# AutoGrind Robot Functions
# File: agscript_robot.script
# Version 1.0
# Programmer: Ned Lecky

global response = "unknown"

global robot_speed = 0.5
global robot_accel = 1.25
global robot_blend = 0.003
global robot_tcp = p[0, 0, 0.175, 0, 0, 0]
global robot_payload_mass = 1.0
global robot_payload_cog = [0, 0, 0.50]
# Geometry [1=FLAT 2=CYL 3=SPHERE, radius_mm)
global robot_part_geometry = [0, 0]

# Defaults get set on load... and can be queried (or changed) from C#
set_tcp(robot_tcp)
set_payload(robot_payload_mass,robot_payload_cog)
set_gravity([0.0, 0.0, 9.82])

# Set interface... allows validation and limits
def set_variable():
  if command[2] == 1:
    # Set speed to s if s>0. Always returns "speed=[current speed]"
    s = command[3]
    if s > 0:
      robot_speed = s
    end
    socket_send_string("robot_speed=")
    socket_send_string(robot_speed)
    socket_send_lf()
    global response = "set_speed()"
  elif command[2] == 2:
    # Set accel to a if a>0. Always returns "accel=[current accel]"
    a = command[3]
    if a > 0:
      robot_accel = a
    end
    socket_send_string("robot_accel=")
    socket_send_string(robot_accel)
    socket_send_lf()
    global response = "set_accel()"
  elif command[2] == 3:
    # Set blend to b if b>=0. Always returns "blend=[current blend]"
    b = command[3]
    if b >= 0:
      robot_blend = b
    end
    socket_send_string("robot_blend=")
    socket_send_string(robot_blend)
    socket_send_lf()
    global response = "set_blend()"
  elif command[2] == 4:
    # Set part_geometry to [shape, radius_mm] is shape>0. Always returns "robot_part_geometry=[current geometry]"
    s = command[3]
    r = command[4]
    if s > 0:
      robot_part_geometry = [s, r]
    end
    socket_send_string("robot_part_geometry=")
    return_vector(robot_part_geometry, 2)
    socket_send_lf()
    global response = "set_blend()"
  elif command[2] == 10:
    # set_tcp if command[3] > -10. Always returns robot_tcp=p[...]
    if command[3] > -10:
      robot_tcp = p[command[3], command[4], command[5], command[6], command[7], command[8]]
      set_tcp(robot_tcp)
    end
    return_pose("robot_tcp", get_tcp_offset())
    global response = "set_tcp()"
  elif command[2] == 11:
    # set_payload if command[3] > 0. Always return robot_m and robot_cog
    if command[3] > 0:
      robot_payload_mass = command[3]
      robot_payload_cog = [command[4], command[5], command[6]]
      set_payload(robot_payload_mass, robot_payload_cog)
    end
    socket_send_string("robot_payload_mass=")
    socket_send_string(robot_payload_mass)
    socket_send_lf()
    socket_send_string("robot_payload_cog=")
    return_vector(robot_payload_cog, 3)
    socket_send_lf()
    global response = "set_payload()"
  else:
    global response = "set_variable ERROR"
  end

end

# Send get_tcp_offset() result to socket
def return_tcp_offset():
  p = get_tcp_offset()
  return_pose("tcp_offset", p)
  global response = "return_tcp_offset()"
end

# Send get_actual_tcp_pose() to socket
def return_actual_tcp_pose():
  p = get_actual_tcp_pose()
  return_pose("actual_tcp_pose", p)
  global response = "return_actual_tcp_pose()"
end

# Send get_actual_joint_positions() to
def return_get_actual_joint_positions():
  p = get_actual_joint_positions()
  return_joints("actual_joint_positions", p)
  global response = "return_get_actual_joint_positions()"
end

# Movel relatively in base coordinates
def movel_relative_base(p1):
  p0 = get_actual_tcp_pose()
  p2 = pose_add(p0, p1)
  movel(p2, robot_accel, robot_speed)
  global response = "movel_relative_base()"
end

# Movel relatively in TCP coordinates
def movel_relative_tcp(p1):
  p1 = pose_trans(get_forward_kin(), p1)
  movel(p1, a = robot_accel, v = robot_speed)
  global response = "movel_relative_tcp()"
end

# Change one element of current pose and movel there
def movel_one_only(index = 0, val = 0):
  p = get_actual_tcp_pose()
  p[index] = val
  movel(p, robot_accel, robot_speed)
  global response = "movel_one_only()"
end

# Change only rotation elements of current pose and movel there
def movel_rot_only(r1 = 0, r2 = 0, r3 = 0):
  p = get_actual_tcp_pose()
  p[3] = r1
  p[4] = r2
  p[5] = r3
  movel(p, robot_accel, robot_speed)
  global response = "movel_rot_only()"
end

# Movej to physical joint positions
def movej_q(q):
  movej(q, robot_accel, robot_speed)
  global response = "movej_q()"
end


# Move to touchoff
#
def calculate_point_to_move_towards(feature, direction, position_distance):
  local posDir = [direction[0], direction[1], direction[2]]
  if (norm(posDir) < 1e-6):
    return get_target_waypoint()
  end
  local direction_vector_normalized = normalize(posDir)
  local displacement_pose = p[direction_vector_normalized[0] * position_distance, direction_vector_normalized[1] * position_distance, direction_vector_normalized[2] * position_distance, 0, 0, 0]
  local wanted_displacement_in_base_frame = pose_sub(pose_trans(feature, displacement_pose), feature)
  return pose_add(get_target_waypoint(), wanted_displacement_in_base_frame)
end
#$ 7 "Robot Program"
#$ 8 "MoveL"
#$ 9 "Direction: Tool Z+"
global move_thread_flag = 0
thread move_thread():
  enter_critical
  move_thread_flag = 1
  local towardsPos = calculate_point_to_move_towards(get_forward_kin(), [0.0, 0.0, 1.0], 0.025)
  movel(towardsPos, a = 0.5, v = 0.02)
  move_thread_flag = 2
  exit_critical
end
def touchoff():
  move_thread_flag = 0
  move_thread_han = run move_thread()
  while (True):
    local targetTcpDirection = get_target_tcp_speed()
    local stepsToRetract = tool_contact(direction = targetTcpDirection)
    if (stepsToRetract > 0):
      kill move_thread_han
      stopl(1.0)
      local backTrackMovement = get_actual_joint_positions_history(stepsToRetract)
      local contactPose = get_forward_kin(backTrackMovement)
      local posDir = [targetTcpDirection[0], targetTcpDirection[1], targetTcpDirection[2]]
      local retractTo = contactPose
      if (norm(posDir) > 1e-6):
        local normalizedPosDir = normalize(posDir)
        local additionalRetraction = p[normalizedPosDir[0] * 0.001, normalizedPosDir[1] * 0.001, normalizedPosDir[2] * 0.001, 0, 0, 0]
        retractTo = pose_sub(contactPose, additionalRetraction)
      end
      movel(retractTo, a = 1.0, v = 0.1)
      #$ 10 "Until (tool_contact_detection)"
      return True
      break
    end
    sleep(1.0E-10)
    if (move_thread_flag > 1):
      join move_thread_han
      #$ 11 "Until (distance)"
      #$ 12 "Popup: No part encountered"
      #popup("No part encountered", "Message", False, False, blocking = True)
      return False
      break
    end
    sync()
  end
  return False
end
