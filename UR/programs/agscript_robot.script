# AutoGrind Robot Functions
# File: agscript_robot.script
# Version 2022.04 A
# Programmer: Ned Lecky


global response = "unknown"

global robot_linear_speed_mps = 0.2
global robot_linear_accel_mpss = 0.4
global robot_blend_radius_m = 0.003
global robot_joint_speed_rps = 1.0
global robot_joint_accel_rpss = 4.0
global robot_tcp = p[0, 0, 0.175, 0, 0, 0]
global robot_tcp_part = robot_tcp
global robot_payload_mass_kg = 1.0
global robot_payload_cog_m = [0, 0, 0.50]
# Geometry [1=FLAT 2=CYL 3=SPHERE, diameter_m)
global robot_part_geometry = [0, 0]
global robot_door_closed_input = [-1, -1]
global robot_tool_on_outputs = [-1, -1, -1, -1, -1, -1, -1, -1]
global robot_tool_off_outputs = [-1, -1, -1, -1, -1, -1, -1, -1]
global robot_coolant_on_outputs = [-1, -1, -1, -1, -1, -1, -1, -1]
global robot_coolant_off_outputs = [-1, -1, -1, -1, -1, -1, -1, -1]
global robot_freedrive_mode = 0

# Defaults get set on load... and can be queried (or changed) from C#
set_tcp(robot_tcp)
set_payload(robot_payload_mass_kg, robot_payload_cog_m)
set_gravity([0.0, 0.0, 9.82])

# Set interface... allows validation and limits
def set_variable():
  if command[2] == 1:
    # Set speed to s if s>0. Always returns current value
    s = command[3]
    if s > 0:
      robot_linear_speed_mps = s / 1000.0
    end
    socket_set_var("robot_linear_speed_mmps", robot_linear_speed_mps * 1000.0)
    global response = "set_linear_speed()"
  elif command[2] == 2:
    # Set accel to a if a>0. Always returns current value
    a = command[3]
    if a > 0:
      robot_linear_accel_mpss = a / 1000.0
    end
    socket_set_var("robot_linear_accel_mmpss", robot_linear_accel_mpss * 1000.0)
    global response = "set_linear_accel()"
  elif command[2] == 3:
    # Set blend to b if b>=0. Always returns current value
    b = command[3]
    if b >= 0:
      robot_blend_radius_m = b / 1000.0
    end
    socket_set_var("robot_blend_radius_mm", robot_blend_radius_m * 1000.0)
    global response = "set_blend_radius()"
  elif command[2] == 4:
    # Set joint speed to s if s>0. Always returns current value
    s = command[3]
    if s > 0:
      robot_joint_speed_rps = d2r(s)
    end
    socket_set_var("robot_joint_speed_dps", r2d(robot_joint_speed_rps))
    global response = "set_joint_speed()"
  elif command[2] == 5:
    # Set joint accel to a if a>0. Always returns current value
    a = command[3]
    if a > 0:
      robot_joint_accel_rpss = d2r(a)
    end
    socket_set_var("robot_joint_accel_dpss", r2d(robot_joint_accel_rpss))
    global response = "set_joint_accel()"
  elif command[2] == 6:
    # Set part_geometry to [shape, diameter_m] is shape>0. Always returns "robot_part_geometry=[current geometry]"
    shape = command[3]
    if shape > 0:
      diameter_m = limiter(command[4], 50, 1100) / 1000.0
      robot_part_geometry = [shape, diameter_m]
    end

    # set robot_tcp_part based on geometry
    if shape == 1:  # Flat
      robot_tcp_part = robot_tcp
    else:  # Cylinder or Sphere
      robot_tcp_part = pose_trans(robot_tcp, p[0, 0, robot_part_geometry[1] / 2.0, 0, 0, 0])
    end

    socket_send_string("robot_part_geometry=")
    return_vector(robot_part_geometry, 2)
    socket_send_lf()
    return_pose("robot_tcp_part", robot_tcp_part)
    global response = "set_part_geometry()"
  elif command[2] == 10:
    # Set door closed IO
    if command[3] >= 0:
      robot_door_closed_input[0] = command[3]
      robot_door_closed_input[1] = command[4]
    end

    socket_send_string("robot_door_closed_input=")
    return_vector(robot_door_closed_input, 2)
    socket_send_lf()
    socket_set_var("robot_door_closed", is_door_closed())
    global response = "set_door_closed_input()"
  elif command[2] == 11:
    # Set tool on Output
    robot_tool_on_outputs = command_3_padded_8(command)

    socket_send_string("robot_tool_on_outputs=")
    return_vector(robot_tool_on_outputs, 8)
    socket_send_lf()
    global response = "set_tool_on_outputs()"
  elif command[2] == 12:
    # Set tool off Output
    robot_tool_off_outputs = command_3_padded_8(command)

    socket_send_string("robot_tool_off_outputs=")
    return_vector(robot_tool_off_outputs, 8)
    socket_send_lf()
    global response = "set_tool_off_outputs()"
  elif command[2] == 13:
    # Set coolant on Output
    robot_coolant_on_outputs = command_3_padded_8(command)

    socket_send_string("robot_coolant_on_outputs=")
    return_vector(robot_coolant_on_outputs, 8)
    socket_send_lf()
    global response = "set_coolant_on_outputs()"
  elif command[2] == 14:
    # Set coolant off Output
    robot_coolant_off_outputs = command_3_padded_8(command)

    socket_send_string("robot_coolant_off_outputs=")
    return_vector(robot_coolant_off_outputs, 8)
    socket_send_lf()
    global response = "set_coolant_off_outputs()"
  elif command[2] == 15:
    # tool_on
    tool_power(True, grind_contact_enable)
    global response = "tool_on()"
  elif command[2] == 16:
    # tool_off
    tool_power(False, grind_contact_enable)
    global response = "tool_off()"
  elif command[2] == 17:
    # coolant_on
    coolant_flow(True, grind_contact_enable)
    global response = "coolant_on()"
  elif command[2] == 18:
    # coolant_off
    coolant_flow(False, grind_contact_enable)
    global response = "coolant_off()"
  elif command[2] == 19:
    # freedrive on/off
    if (command[3] > 0):
      freedrive_mode()
      robot_freedrive_mode = 1
      socket_set_var("robot_freedrive_mode", robot_freedrive_mode)
    else:
      end_freedrive_mode()
      robot_freedrive_mode = 0
      socket_set_var("robot_freedrive_mode", robot_freedrive_mode)
    end
    global response = "freedrive_mode()"
  elif command[2] == 20:
    # set_tcp if command[3] > -10. Always returns robot_tcp=p[...]
    if command[3] > -10:
      robot_tcp = p[command[3], command[4], command[5], command[6], command[7], command[8]]
      robot_tcp_part = robot_tcp
      set_tcp(robot_tcp)
    end
    return_pose("robot_tcp", get_tcp_offset())
    return_pose("robot_tcp_part", robot_tcp_part)
    global response = "set_tcp()"
  elif command[2] == 21:
    # set_payload if command[3] > 0. Always return robot_m and robot_cog
    if command[3] > 0:
      robot_payload_mass_kg = command[3]
      robot_payload_cog_m = [command[4], command[5], command[6]]
      set_payload(robot_payload_mass_kg, robot_payload_cog_m)
    end
    socket_set_var("robot_payload_mass_kg", robot_payload_mass_kg)
    #socket_send_string("robot_payload_mass_kg=")
    #socket_send_string(robot_payload_mass_kg)
    #socket_send_lf()
    socket_send_string("robot_payload_cog_m=")
    return_vector(robot_payload_cog_m, 3)
    socket_send_lf()
    global response = "set_payload()"
  else:
    global response = "set_variable ERROR"
  end

end

# Send get_tcp_offset() result to socket
def return_tcp_offset():
  p = get_tcp_offset()
  return_pose("tcp_offset", p)
  global response = "return_tcp_offset()"
end

# Send get_actual_tcp_pose() to socket
def return_actual_tcp_pose():
  p = get_actual_tcp_pose()
  return_pose("actual_tcp_pose", p)
  global response = "return_actual_tcp_pose()"
end

# Send get_actual_joint_positions() to socket
def return_get_actual_joint_positions():
  p = get_actual_joint_positions()
  return_joints("actual_joint_positions", p)
  global response = "return_get_actual_joint_positions()"
end

# Send both joints and pose to socket labeled position_p and position_q
def return_both_positions():
  return_joints("position_q", get_actual_joint_positions())
  return_pose("position_p", get_actual_tcp_pose())
  global response = "return_both_positions()"
end

# Movel relatively in base coordinates
def movel_relative_base(p1):
  p0 = get_actual_tcp_pose()
  p2 = pose_add(p0, p1)
  movel(p2, robot_linear_accel_mpss, robot_linear_speed_mps)
  global response = "movel_relative_base()"
end

# Movel relatively in TCP coordinates
def movel_relative_tcp(p1):
  p1 = pose_trans(get_forward_kin(), p1)
  movel(p1, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
  global response = "movel_relative_tcp()"
end

# Movel relatively in TCP_part coordinates
def movel_relative_tcp_part(p1):
  set_tcp(robot_tcp_part)
  p1 = pose_trans(get_forward_kin(), p1)
  #p1 = pose_trans(get_forward_kin(q=get_actual_joint_positions(), tcp = robot_tcp_part), p1)
  #p1 = pose_trans(get_forward_kin(q = get_actual_joint_positions(), tcp = robot_tcp_part), p1)
  movel(p1, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
  set_tcp(robot_tcp)
  global response = "movel_relative_tcp_part()"
end

# Change one element of curren#t pose and movel there
def movel_one_only(index = 0, val = 0):
  p = get_actual_tcp_pose()
  p[index] = val
  movel(p, robot_linear_accel_mpss, robot_linear_speed_mps)
  global response = "movel_one_only()"
end

# Change only rotation elements of current pose and movel there
def movel_rot_only(r1 = 0, r2 = 0, r3 = 0):
  p = get_actual_tcp_pose()
  p[3] = r1
  p[4] = r2
  p[5] = r3
  movel(p, robot_linear_accel_mpss, robot_linear_speed_mps)
  global response = "movel_rot_only()"
end

# Movej to position (works with joints or poses)
def movej_ag(p):
  movej(p, a = robot_joint_accel_rpss, v = robot_joint_speed_rps)
  global response = "movej_ag()"
end

# Movel to position (works with joints or poses)
def movel_ag(p):
  movel(p, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
  global response = "movel_ag()"
end


# ####################################################################################
# START AUTOMATED DOOR MONITORING THREAD
#
# Return True if door in closed state (or if door I/IO is undefined)
def is_door_closed():
  if robot_door_closed_input[0] < 0:
    return True
  end
  if get_standard_digital_in(robot_door_closed_input[0]):
    f = 1
  else:
    f = 0
  end
  return f == robot_door_closed_input[1]
end

global robot_door_closed = is_door_closed()
global time_in_uncommanded_grind = 0
global time_door_check_rate_s = 0.250
global grind_max_wait_ms = 1500
thread door_monitor_thread():
  while True:
    sleep(time_door_check_rate_s)
    new_door_closed = is_door_closed()

    # Notify host if door state has changed
    if robot_door_closed != new_door_closed:
      robot_door_closed = new_door_closed
      socket_set_var("robot_door_closed", robot_door_closed)
    end

    # Check for still in grind process but not executing a grind command
    # This is what happens after a grind_...(....,1) executes while waiting for next command
    if grind_process_state and grind_ready:
      time_in_uncommanded_grind = time_in_uncommanded_grind + time_door_check_rate_s
      # No new grind commands for grind_max_wait_ms... schedule a grind_retract!
      if time_in_uncommanded_grind > grind_max_wait_ms / 1000.0:
        global halt_grind = True
      end
    else:
      time_in_uncommanded_grind = 0
    end
  end
end
global doorMonitorThread = run door_monitor_thread()
#
# END AUTOMATED DOOR MONITORING THREAD
# ####################################################################################

# ####################################################################################
# START NO_COMMAND HOUSEKEEPING
# This gets called when the PolyScope receives no command (about 1/second)
# We can fire off any command here safely since no others will be seen until we exit
#
global no_command_count = 0
global halt_grind  = False
def no_command():
  global no_command_count = no_command_count + 1

  if halt_grind:
    halt_grind=False
    # Simulate receiving a (40,0) (grind_retract)
    command[0]=3
    command[1]=40
    command[2]=0
    pattern_grind()
  end
end
#
# END NO_COMMAND HOUSEKEEPING
# ####################################################################################

# ####################################################################################
# TIMER TICK THREAD (NOT IN USE)
#
#global ticks = 0
#global runtime = 0
#thread ticker_thread():
#  while (True):
#    global ticks = ticks + 1
#    global runtime = ticks / 500
#    sync()
#  end
#end
#global tickerThread = run ticker_thread()
#
# END TIMER TICK THREAD
# ####################################################################################

######################################################################################
# Movel_int  Segmented movel
#
global grind_distance_m = 0
def movel_int(p, a = 1.2, v = 0.25, t = 0, r = 0, t_move = 1):
  #movel(p, a, v, t, r)
  #return None

  p0 = get_target_tcp_pose()
  global grind_n_segments = limiter(ceil(t_move * 4.0), 1, 1000)

  i = 1
  while i <= grind_n_segments and ok_to_proceed():
    p1 = interpolate_pose(p0, p, i / grind_n_segments)
    movel(p1, a = a, v = v, r = r)
    i = i + 1
  end
  return None
end
#
# Movel_int  Interruptable movel
######################################################################################


# ####################################################################################
# START TOUCHOFF HANDLER
#
def calculate_point_to_move_towards(feature, direction, position_distance):
  local posDir = [direction[0], direction[1], direction[2]]
  if (norm(posDir) < 1e-6):
    return get_target_waypoint()
  end
  local direction_vector_normalized = normalize(posDir)
  local displacement_pose = p[direction_vector_normalized[0] * position_distance, direction_vector_normalized[1] * position_distance, direction_vector_normalized[2] * position_distance, 0, 0, 0]
  local wanted_displacement_in_base_frame = pose_sub(pose_trans(feature, displacement_pose), feature)
  return pose_add(get_target_waypoint(), wanted_displacement_in_base_frame)
end
#$ 7 "Robot Program"
#$ 8 "MoveL"
#$ 9 "Direction: Tool Z+"
global move_thread_flag = 0
global move_thread_approach_speed_mps = 0.01
thread move_thread():
  enter_critical
  move_thread_flag = 1
  local towardsPos = calculate_point_to_move_towards(get_forward_kin(), [0.0, 0.0, 1.0], 0.025)
  movel(towardsPos, a = 0.5, v = move_thread_approach_speed_mps)
  move_thread_flag = 2
  exit_critical
end
# Currently using speed_mmps for both approach and 2X for departure
def touchoff(approach_speed_mmps, retract_mm):
  approach_speed_mps = approach_speed_mmps / 1000.0
  global move_thread_approach_speed_mps = approach_speed_mps

  retract_speed_mps = approach_speed_mps * 2.0

  retract_m = retract_mm / 1000.0

  move_thread_flag = 0
  move_thread_han = run move_thread()
  while (True):
    local targetTcpDirection = get_target_tcp_speed()
    local stepsToRetract = tool_contact(direction = targetTcpDirection)
    if (stepsToRetract > 0):
      kill move_thread_han
      stopl(1.0)
      local backTrackMovement = get_actual_joint_positions_history(stepsToRetract)
      local contactPose = get_forward_kin(backTrackMovement)
      local posDir = [targetTcpDirection[0], targetTcpDirection[1], targetTcpDirection[2]]
      local retractTo = contactPose
      if (norm(posDir) > 1e-6):
        local normalizedPosDir = normalize(posDir)
        local additionalRetraction = p[normalizedPosDir[0] * retract_m, normalizedPosDir[1] * retract_m, normalizedPosDir[2] * retract_m, 0, 0, 0]
        retractTo = pose_sub(contactPose, additionalRetraction)
      end
      movel(retractTo, a = 1.0, v = retract_speed_mps)
      #$ 10 "Until (tool_contact_detection)"
      return True
      break
    end
    sleep(1.0E-10)
    if (move_thread_flag > 1):
      join move_thread_han
      #$ 11 "Until (distance)"
      #$ 12 "Popup: No part encountered"
      #popup("No part encountered", "Message", False, False, blocking = True)
      return False
      break
    end
    sync()
  end
  return False
end
#
# END TOUCHOFF HANDLER
# ####################################################################################
