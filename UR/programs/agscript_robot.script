# AutoGrind Robot Functions
# File: agscript_robot.script
# Version 1.0
# Programmer: Ned Lecky

global response = "unknown"

global robot_linear_speed_mps = 0.2
global robot_linear_accel_mpss = 0.4
global robot_blend_radius_m = 0.003
global robot_joint_speed_rps = 1.0
global robot_joint_accel_rpss = 4.0
global robot_tcp = p[0, 0, 0.175, 0, 0, 0]
global robot_tcp_part = robot_tcp
global robot_payload_mass_kg = 1.0
global robot_payload_cog_m = [0, 0, 0.50]
# Geometry [1=FLAT 2=CYL 3=SPHERE, diameter_m)
global robot_part_geometry = [0, 0]

# Defaults get set on load... and can be queried (or changed) from C#
set_tcp(robot_tcp)
set_payload(robot_payload_mass_kg, robot_payload_cog_m)
set_gravity([0.0, 0.0, 9.82])

# Set interface... allows validation and limits
def set_variable():
  if command[2] == 1:
    # Set speed to s if s>0. Always returns current value
    s = command[3]
    if s > 0:
      robot_linear_speed_mps = s / 1000.0
    end
    socket_send_string("robot_linear_speed_mmps=")
    socket_send_string(robot_linear_speed_mps * 1000.0)
    socket_send_lf()
    global response = "set_linear_speed()"
  elif command[2] == 2:
    # Set accel to a if a>0. Always returns current value
    a = command[3]
    if a > 0:
      robot_linear_accel_mpss = a / 1000.0
    end
    socket_send_string("robot_linear_accel_mmpss=")
    socket_send_string(robot_linear_accel_mpss * 1000.0)
    socket_send_lf()
    global response = "set_linear_accel()"
  elif command[2] == 3:
    # Set blend to b if b>=0. Always returns current value
    b = command[3]
    if b >= 0:
      robot_blend_radius_m = b / 1000.0
    end
    socket_send_string("robot_blend_radius_mm=")
    socket_send_string(robot_blend_radius_m * 1000.0)
    socket_send_lf()
    global response = "set_blend_radius()"
  elif command[2] == 4:
    # Set joint speed to s if s>0. Always returns current value
    s = command[3]
    if s > 0:
      robot_joint_speed_rps = d2r(s)
    end
    socket_send_string("robot_joint_speed_dps=")
    socket_send_string(r2d(robot_joint_speed_rps))
    socket_send_lf()
    global response = "set_joint_speed()"
  elif command[2] == 5:
    # Set joint accel to a if a>0. Always returns current value
    a = command[3]
    if a > 0:
      robot_joint_accel_rpss = d2r(a)
    end
    socket_send_string("robot_joint_accel_dpss=")
    socket_send_string(r2d(robot_joint_accel_rpss))
    socket_send_lf()
    global response = "set_joint_accel()"
  elif command[2] == 6:
    # Set part_geometry to [shape, diameter_m] is shape>0. Always returns "robot_part_geometry=[current geometry]"
    shape = command[3]
    if shape > 0:
      diameter_m = command[4] / 1000.0
      robot_part_geometry = [shape, diameter_m]
    end

    # set robot_tcp_part based on geometry
    if shape == 1:  # Flat
      robot_tcp_part = robot_tcp
    else:  # Cylinder or Sphere
      robot_tcp_part = pose_trans(robot_tcp, p[0, 0, robot_part_geometry[1] / 2.0, 0, 0, 0])
    end

    socket_send_string("robot_part_geometry=")
    return_vector(robot_part_geometry, 2)
    socket_send_lf()
    return_pose("robot_tcp_part", robot_tcp_part)
    global response = "set_part_geometry()"
  elif command[2] == 10:
    # set_tcp if command[3] > -10. Always returns robot_tcp=p[...]
    if command[3] > -10:
      robot_tcp = p[command[3], command[4], command[5], command[6], command[7], command[8]]
      robot_tcp_part = robot_tcp
      set_tcp(robot_tcp)
    end
    return_pose("robot_tcp", get_tcp_offset())
    return_pose("robot_tcp_part", robot_tcp_part)
    global response = "set_tcp()"
  elif command[2] == 11:
    # set_payload if command[3] > 0. Always return robot_m and robot_cog
    if command[3] > 0:
      robot_payload_mass_kg = command[3]
      robot_payload_cog_m = [command[4], command[5], command[6]]
      set_payload(robot_payload_mass_kg, robot_payload_cog_m)
    end
    socket_send_string("robot_payload_mass_kg=")
    socket_send_string(robot_payload_mass_kg)
    socket_send_lf()
    socket_send_string("robot_payload_cog_m=")
    return_vector(robot_payload_cog_m, 3)
    socket_send_lf()
    global response = "set_payload()"
  else:
    global response = "set_variable ERROR"
  end

end

# Send get_tcp_offset() result to socket
def return_tcp_offset():
  p = get_tcp_offset()
  return_pose("tcp_offset", p)
  global response = "return_tcp_offset()"
end

# Send get_actual_tcp_pose() to socket
def return_actual_tcp_pose():
  p = get_actual_tcp_pose()
  return_pose("actual_tcp_pose", p)
  global response = "return_actual_tcp_pose()"
end

# Send get_actual_joint_positions() to socket
def return_get_actual_joint_positions():
  p = get_actual_joint_positions()
  return_joints("actual_joint_positions", p)
  global response = "return_get_actual_joint_positions()"
end

# Send both joints and pose to socket labeled position_p and position_q
def return_both_positions():
  return_joints("position_q", get_actual_joint_positions())
  return_pose("position_p", get_actual_tcp_pose())
  global response = "return_both_positions()"
end

# Movel relatively in base coordinates
def movel_relative_base(p1):
  p0 = get_actual_tcp_pose()
  p2 = pose_add(p0, p1)
  movel(p2, robot_linear_accel_mpss, robot_linear_speed_mps)
  global response = "movel_relative_base()"
end

# Movel relatively in TCP coordinates
def movel_relative_tcp(p1):
  p1 = pose_trans(get_forward_kin(), p1)
  movel(p1, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
  global response = "movel_relative_tcp()"
end

# Movel relatively in TCP_part coordinates
def movel_relative_tcp_part(p1):
  set_tcp(robot_tcp_part)
  p1 = pose_trans(get_forward_kin(), p1)
  #p1 = pose_trans(get_forward_kin(q=get_actual_joint_positions(), tcp = robot_tcp_part), p1)
  #p1 = pose_trans(get_forward_kin(q = get_actual_joint_positions(), tcp = robot_tcp_part), p1)
  movel(p1, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
  set_tcp(robot_tcp)
  global response = "movel_relative_tcp_part()"
end

# Change one element of current pose and movel there
def movel_one_only(index = 0, val = 0):
  p = get_actual_tcp_pose()
  p[index] = val
  movel(p, robot_linear_accel_mpss, robot_linear_speed_mps)
  global response = "movel_one_only()"
end

# Change only rotation elements of current pose and movel there
def movel_rot_only(r1 = 0, r2 = 0, r3 = 0):
  p = get_actual_tcp_pose()
  p[3] = r1
  p[4] = r2
  p[5] = r3
  movel(p, robot_linear_accel_mpss, robot_linear_speed_mps)
  global response = "movel_rot_only()"
end

# Movej to position (works with joints or poses)
def movej_ag(p):
  movej(p, a = robot_joint_accel_rpss, v = robot_joint_speed_rps)
  global response = "movej_ag()"
end

# Movel to position (works with joints or poses)
def movel_ag(p):
  movel(p, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
  global response = "movel_ag()"
end


# Move to touchoff
#
def calculate_point_to_move_towards(feature, direction, position_distance):
  local posDir = [direction[0], direction[1], direction[2]]
  if (norm(posDir) < 1e-6):
    return get_target_waypoint()
  end
  local direction_vector_normalized = normalize(posDir)
  local displacement_pose = p[direction_vector_normalized[0] * position_distance, direction_vector_normalized[1] * position_distance, direction_vector_normalized[2] * position_distance, 0, 0, 0]
  local wanted_displacement_in_base_frame = pose_sub(pose_trans(feature, displacement_pose), feature)
  return pose_add(get_target_waypoint(), wanted_displacement_in_base_frame)
end
#$ 7 "Robot Program"
#$ 8 "MoveL"
#$ 9 "Direction: Tool Z+"
global move_thread_flag = 0
thread move_thread():
  enter_critical
  move_thread_flag = 1
  local towardsPos = calculate_point_to_move_towards(get_forward_kin(), [0.0, 0.0, 1.0], 0.025)
  movel(towardsPos, a = 0.5, v = 0.02)
  move_thread_flag = 2
  exit_critical
end
def touchoff():
  move_thread_flag = 0
  move_thread_han = run move_thread()
  while (True):
    local targetTcpDirection = get_target_tcp_speed()
    local stepsToRetract = tool_contact(direction = targetTcpDirection)
    if (stepsToRetract > 0):
      kill move_thread_han
      stopl(1.0)
      local backTrackMovement = get_actual_joint_positions_history(stepsToRetract)
      local contactPose = get_forward_kin(backTrackMovement)
      local posDir = [targetTcpDirection[0], targetTcpDirection[1], targetTcpDirection[2]]
      local retractTo = contactPose
      if (norm(posDir) > 1e-6):
        local normalizedPosDir = normalize(posDir)
        local additionalRetraction = p[normalizedPosDir[0] * 0.001, normalizedPosDir[1] * 0.001, normalizedPosDir[2] * 0.001, 0, 0, 0]
        retractTo = pose_sub(contactPose, additionalRetraction)
      end
      movel(retractTo, a = 1.0, v = 0.1)
      #$ 10 "Until (tool_contact_detection)"
      return True
      break
    end
    sleep(1.0E-10)
    if (move_thread_flag > 1):
      join move_thread_han
      #$ 11 "Until (distance)"
      #$ 12 "Popup: No part encountered"
      #popup("No part encountered", "Message", False, False, blocking = True)
      return False
      break
    end
    sync()
  end
  return False
end
