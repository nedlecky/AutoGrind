def AutoGrind01():
  set_tcp(p[0.0,0.0,0.1,3.141592653589793,0.0,0.0])
  set_payload(2.0)
  step_count_80ca3340_be0f_485b_b5f6_d0f23eb4131f = 0.0
  thread Step_Counter_Thread_f8839622_9f7f_4642_a971_8a51eb577eb7():
    while (True):
      step_count_80ca3340_be0f_485b_b5f6_d0f23eb4131f = step_count_80ca3340_be0f_485b_b5f6_d0f23eb4131f + 1.0
      sync()
    end
  end
  run Step_Counter_Thread_f8839622_9f7f_4642_a971_8a51eb577eb7()
  set_safety_mode_transition_hardness(1)
  set_standard_analog_input_domain(0, 1)
  set_standard_analog_input_domain(1, 1)
  set_tool_analog_input_domain(0, 1)
  set_tool_analog_input_domain(1, 1)
  set_analog_outputdomain(0, 0)
  set_analog_outputdomain(1, 0)
  set_input_actions_to_default()
  set_gravity([0.0, 0.0, 9.82])
  set_tool_communication(False, 115200, 0, 1, 1.5, 3.5)
  set_tool_output_mode(0)
  set_tool_digital_output_mode(0, 1)
  set_tool_digital_output_mode(1, 1)
  set_tool_voltage(0)
  global Vertical_1_p=p[-.139608417872, -.431276583102, .028138902829, -.001221359682, 3.116276528482, .038891915637]
  global Vertical_1_q=[-1.6006999999999998, -1.7271, -2.2029999999999994, -0.8079999999999998, 1.5951, -0.030999999999999694]
  global Tilted_2_p=p[-.139608417868, -.431276582996, .028138902982, -.011381173019, 3.019426224372, -.776094768972]
  global Tilted_2_q=[-1.6143181432207498, -1.730963551856462, -2.588173794846753, 0.1085536174237972, 1.6168206000396343, -0.039262279865630134]
  global Vertical_2_p=p[-.139608417866, -.431276582919, .131081236338, -.001221329928, 3.116276528722, .038891910429]
  global Vertical_2_q=[-1.600700000064136, -1.5575468977702354, -2.0619765024476475, -1.1185765962043455, 1.595100000182046, -0.030999980927620463]
  global Vertical_5_p=p[-.139608417872, -.431276583102, .028138902829, -.001221359682, 3.116276528482, .038891915637]
  global Vertical_5_q=[-1.6006999999999998, -1.7271, -2.2029999999999994, -0.8079999999999998, 1.5951, -0.030999999999999694]
  def AG_50():
    $ 64 "AG_50" "noBreak"
    $ 65 "MoveL"
    $ 66 "Vertical_1" "breakAfter"
    movel(Vertical_1_p, a=1.2, v=0.25)
    $ 67 "Tilted_2" "breakAfter"
    movel(Tilted_2_p, a=1.2, v=0.25)
    $ 68 "Vertical_2" "breakAfter"
    movel(Vertical_2_p, a=1.2, v=0.25)
    $ 69 "Vertical_5" "breakAfter"
    movel(Vertical_5_p, a=1.2, v=0.25)
  end
  $ 1 "BeforeStart"
  $ 2 "Script: agscript_util.script"
  # AutoGrind General UR Utilities
  # File: agscript_util.script
  # Version 1.0
  # Programmer: Ned Lecky
  
  # Send CRLF out the socket
  def socket_send_crlf():
    socket_send_byte(13)
    socket_send_byte(10)
  end
  
  # Send LF out the socket
  def socket_send_lf():
    socket_send_byte(10)
  end
  
  # Send 6-vectors back to socket as [n,n,n,n,n,n]
  def return_vector(p):
    socket_send_string("[")
    i = 0
    while i < 6:
      if i > 0:
        socket_send_string(",")
      end
      socket_send_string(p[i])
      i = i + 1
    end
    socket_send_string("]")
  end
  
  # Send 6-element position back to socket as:
  #   (isPose=False) name=[n,n,n,n,n,n]
  #   (isPose=True)name=p[n,n,n,n,n,n]
  def return_position(name, isPose, p):
    socket_send_string(name)
    socket_send_string("=")
    if isPose == True:
      socket_send_string("p")
    end
    return_vector(p)
    socket_send_lf()
  end
  
  # Return a 6-element vector as a pose name=p[.....]
  def return_pose(name, p):
    return_position(name, True, p)
  end
  
  # Return a 6-element vector as joint angles name=[.....]
  def return_joints(name, p):
    return_position(name, False, p)
  end
  $ 3 "Script: agscript_robot.script"
  # AutoGrind Robot Functions
  # File: agscript_robot.script
  # Version 1.0
  # Programmer: Ned Lecky
  
  global response = "unknown"
  
  global robot_speed = 0.3
  global robot_accel = 0.3
  
  # Set speed to s if s<>0. Always returns "speed=[current speed]"
  def set_speed(s):
    if s > 0:
      robot_speed = s
    end
    socket_send_string("robot_speed=")
    socket_send_string(robot_speed)
    socket_send_lf()
    global response = "set_speed()"
  end
  
  # Set accel to a if a<>0. Always returns "accel=[current accel]"
  def set_accel(a):
    if a > 0:
      robot_accel = a
    end
    socket_send_string("robot_accel=")
    socket_send_string(robot_accel)
    socket_send_lf()
    global response = "set_accel()"
  end
  
  # Send get_tcp_offset() result to socket
  def return_tcp_offset():
    p = get_tcp_offset()
    return_pose("tcp_offset", p)
    global response = "return_tcp_offset()"
  end
  
  # Send get_actual_tcp_pose() to socket
  def return_actual_tcp_pose():
    p = get_actual_tcp_pose()
    return_pose("actual_tcp_pose", p)
    global response = "return_actual_tcp_pose()"
  end
  
  # Send get_actual_joint_positions() to
  def return_get_actual_joint_positions():
    p = get_actual_joint_positions()
    return_joints("actual_joint_positions", p)
    global response = "return_get_actual_joint_positions()"
  end
  
  # Movel relatively
  def movel_relative(p1):
    p0 = get_actual_tcp_pose()
    p2 = pose_add(p0, p1)
    movel(p2, robot_accel, robot_speed)
    global response = "movel_relative()"
  end
  
  # Change one element of current pose and movel there
  def movel_one_only(index=0, val = 0):
    p = get_actual_tcp_pose()
    p[index] = val
    movel(p, robot_accel, robot_speed)
    global response = "movel_one_only()"
  end
  
  # Change only rotation elements of current pose and movel there
  def movel_rot_only(r1=0, r2=0, r3=0):
    p = get_actual_tcp_pose()
    p[3] = r1
    p[4] = r2
    p[5] = r3
    movel(p, robot_accel, robot_speed)
    global response = "movel_rot_only()"
  end
  
  # Movej to physical joint positions
  def movej_q(q):
    movej(q, robot_accel, robot_speed)
    global response = "movej_q()"
  end
  $ 4 "Script: agscript_grind.script"
  # AutoGrind Grinding Functions
  # File: agscript_grind.script
  # Version 1.0
  # Programmer: Ned Lecky
  
  global listenerThread = 0
  global threadCount = 0
  global haltCount = 0
  global haltCommand = [0, 0]
  
  global tool_length_m = 0.100
  
  global grind_dryrun = False
  
  def tool_power(on = False):
  
    return None
  end
  
  def coolant_flow(on = False):
  
    return None
  end
  
  def apply_force(on = False):
  
    return None
  end
  
  # Get into contact with part (or away from)
  def contact_part(on = False):
    if on:
      # Advance until contact
      # Simulated....
      p1 = pose_trans(get_forward_kin(), p[0, 0, 0.020, 0, 0, 0])
      movel(p1, robot_accel, robot_speed)
  
      # TODO if fails should return to initial position
    else:
      p1 = pose_trans(get_forward_kin(), p[0, 0, -0.020, 0, 0, 0])
      movel(p1, robot_accel, robot_speed)
    end
  
    return True
  end
  
  # Setup for grinding
  global grinding_state = False
  def set_grinding_state(on = False):
    if on and not grinding_state:
      if grind_dryrun:
        return True
      end
      if not contact_part(True):
        return False
      end
      tool_power(True)
      coolant_flow(True)
      apply_force(True)
      grinding_state = True
      return True
    elif not on and grinding_state:
      apply_force(False)
      contact_part(False)
      coolant_flow(False)
      tool_power(False)
      grinding_state = False
      return True
    end
    return True
  end
  
  # Abort system
  thread listener_thread():
    global haltCommand = [0, 0]
    global haltCount = 0
    while (True):
      global threadCount = threadCount + 1
      global haltCommand = socket_read_ascii_float(1, timeout = 0.1)
      if haltCommand[0] > 0:
        global haltCount = haltCount + 1
      end
    end
  
    return False
  end
  
  def ok_to_proceed():
    return haltCount == 0
  end
  
  # Execute the desired pattern grind selected by command[2]
  def pattern_grind():
    #global listen_thread
    if listenerThread > 0:
      kill listenerThread
      listenerThread = 0
    end
    listenerThread = run listener_thread()
  
    global grind_busy = True
    socket_send_line("grind_busy=True")
    global grind_cycle = 0
    global grind_n_cycles = 0
    global grind_dx_mm = 0
    global grind_dx2_mm = 0
    global grind_dy_mm = 0
    global grind_n_spirals = 0
    global grind_radius_mm = 0
    global grind_xstep_mm = 0
    global grind_ystep_mm = 0
    global grind_rstep_mm = 0
  
    if command[2] == 1:
      global response = "set grind_dryrun"
      if command[3] > 0:
        global grind_dryrun = True
        socket_send_line("grind_dryrun=True")
      else:
        global grind_dryrun = False
        socket_send_line("grind_dryrun=False")
      end
    elif command[2] == 10:
      global response = "grind_flat_rect"
      global grind_dx_mm = command[3]
      global grind_dy_mm = command[4]
      global grind_n_cycles = command[5]
      grind_flat_rect(grind_dx_mm, grind_dy_mm, grind_n_cycles)
    elif command[2] == 20:
      global response = "grind_cyl_rect"
      global grind_dx_mm = command[3]
      global grind_dy_mm = command[4]
      global grind_radius_mm = command[5]
      global grind_n_cycles = command[6]
      grind_cyl_rect(grind_dx_mm, grind_dy_mm, grind_radius_mm, grind_n_cycles)
    elif command[2] == 25:
      global response = "grind_sphere_rect"
      global grind_dx_mm = command[3]
      global grind_dy_mm = command[4]
      global grind_radius_mm = command[5]
      global grind_n_cycles = command[6]
      grind_sphere_rect(grind_dx_mm, grind_dy_mm, grind_radius_mm, grind_n_cycles)
    elif command[2] == 30:
      global response = "grind_flat_serp"
      global grind_dx_mm = command[3]
      global grind_dy_mm = command[4]
      global grind_xstep_mm = command[5]
      global grind_ystep_mm = command[6]
      global grind_n_cycles = command[7]
      grind_flat_serp(grind_dx_mm, grind_dy_mm, grind_xstep_mm, grind_ystep_mm, grind_n_cycles)
    elif command[2] == 40:
      global response = "grind_cyl_serp"
      global grind_dx_mm = command[3]
      global grind_dy_mm = command[4]
      global grind_xstep_mm = command[5]
      global grind_ystep_mm = command[6]
      global grind_radius_mm = command[7]
      global grind_n_cycles = command[8]
      grind_cyl_serp(grind_dx_mm, grind_dy_mm, grind_xstep_mm, grind_ystep_mm, grind_radius_mm, grind_n_cycles)
    elif command[2] == 50:
      global response = "grind_flat_circle"
      global grind_dx_mm = command[3]
      global grind_n_cycles = command[4]
      grind_flat_circle(grind_dx_mm, grind_n_cycles)
    elif command[2] == 60:
      global response = "grind_flat_spiral"
      global grind_dx_mm = command[3]
      global grind_dx2_mm = command[4]
      global grind_n_spirals = command[5]
      global grind_n_cycles = command[6]
      grind_flat_spiral(grind_dx_mm, grind_dx2_mm, grind_n_spirals, grind_n_cycles)
    else:
      global response = "Unknown Grind Command"
    end
  
    kill listenerThread
    listenerThread = 0
    global grind_busy = False
    socket_send_line("grind_busy=False")
  end
  
  # Grind along a flat rect dx_mm x dy_mm centered on current tool position. Repeat n_cycles times.
  # Move in x direction first, then y
  def grind_flat_rect(dx_mm, dy_mm, n_cycles):
    if n_cycles < 1:
      return True
    end
  
    # Unit conversion
    dx_m = dx_mm / 1000.0
    dy_m = dy_mm / 1000.0
  
    # Find initial position p0
    set_tcp(p[0, 0, tool_length_m, 0, 0, 0])
    p0 = get_actual_tcp_pose()
  
    # Move to offset position bottom left of scan area
    p1 = pose_trans(get_forward_kin(), p[-dx_m / 2, -dy_m / 2, 0, 0, 0, 0])
    movel(p1, robot_accel, robot_speed)
  
    if not set_grinding_state(True):
      movel(p0, robot_accel, robot_speed)
      return False
    end
  
    # Grind box pattern
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      if ok_to_proceed():
        p1 = pose_trans(get_forward_kin(), p[dx_m, 0, 0, 0, 0, 0])
        movel(p1, robot_accel, robot_speed)
      end
  
      if ok_to_proceed():
        p1 = pose_trans(get_forward_kin(), p[0, dy_m, 0, 0, 0, 0])
        movel(p1, robot_accel, robot_speed)
      end
  
      if ok_to_proceed():
        p1 = pose_trans(get_forward_kin(), p[-dx_m, 0, 0, 0, 0, 0])
        movel(p1, robot_accel, robot_speed)
      end
  
      if ok_to_proceed():
        p1 = pose_trans(get_forward_kin(), p[0, -dy_m, 0, 0, 0, 0])
        movel(p1, robot_accel, robot_speed)
      end
      grind_cycle = grind_cycle + 1
    end
  
    set_grinding_state(False)
  
    # Return robot back to initial position
    movel(p0, robot_accel, robot_speed)
    return True
  end
  
  # Grind along a cylindrical rect dx_mm,dy_mm with radius_mm centered on current tool position. Repeat n_cycles times.
  # Move in x direction first, then r
  def grind_cyl_rect(dx_mm, dy_mm, radius_mm, n_cycles):
    if n_cycles < 1:
      return False
    end
  
    # Unit conversion
    dx_m = dx_mm / 1000.0
    radius_m = radius_mm / 1000.0
    drx_rad = dy_mm / radius_mm
  
    # Find initial position p0
    set_tcp(p[0, 0, tool_length_m + radius_m, 0, 0, 0])
    p0 = get_actual_tcp_pose()
  
    # Move to offset position bottom left of scan area
    p1 = pose_trans(get_forward_kin(), p[-dx_m / 2, 0, 0, -drx_rad / 2, 0, 0])
    movel(p1, robot_accel, robot_speed)
  
    if not set_grinding_state(True):
      movel(p0, robot_accel, robot_speed)
      return False
    end
  
    # Grind cylindrical box pattern
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      if ok_to_proceed():
        p1 = pose_trans(get_forward_kin(), p[dx_m, 0, 0, 0, 0, 0])
        movel(p1, robot_accel, robot_speed)
      end
  
      if ok_to_proceed():
        p1 = pose_trans(get_forward_kin(), p[0, 0, 0, drx_rad, 0, 0])
        movel(p1, robot_accel, robot_speed)
      end
  
      if ok_to_proceed():
        p1 = pose_trans(get_forward_kin(), p[-dx_m, 0, 0, 0, 0, 0])
        movel(p1, robot_accel, robot_speed)
      end
  
      if ok_to_proceed():
        p1 = pose_trans(get_forward_kin(), p[0, 0, 0, -drx_rad, 0, 0])
        movel(p1, robot_accel, robot_speed)
      end
      grind_cycle = grind_cycle + 1
    end
  
    set_grinding_state(False)
  
    # Return robot back to initial position
    movel(p0, robot_accel, robot_speed)
    return True
  end
  
  # Grind along a cylindrical rect dx_mm,dy_mm with radius_mm centered on current tool position. Repeat n_cycles times.
  # Move in x direction first, then r
  def grind_sphere_rect(dx_mm, dy_mm, radius_mm, n_cycles):
    if n_cycles < 1:
      return False
    end
  
    # Unit conversion
    radius_m = radius_mm / 1000.0
    drx_rad = dx_mm / radius_mm
    dry_rad = dy_mm / radius_mm
  
    # Find initial position p0
    set_tcp(p[0, 0, tool_length_m + radius_m, 0, 0, 0])
    p0 = get_actual_tcp_pose()
  
    # Move to offset position bottom left of scan area
    p1 = pose_trans(get_forward_kin(), p[0, 0, 0, -drx_rad / 2, -dry_rad / 2, 0])
    movel(p1, robot_accel, robot_speed)
  
    if not set_grinding_state(True):
      movel(p0, robot_accel, robot_speed)
      return False
    end
  
    # Grind cylindrical box pattern
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      if ok_to_proceed():
        p1 = pose_trans(get_forward_kin(), p[0, 0, 0, drx_rad, 0, 0])
        movel(p1, robot_accel, robot_speed)
      end
  
      if ok_to_proceed():
        p1 = pose_trans(get_forward_kin(), p[0, 0, 0, 0, dry_rad, 0])
        movel(p1, robot_accel, robot_speed)
      end
  
      if ok_to_proceed():
        p1 = pose_trans(get_forward_kin(), p[0, 0, 0, -drx_rad, 0, 0])
        movel(p1, robot_accel, robot_speed)
      end
  
      if ok_to_proceed():
        p1 = pose_trans(get_forward_kin(), p[0, 0, 0, 0, -dry_rad, 0])
        movel(p1, robot_accel, robot_speed)
      end
      grind_cycle = grind_cycle + 1
    end
  
    set_grinding_state(False)
  
    # Return robot back to initial position
    movel(p0, robot_accel, robot_speed)
    return True
  end
  
  # Grind along a flat serpentine dx_mm,dy_mm incrementing by xstep_mm,ystep_mm centered on current tool position. Repeat n_cycles times.
  # Move in x direction first, then y
  def grind_flat_serp(dx_mm, dy_mm, xstep_mm, ystep_mm, n_cycles):
    if n_cycles < 1:
      return False
    end
  
    # Unit conversion
    dx_m = dx_mm / 1000.0
    dy_m = dy_mm / 1000.0
    xstep_m = xstep_mm / 1000.0
    ystep_m = ystep_mm / 1000.0
    x_grid_count = floor(dx_m / xstep_m)
    y_grid_count = floor(dy_m / ystep_m)
  
    # Find initial position
    set_tcp(p[0, 0, tool_length_m, 0, 0, 0])
    p0 = get_actual_tcp_pose()
  
    # Move to offset position bottom left of scan area
    p1 = pose_trans(get_forward_kin(), p[-dx_m / 2, -dy_m / 2, 0, 0, 0, 0])
    movel(p1, robot_accel, robot_speed)
  
    if not set_grinding_state(True):
      movel(p0, robot_accel, robot_speed)
      return False
    end
  
    # Grind serpentine pattern
    global grind_cycle = 1
    x_grid = 0
    y_grid = 0
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      # Advance x by xstep_m
      if ok_to_proceed():
        p1 = pose_trans(get_forward_kin(), p[xstep_m, 0, 0, 0, 0, 0])
        movel(p1, robot_accel, robot_speed)
        # Track new grid square we're in
        if xstep_m > 0:
          x_grid = x_grid + 1
        else:
          x_grid = x_grid - 1
        end
      end
      # Adjust x direction
      if x_grid >= x_grid_count-1 and xstep_m > 0:
        xstep_m = -xstep_m
      elif x_grid == 0 and xstep_m < 0:
        xstep_m = -xstep_m
      end
  
      # Advance y by ystep_m
      if ok_to_proceed():
        p1 = pose_trans(get_forward_kin(), p[0, ystep_m, 0, 0, 0, 0])
        movel(p1, robot_accel, robot_speed)
        # Track new grid square we're in
        if ystep_m > 0:
          y_grid = y_grid + 1
        else:
          y_grid = y_grid - 1
        end
      end
      # Adjust y direction
      if y_grid >= y_grid_count-1 and ystep_m > 0:
        ystep_m = -ystep_m
      elif y_grid == 0 and ystep_m < 0:
        ystep_m = -ystep_m
      end
  
      # Detect when we've covered all the grid squares!
      # That's when you reach n-1,n-1 or 0,0
      if x_grid == x_grid_count - 1 and y_grid == y_grid_count - 1:
        grind_cycle = grind_cycle + 1
      elif x_grid == 0 and y_grid == 0:
        grind_cycle = grind_cycle + 1
      end
    end
  
    set_grinding_state(False)
  
    # Return robot back to initial position
    movel(p0, robot_accel, robot_speed)
    return True
  end
  
  # Grind along a cylindrical serpentine dx_mm,dy_mm incrementing by xstep_mm,rstep_mm centered on current tool position. Repeat n_cycles times.
  # Move in x direction first, then r
  def grind_cyl_serp(dx_mm, dy_mm, xstep_mm, ystep_mm, radius_mm, n_cycles):
    if n_cycles < 1:
      return False
    end
  
    # Unit conversion
    dx_m = dx_mm / 1000.0
    radius_m = radius_mm / 1000.0
    drx_rad = dy_mm / radius_mm
    xstep_m = xstep_mm / 1000.0
    rstep_rad = ystep_mm / radius_mm
    x_grid_count = floor(dx_mm / xstep_mm)
    r_grid_count = floor(dy_mm / ystep_mm)
  
    # Find initial position
    set_tcp(p[0, 0, tool_length_m + radius_m, 0, 0, 0])
    p0 = get_actual_tcp_pose()
  
    # Move to offset position bottom left of scan area
    p1 = pose_trans(get_forward_kin(), p[-dx_m / 2, 0, 0, -drx_rad / 2, 0, 0])
    movel(p1, robot_accel, robot_speed)
  
    if not set_grinding_state(True):
      movel(p0, robot_accel, robot_speed)
      return False
    end
  
    # Grind serpentine pattern
    global grind_cycle = 1
    x_grid = 0
    r_grid = 0
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      # Advance x by xstep_m
      if ok_to_proceed():
        p1 = pose_trans(get_forward_kin(), p[xstep_m, 0, 0, 0, 0, 0])
        movel(p1, robot_accel, robot_speed)
        # Track new grid square we're in
        if xstep_m > 0:
          x_grid = x_grid + 1
        else:
          x_grid = x_grid - 1
        end
      end
      # Adjust x direction
      if x_grid >= x_grid_count-1 and xstep_m > 0:
        xstep_m = -xstep_m
      elif x_grid == 0 and xstep_m < 0:
        xstep_m = -xstep_m
      end
  
      # Advance r by rstep_rad
      if ok_to_proceed():
        p1 = pose_trans(get_forward_kin(), p[0, 0, 0, rstep_rad, 0, 0])
        movel(p1, robot_accel, robot_speed)
        # Track new grid square we're in
        if rstep_rad > 0:
          r_grid = r_grid + 1
        else:
          r_grid = r_grid - 1
        end
      end
      # Adjust r direction
      if r_grid >= r_grid_count-1 and rstep_rad > 0:
        rstep_rad = -rstep_rad
      elif r_grid == 0 and rstep_rad < 0:
        rstep_rad = -rstep_rad
      end
  
      # Detect when we've covered all the grid squares!
      # That's when you reach n-1,n-1 or 0,0
      if x_grid == x_grid_count - 1 and r_grid == r_grid_count - 1:
        grind_cycle = grind_cycle + 1
      elif r_grid == 0 and r_grid == 0:
        grind_cycle = grind_cycle + 1
      end
    end
  
    set_grinding_state(False)
  
    # Return robot back to initial position
    movel(p0, robot_accel, robot_speed)
    return True
  end
  
  # Grind along a flat circle diam dx_mm centered on current tool position. Repeat n_cycles times.
  def grind_flat_circle(dx_mm, n_cycles):
    if n_cycles < 1:
      return True
    end
  
    # Unit conversion
    dx_m = dx_mm / 1000.0
    n_points = ceil(dx_mm * 1.0) # 10 points in a 10mm diam circle... linear n_points up and down from there
    radius_m = dx_m / 2          # Circle radius is half of specified dx
  
    # Find initial position p0
    set_tcp(p[0, 0, tool_length_m, 0, 0, 0])  #
    p0 = get_actual_tcp_pose()
  
    # Move to offset position east edge of circle
    p1 = pose_trans(get_forward_kin(), p[radius_m, 0, 0, 0, 0, 0])
    movel(p1, robot_accel, robot_speed)
  
    if not set_grinding_state(True):
      movel(p0, robot_accel, robot_speed)
      return False
    end
  
    # Grind circle pattern
    # We're in contact at east side... compute where contact position would be at center of circle
    p_center = pose_trans(get_forward_kin(), p[-radius_m, 0, 0, 0, 0, 0])
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      i = 1
      while ok_to_proceed() and i <= n_points:
        theta = d2r(360.0 * i / n_points)
        x = radius_m * cos(theta)
        y = radius_m * sin(theta)
  
        p1 = pose_trans(p_center, p[x, y, 0, 0, 0, 0])
        movel(p1, robot_accel, robot_speed, 0.005)
        i = i + 1
      end
  
      grind_cycle = grind_cycle + 1
    end
  
    set_grinding_state(False)
  
    # Return robot back to initial position
    movel(p0, robot_accel, robot_speed)
    return True
  end
  
  # Grind along a flat spiral diam dx_mm to dx2_mm in n_spirals rotations centered on current tool position. Repeat n_cycles times.
  def grind_flat_spiral(dx_mm, dx2_mm, n_spirals, n_cycles):
    if n_cycles < 1:
      return True
    end
  
    # Unit conversion
    dx_m = dx_mm / 1000.0
    dx2_m = dx2_mm / 1000.0
    n_points = ceil(dx_mm * 1.0) # 10 points in a 10mm diam circle... linear n_points up and down from there
    radius_m = dx_m / 2          # Circle radius is half of specified dx
    radius2_m = dx2_m / 2
  
    # Find initial position p0
    set_tcp(p[0, 0, tool_length_m, 0, 0, 0])  #
    p0 = get_actual_tcp_pose()
  
    # Move to offset position east edge of circle
    p1 = pose_trans(get_forward_kin(), p[radius_m, 0, 0, 0, 0, 0])
    movel(p1, robot_accel, robot_speed)
  
    if not set_grinding_state(True):
      movel(p0, robot_accel, robot_speed)
      return False
    end
  
    # Grind spiral pattern
    # We're in contact at east side... compute where contact position would be at center of circle
    p_center = pose_trans(get_forward_kin(), p[-radius_m, 0, 0, 0, 0, 0])
    n_total_points = n_spirals * n_points
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      i = 0
      while ok_to_proceed() and i <= n_total_points:
        theta = d2r(360.0 * (i % n_points) / n_points)
        r_instantaneous = i * (radius2_m - radius_m) / n_total_points + radius_m
        x = r_instantaneous * cos(theta)
        y = r_instantaneous * sin(theta)
  
        p1 = pose_trans(p_center, p[x, y, 0, 0, 0, 0])
        movel(p1, robot_accel, robot_speed, 0.005)
        i = i + 1
      end
  
      grind_cycle = grind_cycle + 1
      # Next cycle- swap diameters so we go in/out/in etc.
      old_radius_m = radius_m
      radius_m = radius2_m
      radius2_m = old_radius_m
    end
  
    set_grinding_state(False)
  
    # Return robot back to initial position
    movel(p0, robot_accel, robot_speed)
    return True
  end
  
  $ 5 "currentTcpPose≔get_actual_tcp_pose()"
  global currentTcpPose= get_actual_tcp_pose ()
  $ 6 "MoveJ"
  $ 7 "currentTcpPose" "breakAfter"
  movej(currentTcpPose, a=1.3962634015954636, v=1.0471975511965976)
  $ 8 "socket_close()"
  socket_close()
  $ 9 "Wait: 0.25"
  sleep(0.25)
  $ 10 "socket_is_open≔ False "
  global socket_is_open=  False  
  $ 11 "command_index≔0"
  global command_index=0
  while (True):
    $ 12 "Robot Program"
    $ 13 "Loop socket_is_open ≟  False "
    while (socket_is_open  ==    False  ):
      $ 14 "socket_is_open≔socket_open('192.168.0.252', 30000)"
      global socket_is_open=socket_open("192.168.0.252", 30000)
      $ 15 "Wait: 1.0"
      sleep(1.0)
    end
    $ 16 "response≔'Unknown command'"
    global response="Unknown command"
    $ 17 "command≔socket_read_ascii_float(10)"
    global command=socket_read_ascii_float(10)
    $ 18 "If command[0]≥1"
    if (command[0] >= 1):
      $ 19 "socket_send_line('robot_busy=True')"
      socket_send_line("robot_busy=True")
      $ 20 "command_index≔command_index+1"
      global command_index=command_index+1
      $ 21 "socket_set_var('robot_index', command_index)"
      socket_set_var("robot_index", command_index)
      $ 22 "lastCommand≔command"
      global lastCommand=command
      $ 23 "Switch command[1]"
      switch_1 = command[1]
      $ 24 "Case 10"
      if (10 == switch_1):
        $ 25 "return_actual_tcp_pose()"
        return_actual_tcp_pose()
      elif (12 == switch_1):
        $ 26 "Case 12"
        $ 27 "return_tcp_offset()"
        return_tcp_offset()
      elif (13 == switch_1):
        $ 28 "Case 13"
        $ 29 "movel_relative(p[command[2], command[3], command[4], command[5], command[6], command[7]])"
        movel_relative(p[command[2], command[3], command[4], command[5], command[6], command[7]])
      elif (15 == switch_1):
        $ 30 "Case 15"
        $ 31 "movel_one_only(command[2],command[3])"
        movel_one_only(command[2],command[3])
      elif (18 == switch_1):
        $ 32 "Case 18"
        $ 33 "movel_rot_only(command[2],command[3],command[4])"
        movel_rot_only(command[2],command[3],command[4])
      elif (20 == switch_1):
        $ 34 "Case 20"
        $ 35 "return_get_actual_joint_positions()"
        return_get_actual_joint_positions()
      elif (21 == switch_1):
        $ 36 "Case 21"
        $ 37 "movej_q([command[2], command[3], command[4], command[5], command[6], command[7]])"
        movej_q([command[2], command[3], command[4], command[5], command[6], command[7]])
      elif (30 == switch_1):
        $ 38 "Case 30"
        $ 39 "set_speed(command[2])"
        set_speed(command[2])
      elif (31 == switch_1):
        $ 40 "Case 31"
        $ 41 "set_accel(command[2])"
        set_accel(command[2])
      elif (40 == switch_1):
        $ 42 "Case 40"
        $ 43 "pattern_grind()"
        pattern_grind()
      elif (50 == switch_1):
        $ 44 "Case 50"
        $ 45 "Call AG_50"
        AG_50()
      elif (98 == switch_1):
        $ 46 "Case 98"
        $ 47 "response≔'socket reset'"
        global response="socket reset"
      elif (99 == switch_1):
        $ 48 "Case 99"
        $ 49 "response≔'exiting'"
        global response="exiting"
      else:
        $ 50 "Default Case"
        $ 51 "response≔'unknown command'"
        global response="unknown command"
      end
      $ 52 "socket_send_line('robot_response=' + response + '#robot_busy=False')"
      socket_send_line("robot_response=" + response + "#robot_busy=False")
      $ 53 "If command[1]≟98"
      if (command[1] == 98):
        $ 54 "Wait: 0.5"
        sleep(0.5)
        $ 55 "socket_close()"
        socket_close()
        $ 56 "socket_is_open≔ False "
        global socket_is_open=  False  
      end
      $ 57 "If command[1]≟99"
      if (command[1] == 99):
        $ 58 "Wait: 0.5"
        sleep(0.5)
        $ 59 "socket_close()"
        socket_close()
        $ 60 "socket_is_open≔ False "
        global socket_is_open=  False  
        $ 61 "Halt"
        halt
      end
    else:
      $ 62 "Else" "noBreak"
    end
  end
end
