def AutoGrind01():
  set_standard_analog_input_domain(0, 1)
  set_standard_analog_input_domain(1, 1)
  set_tool_analog_input_domain(0, 1)
  set_tool_analog_input_domain(1, 1)
  set_analog_outputdomain(0, 0)
  set_analog_outputdomain(1, 0)
  set_input_actions_to_default()
  set_safety_mode_transition_hardness(1)
  step_count_6a348ad0_cd75_464b_8624_637662ad2bab = 0.0
  thread Step_Counter_Thread_5dde3dde_56a3_4bc9_aa29_95b79d347b9a():
    while (True):
      step_count_6a348ad0_cd75_464b_8624_637662ad2bab = step_count_6a348ad0_cd75_464b_8624_637662ad2bab + 1.0
      sync()
    end
  end
  run Step_Counter_Thread_5dde3dde_56a3_4bc9_aa29_95b79d347b9a()
  set_tcp(p[0.0,0.0,0.174,3.141592653589793,0.0,0.0])
  set_payload(2.0)
  set_gravity([0.0, 0.0, 9.82])
  set_tool_communication(False, 115200, 0, 1, 1.5, 3.5)
  set_tool_output_mode(0)
  set_tool_digital_output_mode(0, 1)
  set_tool_digital_output_mode(1, 1)
  set_tool_voltage(0)
  global up_pose_p=p[-.139608417870, -.431276583025, .128881236186, -.001221359682, 3.116276528482, .038891915637]
  global up_pose_q=[-1.6006999999532772, -1.5602662340053621, -2.0656244038598475, -1.1122093621336546, 1.5951000000012003, -0.030999999953279733]
  global down_pose_p=p[-.139608417867, -.431276582947, .015638902876, -.001221359682, 3.116276528482, .038891915637]
  global down_pose_q=[-1.6007000000057907, -1.7535815119226044, -2.215643614002417, -0.7688748740751139, 1.5950999999998547, -0.03100000000578973]
  global Vertical_3_p=p[-.139608417872, -.431276583102, .028138902829, -.001221359682, 3.116276528482, .038891915637]
  global Vertical_3_q=[-1.6006999999999998, -1.7271, -2.2029999999999994, -0.8079999999999998, 1.5951, -0.030999999999999694]
  global Tilted_1_p=p[-.139608417868, -.431276582996, .028138902982, -.011381173019, 3.019426224372, -.776094768972]
  global Tilted_1_q=[-1.6143181432207498, -1.730963551856462, -2.588173794846753, 0.1085536174237972, 1.6168206000396343, -0.039262279865630134]
  global Vertical_4_p=p[-.139608417866, -.431276582919, .131081236338, -.001221329928, 3.116276528722, .038891910429]
  global Vertical_4_q=[-1.600700000064136, -1.5575468977702354, -2.0619765024476475, -1.1185765962043455, 1.595100000182046, -0.030999980927620463]
  def AG_50():
    $ 78 "AG_50" "noBreak"
    $ 79 "MoveL"
    $ 80 "Vertical_3" "breakAfter"
    movel(Vertical_3_p, a=1.2, v=0.25)
    $ 81 "Tilted_1" "breakAfter"
    movel(Tilted_1_p, a=1.2, v=0.25)
    $ 82 "Vertical_4" "breakAfter"
    movel(Vertical_4_p, a=1.2, v=0.25)
    $ 83 "Vertical_3" "breakAfter"
    movel(Vertical_3_p, a=1.2, v=0.25)
  end
  $ 1 "BeforeStart"
  $ 2 "Script: agscript_util.script"
  # AutoGrind General UR Utilities
  # File: agscript_util.script
  # Version 1.0
  # Programmer: Ned Lecky
  
  # Send CRLF out the socket
  def socket_send_crlf():
    socket_send_byte(13)
    socket_send_byte(10)
  end
  
  # Send LF out the socket
  def socket_send_lf():
    socket_send_byte(10)
  end
  
  # Conversion (RPY(deg) to AxisAngle)
  def RPY_to_AxisAngle(R):
    Rx = d2r(R[3]) / 2.0
    Ry = d2r(R[4]) / 2.0
    Rz = d2r(R[5]) / 2.0
  
    Cx = cos(Rx)
    Sx = sin(Rx)
    Cy = cos(Ry)
    Sy = sin(Ry)
    Cz = cos(Rz)
    Sz = sin(Rz)
  
    Angle = 2.0 * acos(Cx * Cy * Cz + Sx * Sy * Sz)
    x = Sx * Cy * Cz - Cx * Sy * Sz
    y = Cx * Sy * Cz + Sx * Cy * Sz
    z = -Sx * Sy * Cz + Cx * Cy * Sz
    Norm = sqrt(x * x + y * y + z * z)
    if norm(Norm) < 1e-4:
      Ax = 0
      Ay = 0
      Az = 0
    else:
      Ratio = Angle / Norm
      Ax = x * Ratio
      Ay = y * Ratio
      Az = z * Ratio
    end
    Ans = p[R[0], R[1], R[2], Ax, Ay, Az]
  
    return Ans
  end
  
  # Conversion (AxisAngle to RPY)
  def AxisAngle_to_RPY(R):
    Rx = R[3]
    Ry = R[4]
    Rz = R[5]
  
    Angle = sqrt(Rx * Rx + Ry * Ry + Rz * Rz)
    if Angle < 1e-4:
      x = 0
      y = 0
      z = 1
    else:
      x = Rx / Angle
      y = Ry / Angle
      z = Rz / Angle
    end
    S = sin(Angle)
    C = cos(Angle)
    T = 1 - C
  
    r11 = T * x * x + C
    r12 = T * x * y - S * z
    r13 = T * x * z + S * y
    r21 = T * x * y + S * z
    r22 = T * y * y + C
    r23 = T * y * z - S * x
    r31 = T * x * z - S * y
    r32 = T * y * z + S * x
    r33 = T * z * z + C
  
    if r31 > 1:
      r31 = 1
    elif r31 < -1:
      r31 = -1
    end
  
    Ay = asin(-r31)
    if Ay > d2r(89.9):
      sinAxMinusAz = (r12 - r23) / (1 - r31)
      cosAxMinusAz = (r13 + r22) / (1 - r31)
      Ax = atan2(sinAxMinusAz, cosAxMinusAz)
      Az = 0
    elif Ay < d2r(-89.9):
      sinAxPlusAz = (-r12 - r23) / (1 + r31)
      cosAxPlusAz = (-r13 + r22) / (1 + r31)
      Ax = atan2(sinAxPlusAz, cosAxPlusAz)
      Az = 0
    else:
      Ax = atan2(r32, r33)
      Az = atan2(r21, r11)
    end
  
    Ans = p[R[0], R[1], R[2], r2d(Ax), r2d(Ay), r2d(Az)]
  
    return Ans
  end
  
  # Get position in RPY coordinate
  def get_actual_tcp_pose_RPY():
    p = get_actual_tcp_pose()
    p2 = AxisAngle_to_RPY(p)
    return p2
  end
  
  # movel in RPY coordinates
  def movel_RPY(p, accel, speed):
    p1 = RPY_to_AxisAngle(p)
    movel(p1, accel, speed)
  end
  
  # movej in RPY coordinates
  def movej_RPY(p, accel, speed):
    p1 = RPY_to_AxisAngle(p)
    movej(p1, accel, speed)
  end
  
  # Add position
  def pose_add_RPY(V1, V2):
    A0 = V1[0] + V2[0]
    A1 = V1[1] + V2[1]
    A2 = V1[2] + V2[2]
    A3 = V1[3] + V2[3]
    A4 = V1[4] + V2[4]
    A5 = V1[5] + V2[5]
    A = p[A0, A1, A2, A3, A4, A5]
  
    return A
  end
  
  # Send 6-vectors back to socket as [n,n,n,n,n,n]
  def return_vector(p):
    socket_send_string("[")
    i = 0
    while i < 6:
      if i > 0:
        socket_send_string(",")
      end
      socket_send_string(p[i])
      i = i + 1
    end
    socket_send_string("]")
  end
  
  # Send 6-element position back to socket as:
  #   (isPose=False) name=[n,n,n,n,n,n]
  #   (isPose=True)name=p[n,n,n,n,n,n]
  def return_position(name, isPose, p):
    socket_send_string(name)
    socket_send_string("=")
    if isPose == True:
      socket_send_string("p")
    end
    return_vector(p)
    socket_send_lf()
  end
  
  # Return a 6-element vector as a pose name=p[.....]
  def return_pose(name, p):
    return_position(name, True, p)
  end
  
  # Return a 6-element vector as joint angles name=[.....]
  def return_joints(name, p):
    return_position(name, False, p)
  end
  $ 3 "Script: agscript_robot.script"
  # AutoGrind Robot Functions
  # File: agscript_robot.script
  # Version 1.0
  # Programmer: Ned Lecky
  
  global scriptRunning = True
  global response = "unknown"
  
  global speed = 0.3
  global accel = 0.3
  
  # Set speed to s if s<>0. Always returns "speed=[current speed]"
  def set_speed(s):
    if s>0:
      speed = s
    end
    socket_send_string("speed=")
    socket_send_string(speed)
    socket_send_lf()
    global response = "set_speed()"
  end
  
  # Set accel to a if a<>0. Always returns "accel=[current accel]"
  def set_accel(a):
    if a>0:
      accel = a
    end
    socket_send_string("accel=")
    socket_send_string(accel)
    socket_send_lf()
    global response = "set_accel()"
  end
  
  # Send get_tcp_offset() result to socket
  def return_tcp_offset():
    p = get_tcp_offset()
    return_pose("tcp_offset", p)
    global response = "return_tcp_offset()"
  end
  
  # Send get_actual_tcp_pose() to socket
  def return_actual_tcp_pose():
    p = get_actual_tcp_pose()
    return_pose("actual_tcp_pose", p)
    global response = "return_actual_tcp_pose()"
  end
  
  # Send return_actual_tcp_pose_RPY() to socket
  def return_actual_tcp_pose_RPY():
    p = get_actual_tcp_pose_RPY()
    return_pose("actual_tcp_pose_RPY", p)
    global response = "return_actual_tcp_pose_RPY()"
  end
  
  # Send get_actual_joint_positions() to
  def return_get_actual_joint_positions():
    p = get_actual_joint_positions()
    return_joints("actual_joint_positions", p)
    global response = "return_get_actual_joint_positions()"
  end
  
  # Movel relatively in RPY
  def movel_RPY_rel():
    p0 = get_actual_tcp_pose_RPY()
    p1 = p[command[2], command[3], command[4], command[5], command[6], command[7]]
    p2 = pose_add_RPY(p0, p1)
    movel_RPY(p2, accel, speed)
    global response = "movel_RPY_rel()"
  end
  
  # Movej relatively in RPY
  def movej_RPY_rel():
    p0 = get_actual_tcp_pose_RPY()
    p1 = p[command[2], command[3], command[4], command[5], command[6], command[7]]
    p2 = pose_add_RPY(p0, p1)
    movej_RPY(p2, accel, speed)
    global response = "movej_RPY_rel()"
  end
  
  # Movej to 0,0,0, RPY
  def movej_RPY_zero():
    p0 = get_actual_tcp_pose_RPY()
    p0[3] = 0
    p0[4] = 0
    p0[5] = 0
    movej_RPY(p0, accel, speed)
    global response = "movej_RPY_zero()"
  end
  
  # Movej to physical joint positions
  def movej_q():
    q1 = [command[2], command[3], command[4], command[5], command[6], command[7]]
    movej(q1, accel, speed)
    global response = "movej_q()"
  end
  $ 4 "Script: agscript_grind.script"
  # AutoGrind Grinding Functions
  # File: agscript_grind.script
  # Version 1.0
  # Programmer: Ned Lecky
  
  # Execute the desired pattern grind selected by command[2]
  def pattern_grind():
    if command[2] == 1:
      global response = "Grind box_x_first"
      box_x_first(command[3], command[4])
    elif command[2] == 2:
      global response = "Grind Command 2"
    elif command[2] == 3:
      global response = "Grind serpentine_x"
      serpentine_x_first(command[3], command[4], command[5], command[6])
    else:
      global response = "Unknown Grind Command"
    end
  end
  
  # Grind along a box dx x dy area centered on current XY
  # Move in X direction first, then y
  def box_x_first(dx, dy):
    p0 = get_actual_tcp_pose_RPY()
    x_init = p0[0]
    y_init = p0[1]
    z_init = p0[2]
    x0 = x_init - dx / 2
    y0 = y_init - dy / 2
    x1 = x0 + dx
    y1 = y0 + dy
  
    # Move to offset position bottom left of scan area
    p1 = p0
    p1[0] = x0
    p1[1] = y0
    movel_RPY(p1, accel, speed)
  
    # Advance until contact
    # AND set p1[2] to the z of the part
    p1[2] = p1[2] - 0.010
    movel_RPY(p1, accel, speed)
  
    # Turn on tool
  
    # Turn on force
  
    # Grind box pattern
    p1[0] = x1
    movel_RPY(p1, accel, speed)
    p1[1] = y1
    movel_RPY(p1, accel, speed)
    p1[0] = x0
    movel_RPY(p1, accel, speed)
    p1[1] = y0
    movel_RPY(p1, accel, speed)
  
    # Turn off force
  
    # Lift tool in z
    p1[2] = p1[2] + 0.010
    movel_RPY(p1, accel, speed)
  
    # Turn off tool
  
    # Return robot to initial position
    p1[0] = x_init
    p1[1] = y_init
    p1[2] = z_init
    movel_RPY(p1, accel, speed)
  end
  
  # Run serpentine xy pattern over dx x dy area centered on current XY moving in x_incr y_incr per pass
  # Move in X direction first, then y
  def serpentine_x_first(dx, dy, x_incr, y_incr):
    p0 = get_actual_tcp_pose_RPY()
  
    # Move to offset position bottom left of scan area
    p1 = p0
    p1[0] = p0[0] - dx / 2
    p1[1] = p0[1] - dy / 2
    movel_RPY(p1, accel, speed)
  
    fDone = False
    while fDone != True:
      # Move in X direction
      fDone = True
    end
  end
  
  
  $ 5 "currentTcpPose≔get_actual_tcp_pose()"
  global currentTcpPose= get_actual_tcp_pose ()
  $ 6 "MoveJ"
  $ 7 "currentTcpPose" "breakAfter"
  movej(currentTcpPose, a=1.3962634015954636, v=1.0471975511965976)
  $ 8 "socket_close()"
  socket_close()
  $ 9 "Wait: 0.25"
  sleep(0.25)
  $ 10 "socket_is_open≔ False "
  global socket_is_open=  False  
  $ 11 "command_index≔0"
  global command_index=0
  while (True):
    $ 12 "Robot Program"
    $ 13 "Loop socket_is_open ≟  False "
    while (socket_is_open  ==    False  ):
      $ 14 "socket_is_open≔socket_open('192.168.25.1', 30000)"
      global socket_is_open=socket_open("192.168.25.1", 30000)
      $ 15 "Wait: 0.5"
      sleep(0.5)
    end
    $ 16 "response≔'Unknown command'"
    global response="Unknown command"
    $ 17 "command≔socket_read_ascii_float(7)"
    global command=socket_read_ascii_float(7)
    $ 18 "If command[0]≥1"
    if (command[0] >= 1):
      $ 19 "socket_send_line('robot_running=True')"
      socket_send_line("robot_running=True")
      $ 20 "command_index≔command_index+1"
      global command_index=command_index+1
      $ 21 "socket_set_var('robot_index', command_index)"
      socket_set_var("robot_index", command_index)
      $ 22 "lastCommand≔command"
      global lastCommand=command
      $ 23 "Switch command[1]"
      switch_1 = command[1]
      $ 24 "Case 1"
      if (1 == switch_1):
        $ 25 "MoveL"
        $ 26 "up_pose" "breakAfter"
        movel(up_pose_p, a=1.2, v=0.25)
        $ 27 "response≔'moved up'"
        global response="moved up"
      elif (2 == switch_1):
        $ 28 "Case 2"
        $ 29 "MoveJ"
        $ 30 "down_pose" "breakAfter"
        movej(get_inverse_kin(down_pose_p, qnear=down_pose_q), a=1.3962634015954636, v=1.0471975511965976)
        $ 31 "response≔'moved down'"
        global response="moved down"
      elif (3 == switch_1):
        $ 32 "Case 3"
        $ 33 "response≔'close'"
        global response="close"
      elif (4 == switch_1):
        $ 34 "Case 4"
        $ 35 "response≔'open'"
        global response="open"
      elif (10 == switch_1):
        $ 36 "Case 10"
        $ 37 "return_actual_tcp_pose()"
        return_actual_tcp_pose()
      elif (11 == switch_1):
        $ 38 "Case 11"
        $ 39 "return_actual_tcp_pose_RPY()"
        return_actual_tcp_pose_RPY()
      elif (12 == switch_1):
        $ 40 "Case 12"
        $ 41 "return_tcp_offset()"
        return_tcp_offset()
      elif (13 == switch_1):
        $ 42 "Case 13"
        $ 43 "movel_RPY_rel()"
        movel_RPY_rel()
      elif (14 == switch_1):
        $ 44 "Case 14"
        $ 45 "movej_RPY_rel()"
        movej_RPY_rel()
      elif (15 == switch_1):
        $ 46 "Case 15"
        $ 47 "movej_RPY_zero()"
        movej_RPY_zero()
      elif (20 == switch_1):
        $ 48 "Case 20"
        $ 49 "return_get_actual_joint_positions()"
        return_get_actual_joint_positions()
      elif (21 == switch_1):
        $ 50 "Case 21"
        $ 51 "movej_q()"
        movej_q()
      elif (30 == switch_1):
        $ 52 "Case 30"
        $ 53 "set_speed(command[2])"
        set_speed(command[2])
      elif (31 == switch_1):
        $ 54 "Case 31"
        $ 55 "set_accel(command[2])"
        set_accel(command[2])
      elif (40 == switch_1):
        $ 56 "Case 40"
        $ 57 "pattern_grind()"
        pattern_grind()
      elif (50 == switch_1):
        $ 58 "Case 50"
        $ 59 "Call AG_50"
        AG_50()
      elif (98 == switch_1):
        $ 60 "Case 98"
        $ 61 "response≔'socket reset'"
        global response="socket reset"
      elif (99 == switch_1):
        $ 62 "Case 99"
        $ 63 "response≔'exiting'"
        global response="exiting"
      else:
        $ 64 "Default Case"
        $ 65 "response≔'unknown command'"
        global response="unknown command"
      end
      $ 66 "socket_send_line('robot_response=' + response + '#robot_running=False')"
      socket_send_line("robot_response=" + response + "#robot_running=False")
      $ 67 "If command[1]≟98"
      if (command[1] == 98):
        $ 68 "Wait: 0.5"
        sleep(0.5)
        $ 69 "socket_close()"
        socket_close()
        $ 70 "socket_is_open≔ False "
        global socket_is_open=  False  
      end
      $ 71 "If command[1]≟99"
      if (command[1] == 99):
        $ 72 "Wait: 0.5"
        sleep(0.5)
        $ 73 "socket_close()"
        socket_close()
        $ 74 "socket_is_open≔ False "
        global socket_is_open=  False  
        $ 75 "Halt"
        halt
      end
    else:
      $ 76 "Else" "noBreak"
    end
  end
end
