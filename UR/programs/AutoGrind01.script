def AutoGrind01():
  set_tool_communication(False, 115200, 0, 1, 1.5, 3.5)
  set_tool_output_mode(0)
  set_tool_digital_output_mode(0, 1)
  set_tool_digital_output_mode(1, 1)
  set_tool_voltage(0)
  set_gravity([0.0, 0.0, 9.82])
  step_count_ec46fc3e_2d79_4fa5_8401_3636c2000426 = 0.0
  thread Step_Counter_Thread_5f3d37c3_e0c2_4317_8830_eccb5878de17():
    while (True):
      step_count_ec46fc3e_2d79_4fa5_8401_3636c2000426 = step_count_ec46fc3e_2d79_4fa5_8401_3636c2000426 + 1.0
      sync()
    end
  end
  run Step_Counter_Thread_5f3d37c3_e0c2_4317_8830_eccb5878de17()
  set_safety_mode_transition_hardness(1)
  set_standard_analog_input_domain(0, 1)
  set_standard_analog_input_domain(1, 1)
  set_tool_analog_input_domain(0, 1)
  set_tool_analog_input_domain(1, 1)
  set_analog_outputdomain(0, 0)
  set_analog_outputdomain(1, 0)
  set_input_actions_to_default()
  set_tcp(p[0.0,0.0,0.175,0.0,0.0,0.0])
  set_payload(1.0, [0.0, 0.0, 0.05])
  global Vertical_1_p=p[.138885408770, -.597734994115, .345465728645, .020328607375, .009472346729, .004936256276]
  global Vertical_1_q=[1.5825845003128052, -1.3035788101008912, 1.3692634741412562, -1.6159240208067835, -1.5805562178241175, 3.148454189300537]
  global Tilted_2_p=p[.138883686744, -.597728142783, .345429622193, -.448043800451, .010443563975, .002601926233]
  global Tilted_2_q=[1.5845965147018433, -1.4651393455317994, 1.7312191168414515, -2.2846466503539027, -1.5859773794757288, 3.1494011878967285]
  global Vertical_2_p=p[.138907887118, -.597724961045, .477595501516, .000033070909, -.000020568314, .002680866690]
  global Vertical_2_q=[1.5797940492630005, -1.280219630604126, 1.0041268507586878, -1.2945302587798615, -1.5720770994769495, 3.1477832794189453]
  global Vertical_5_p=p[.138875969234, -.597730539026, .130475163479, .000006847317, .000017170136, .002581409666]
  global Vertical_5_q=[1.5792073011398315, -1.1477825206569214, 1.743450943623678, -2.1663156948485316, -1.570512596760885, 3.1478190422058105]
  def AG_50():
    $ 71 "AG_50" "noBreak"
    $ 72 "MoveL"
    $ 73 "Vertical_1" "breakAfter"
    movel(Vertical_1_p, a=1.2, v=0.25)
    $ 74 "Tilted_2" "breakAfter"
    movel(Tilted_2_p, a=1.2, v=0.25)
    $ 75 "Vertical_2" "breakAfter"
    movel(Vertical_2_p, a=1.2, v=0.25)
    $ 76 "Vertical_5" "breakAfter"
    movel(Vertical_5_p, a=1.2, v=0.25)
  end
  $ 1 "BeforeStart"
  $ 2 "Script: agscript_util.script"
  # AutoGrind General UR Utilities
  # File: agscript_util.script
  # Version 1.0
  # Programmer: Ned Lecky
  
  # Limit a param to values lowLim <= param <= hiLim
  def limiter(param, loLim, hiLim):
    if param < loLim:
      return loLim
    elif param > hiLim:
      return hiLim
    else:
      return param
    end
  end
  
  # Send CRLF out the socket
  def socket_send_crlf():
    socket_send_byte(13)
    socket_send_byte(10)
  end
  
  # Send LF out the socket
  def socket_send_lf():
    socket_send_byte(10)
  end
  
  # Send n-vectors back to socket as [n,n,n,n,n,n]
  def return_vector(p, n = 6):
    socket_send_string("[")
    i = 0
    while i < n:
      if i > 0:
        socket_send_string(",")
      end
      socket_send_string(p[i])
      i = i + 1
    end
    socket_send_string("]")
  end
  
  # Send 6-element position back to socket as:
  #   (isPose=False) name=[n,n,n,n,n,n]
  #   (isPose=True)name=p[n,n,n,n,n,n]
  def return_position(name, isPose, p):
    socket_send_string(name)
    socket_send_string("=")
    if isPose == True:
      socket_send_string("p")
    end
    return_vector(p, 6)
    socket_send_lf()
  end
  
  # Return a 6-element vector as a pose name=p[.....]
  def return_pose(name, p):
    return_position(name, True, p)
  end
  
  # Return a 6-element vector as joint angles name=[.....]
  def return_joints(name, p):
    return_position(name, False, p)
  end
  $ 3 "Script: agscript_robot.script"
  # AutoGrind Robot Functions
  # File: agscript_robot.script
  # Version 1.0
  # Programmer: Ned Lecky
  
  global response = "unknown"
  
  global robot_speed = 0.2
  global robot_accel = 0.4
  global robot_blend = 0.003
  global robot_tcp = p[0, 0, 0.175, 0, 0, 0]
  global robot_tcp_part = robot_tcp
  global robot_payload_mass = 1.0
  global robot_payload_cog = [0, 0, 0.50]
  # Geometry [1=FLAT 2=CYL 3=SPHERE, diameter_m)
  global robot_part_geometry = [0, 0]
  
  # Defaults get set on load... and can be queried (or changed) from C#
  set_tcp(robot_tcp)
  set_payload(robot_payload_mass, robot_payload_cog)
  set_gravity([0.0, 0.0, 9.82])
  
  # Set interface... allows validation and limits
  def set_variable():
    if command[2] == 1:
      # Set speed to s if s>0. Always returns "speed=[current speed]"
      s = command[3]
      if s > 0:
        robot_speed = s
      end
      socket_send_string("robot_speed=")
      socket_send_string(robot_speed)
      socket_send_lf()
      global response = "set_speed()"
    elif command[2] == 2:
      # Set accel to a if a>0. Always returns "accel=[current accel]"
      a = command[3]
      if a > 0:
        robot_accel = a
      end
      socket_send_string("robot_accel=")
      socket_send_string(robot_accel)
      socket_send_lf()
      global response = "set_accel()"
    elif command[2] == 3:
      # Set blend to b if b>=0. Always returns "blend=[current blend]"
      b = command[3]
      if b >= 0:
        robot_blend = b
      end
      socket_send_string("robot_blend=")
      socket_send_string(robot_blend)
      socket_send_lf()
      global response = "set_blend()"
    elif command[2] == 4:
      # Set part_geometry to [shape, diameter_m] is shape>0. Always returns "robot_part_geometry=[current geometry]"
      shape = command[3]
      if shape > 0:
        diameter_m = command[4] / 1000.0
        robot_part_geometry = [shape, diameter_m]
      end
  
      # set robot_tcp_part based on geometry
      if shape == 1:  # Flat
        robot_tcp_part = robot_tcp
      else:  # Cylinder or Sphere
        robot_tcp_part = pose_trans(robot_tcp, p[0, 0, robot_part_geometry[1] / 2.0, 0, 0, 0])
      end
  
      socket_send_string("robot_part_geometry=")
      return_vector(robot_part_geometry, 2)
      socket_send_lf()
      return_pose("robot_tcp_part", robot_tcp_part)
      global response = "set_part_geometry()"
    elif command[2] == 10:
      # set_tcp if command[3] > -10. Always returns robot_tcp=p[...]
      if command[3] > -10:
        robot_tcp = p[command[3], command[4], command[5], command[6], command[7], command[8]]
        robot_tcp_part = robot_tcp
        set_tcp(robot_tcp)
      end
      return_pose("robot_tcp", get_tcp_offset())
      return_pose("robot_tcp_part", robot_tcp_part)
      global response = "set_tcp()"
    elif command[2] == 11:
      # set_payload if command[3] > 0. Always return robot_m and robot_cog
      if command[3] > 0:
        robot_payload_mass = command[3]
        robot_payload_cog = [command[4], command[5], command[6]]
        set_payload(robot_payload_mass, robot_payload_cog)
      end
      socket_send_string("robot_payload_mass=")
      socket_send_string(robot_payload_mass)
      socket_send_lf()
      socket_send_string("robot_payload_cog=")
      return_vector(robot_payload_cog, 3)
      socket_send_lf()
      global response = "set_payload()"
    else:
      global response = "set_variable ERROR"
    end
  
  end
  
  # Send get_tcp_offset() result to socket
  def return_tcp_offset():
    p = get_tcp_offset()
    return_pose("tcp_offset", p)
    global response = "return_tcp_offset()"
  end
  
  # Send get_actual_tcp_pose() to socket
  def return_actual_tcp_pose():
    p = get_actual_tcp_pose()
    return_pose("actual_tcp_pose", p)
    global response = "return_actual_tcp_pose()"
  end
  
  # Send get_actual_joint_positions() to socket
  def return_get_actual_joint_positions():
    p = get_actual_joint_positions()
    return_joints("actual_joint_positions", p)
    global response = "return_get_actual_joint_positions()"
  end
  
  # Send both joints and pose to socket labeled position_p and position_q
  def return_both_positions():
    return_joints("position_q", get_actual_joint_positions())
    return_pose("position_p", get_actual_tcp_pose())
    global response = "return_both_positions()"
  end
  
  # Movel relatively in base coordinates
  def movel_relative_base(p1):
    p0 = get_actual_tcp_pose()
    p2 = pose_add(p0, p1)
    movel(p2, robot_accel, robot_speed)
    global response = "movel_relative_base()"
  end
  
  # Movel relatively in TCP coordinates
  def movel_relative_tcp(p1):
    p1 = pose_trans(get_forward_kin(), p1)
    movel(p1, a = robot_accel, v = robot_speed)
    global response = "movel_relative_tcp()"
  end
  
  # Movel relatively in TCP_part coordinates
  def movel_relative_tcp_part(p1):
    set_tcp(robot_tcp_part)
    p1 = pose_trans(get_forward_kin(), p1)
    #p1 = pose_trans(get_forward_kin(q=get_actual_joint_positions(), tcp = robot_tcp_part), p1)
    #p1 = pose_trans(get_forward_kin(q = get_actual_joint_positions(), tcp = robot_tcp_part), p1)
    movel(p1, a = robot_accel, v = robot_speed)
    set_tcp(robot_tcp)
    global response = "movel_relative_tcp_part()"
  end
  
  # Change one element of current pose and movel there
  def movel_one_only(index = 0, val = 0):
    p = get_actual_tcp_pose()
    p[index] = val
    movel(p, robot_accel, robot_speed)
    global response = "movel_one_only()"
  end
  
  # Change only rotation elements of current pose and movel there
  def movel_rot_only(r1 = 0, r2 = 0, r3 = 0):
    p = get_actual_tcp_pose()
    p[3] = r1
    p[4] = r2
    p[5] = r3
    movel(p, robot_accel, robot_speed)
    global response = "movel_rot_only()"
  end
  
  # Movej to position (works with joints or poses)
  def movej_ag(p):
    movej(p, a = robot_accel, v = robot_speed)
    global response = "movej_ag()"
  end
  
  # Movel to position (works with joints or poses)
  def movel_ag(p):
    movel(p, a = robot_accel, v = robot_speed)
    global response = "movel_ag()"
  end
  
  
  # Move to touchoff
  #
  def calculate_point_to_move_towards(feature, direction, position_distance):
    local posDir = [direction[0], direction[1], direction[2]]
    if (norm(posDir) < 1e-6):
      return get_target_waypoint()
    end
    local direction_vector_normalized = normalize(posDir)
    local displacement_pose = p[direction_vector_normalized[0] * position_distance, direction_vector_normalized[1] * position_distance, direction_vector_normalized[2] * position_distance, 0, 0, 0]
    local wanted_displacement_in_base_frame = pose_sub(pose_trans(feature, displacement_pose), feature)
    return pose_add(get_target_waypoint(), wanted_displacement_in_base_frame)
  end
  #$ 7 "Robot Program"
  #$ 8 "MoveL"
  #$ 9 "Direction: Tool Z+"
  global move_thread_flag = 0
  thread move_thread():
    enter_critical
    move_thread_flag = 1
    local towardsPos = calculate_point_to_move_towards(get_forward_kin(), [0.0, 0.0, 1.0], 0.025)
    movel(towardsPos, a = 0.5, v = 0.02)
    move_thread_flag = 2
    exit_critical
  end
  def touchoff():
    move_thread_flag = 0
    move_thread_han = run move_thread()
    while (True):
      local targetTcpDirection = get_target_tcp_speed()
      local stepsToRetract = tool_contact(direction = targetTcpDirection)
      if (stepsToRetract > 0):
        kill move_thread_han
        stopl(1.0)
        local backTrackMovement = get_actual_joint_positions_history(stepsToRetract)
        local contactPose = get_forward_kin(backTrackMovement)
        local posDir = [targetTcpDirection[0], targetTcpDirection[1], targetTcpDirection[2]]
        local retractTo = contactPose
        if (norm(posDir) > 1e-6):
          local normalizedPosDir = normalize(posDir)
          local additionalRetraction = p[normalizedPosDir[0] * 0.001, normalizedPosDir[1] * 0.001, normalizedPosDir[2] * 0.001, 0, 0, 0]
          retractTo = pose_sub(contactPose, additionalRetraction)
        end
        movel(retractTo, a = 1.0, v = 0.1)
        #$ 10 "Until (tool_contact_detection)"
        return True
        break
      end
      sleep(1.0E-10)
      if (move_thread_flag > 1):
        join move_thread_han
        #$ 11 "Until (distance)"
        #$ 12 "Popup: No part encountered"
        #popup("No part encountered", "Message", False, False, blocking = True)
        return False
        break
      end
      sync()
    end
    return False
  end
  $ 4 "Script: agscript_grind.script"
  # AutoGrind Grinding Functions
  # File: agscript_grind.script
  # Version 1.0
  # Programmer: Ned Lecky
  
  global listenerThread = 0
  global threadCount = 0
  global haltCount = 0
  global haltCommand = [0, 0]
  
  global grind_ready = True
  global grind_contact_enabled = False
  
  MATH_PI = 3.1415926535
  
  # Execute the desired pattern grind selected by command[2]...
  def pattern_grind():
    global grind_ready = False
    socket_send_line("grind_ready=False")
  
    if listenerThread > 0:
      kill listenerThread
      listenerThread = 0
    end
    listenerThread = run listener_thread()
  
    global grind_cycle = 0
    global grind_n_cycles = 0
    global grind_dx_mm = 0
    global grind_dy_mm = 0
    global grind_circle1_diam_mm = 0
    global grind_circle2_diam_mm = 0
    global grind_n_spirals = 0
    global grind_xstep_mm = 0
    global grind_ystep_mm = 0
  
    # Install tcp that puts tcp at center of part (noop for flat parts!)
    set_tcp(robot_tcp_part)
  
    if command[2] == 1:
      global response = "set grind_contact_enabled"
      if command[3] > 0:
        global grind_contact_enabled = True
        socket_send_line("grind_contact_enabled=True")
      else:
        global grind_contact_enabled = False
        socket_send_line("grind_contact_enabled=False")
      end
      # LINEAR GRINDS
    elif command[2] == 10:
      global response = "grind_line"
      global grind_dx_mm = command[3]
      global grind_dy_mm = command[4]
      global grind_n_cycles = command[5]
      global grind_speed = command[6] / 1000.0
      global grind_force = command[7]
      # These may get calculated later!
      global grind_accel = robot_accel
      global grind_blend = robot_blend
      grind_line(grind_dx_mm, grind_dy_mm, grind_n_cycles)
  
      # RECTANGULAR GRINDS
    elif command[2] == 20:
      global response = "grind_rect"
      global grind_dx_mm = command[3]
      global grind_dy_mm = command[4]
      global grind_n_cycles = command[5]
      global grind_speed = command[6] / 1000.0
      global grind_force = command[7]
      # These may get calculated later!
      global grind_accel = robot_accel
      global grind_blend = robot_blend
      grind_rect(grind_dx_mm, grind_dy_mm, grind_n_cycles)
  
      # SERPENTINE GRINDS
    elif command[2] == 30:
      global response = "grind_serpentine"
      global grind_dx_mm = command[3]
      global grind_dy_mm = command[4]
      global grind_n_xsteps = limiter(command[5], 1, 10)
      global grind_n_ysteps = limiter(command[6], 1, 10)
      global grind_n_cycles = command[7]
      global grind_speed = command[8] / 1000.0
      global grind_force = command[9]
      # These may get calculated later!
      global grind_accel = robot_accel
      global grind_blend = robot_blend
      grind_serpentine(grind_dx_mm, grind_dy_mm, grind_n_xsteps, grind_n_ysteps, grind_n_cycles)
  
      # CIRCULAR GRINDS
    elif command[2] == 40:
      global response = "grind_circle"
      global grind_circle1_diam_mm = command[3]
      global grind_n_cycles = command[4]
      global grind_speed = command[5] / 1000.0
      global grind_force = command[6]
      # These may get calculated later!
      global grind_accel = robot_accel
      global grind_blend = robot_blend
      grind_circle(grind_circle1_diam_mm, grind_n_cycles)
  
      # SPIRAL GRINDS
    elif command[2] == 50:
      global response = "grind_spiral"
      global grind_circle1_diam_mm = command[3]
      global grind_circle2_diam_mm = command[4]
      global grind_n_spirals = command[5]
      global grind_n_cycles = command[6]
      global grind_speed = command[7] / 1000.0
      global grind_force = command[8]
      # These may get calculated later!
      global grind_accel = robot_accel
      global grind_blend = robot_blend
      grind_spiral(grind_circle1_diam_mm, grind_circle2_diam_mm, grind_n_spirals, grind_n_cycles)
    else:
      global response = "Unknown grind command"
    end
  
    # Restore tool-only tcp
    set_tcp(robot_tcp)
  
    kill listenerThread
    listenerThread = 0
  
    global grind_ready = True
    socket_send_line("grind_ready=True")
  end
  
  # Get into contact with part (or away from)
  def contact_part(on = False, enabled = False):
    if on:
      if enabled:
        # Advance until contact
        return touchoff()
      else:
        # Simulated....
        p1 = pose_trans(get_forward_kin(), p[0, 0, 0.010, 0, 0, 0])
        movel(p1, robot_accel, robot_speed)
      end
    else:
      p1 = pose_trans(get_forward_kin(), p[0, 0, -0.010, 0, 0, 0])
      movel(p1, robot_accel, robot_speed)
    end
  
    return True
  end
  
  def tool_power(on = False, enabled = False):
    if not enabled:
      return None
    end
  
    return None
  end
  
  def coolant_flow(on = False, enabled = False):
    if not enabled:
      return None
    end
  
    return None
  end
  
  def apply_force(on = False, enabled = False):
    if not enabled:
      return None
    end
  
    return None
  end
  
  # Setup for grinding
  global grinding_state = False
  def set_grinding_state(on = False):
    if on and not grinding_state:
      if not contact_part(True, grind_contact_enabled):
        return False
      end
      tool_power(True, grind_contact_enabled)
      coolant_flow(True, grind_contact_enabled)
      apply_force(True, grind_contact_enabled)
      grinding_state = True
      return True
    elif not on and grinding_state:
      apply_force(False, grind_contact_enabled)
      contact_part(False, grind_contact_enabled)
      coolant_flow(False, grind_contact_enabled)
      tool_power(False, grind_contact_enabled)
      grinding_state = False
      return True
    end
    return True
  end
  
  # Abort system
  thread listener_thread():
    global haltCommand = [0, 0]
    global haltCount = 0
    while (True):
      global threadCount = threadCount + 1
      global haltCommand = socket_read_ascii_float(1, timeout = 0.1)
      if haltCommand[0] > 0:
        global haltCount = haltCount + 1
      end
    end
  
    return False
  end
  
  def ok_to_proceed():
    return haltCount == 0
  end
  
  # Grind along a line dx_mm x dy_mm centered on current tool position. Repeat n_cycles times.
  def grind_line(dx_mm, dy_mm, n_cycles):
    if n_cycles < 1:
      return True
    end
  
    # shape OK?
    shape = robot_part_geometry[0]
    if shape < 1 or shape > 3:
      return False
    end
  
    # Unit conversion
    dx_m = dx_mm / 1000.0
    dy_m = dy_mm / 1000.0
  
    # Find initial position p0
    p0 = get_actual_tcp_pose()
  
    # Move to start position
    if shape == 1:
      p1 = pose_trans(p0, p[-dx_m / 2, -dy_m / 2, 0, 0, 0, 0])
    elif shape == 2:
      radius_m = robot_part_geometry[1] / 2.0
      drx_rad = dy_m / radius_m
      p1 = pose_trans(p0, p[-dx_m / 2, 0, 0, -drx_rad / 2, 0, 0])
    elif shape == 3:
      radius_m = robot_part_geometry[1] / 2.0
      drx_rad = dy_m / radius_m
      dry_rad = dy_m / radius_m
      p1 = pose_trans(p0, p[0, 0, 0, -drx_rad / 2, -dry_rad / 2, 0])
    end
    movel(p1, a = robot_accel, v = robot_speed)
  
    if not set_grinding_state(True):
      movel(p0, a = robot_accel, v = robot_speed)
      return False
    end
  
    # Grind the pattern
    if shape == 1:
      pattern_line_flat(dx_m, dy_m, n_cycles)
    elif shape == 2:
      pattern_line_cylinder(dx_m, drx_rad, n_cycles)
    elif shape == 3:
      pattern_line_sphere(drx_rad, dry_rad, n_cycles)
    end
  
    set_grinding_state(False)
  
    # Return robot back to initial position
    movel(p0, a = robot_accel, v = robot_speed)
  end
  
  # Move along a flat line dx_m x dy_m starting at current position. Repeat n_cycles times.
  # Move in x direction first, then y
  def pattern_line_flat(dx_m, dy_m, n_cycles):
    # We're in contact at sw side...
    p0 = get_actual_tcp_pose()
    p1 = pose_trans(p0, p[dx_m, dy_m, 0, 0, 0, 0])
    pdest = p1
  
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      if ok_to_proceed():
        movel(pdest, a = grind_accel, v = grind_speed, r = grind_blend)
      end
  
      # Alternate directions for multiple cycles
      if pdest == p0:
        pdest = p1
      else:
        pdest = p0
      end
  
      grind_cycle = grind_cycle + 1
    end
  end
  
  # Move along a cylindrical line dx_mm,drx_rad starting at current position. Repeat n_cycles times.
  # Move in x direction first, then rx
  def pattern_line_cylinder(dx_m, drx_rad, n_cycles):
    # We're in contact at sw side...
    p0 = get_actual_tcp_pose()
    p1 = pose_trans(p0, p[dx_m, 0, 0, drx_rad, 0, 0])
    pdest = p1
  
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      if ok_to_proceed():
        # TODO What should the speed adjustment be here? Pure rotation seems to need a 2*PI
        movel(pdest, a = grind_accel, v = grind_speed * 2.0 * MATH_PI, r = grind_blend)
      end
  
      # Alternate directions for multiple cycles
      if pdest == p0:
        pdest = p1
      else:
        pdest = p0
      end
  
      grind_cycle = grind_cycle + 1
    end
  end
  
  # Move along a spherical line drx_rad,dry_rad starting at current tool position. Repeat n_cycles times.
  # Move in rx direction first, then ry
  def pattern_line_sphere(drx_rad, dry_rad, n_cycles):
    # We're in contact at sw side...
    p0 = get_actual_tcp_pose()
    p1 = pose_trans(p0, p[0, 0, 0, drx_rad, dry_rad, 0])
    pdest = p1
  
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      if ok_to_proceed():
        # TODO What should the speed adjustment be here? Pure rotation seems to need a 2*PI
        movel(pdest, a = grind_accel, v = grind_speed * 2.0 * MATH_PI, r = grind_blend)
      end
      # Alternate directions for multiple cycles
      if pdest == p0:
        pdest = p1
      else:
        pdest = p0
      end
  
      grind_cycle = grind_cycle + 1
    end
  end
  
  # Grind along a rect dx_mm x dy_mm centered on current tool position. Repeat n_cycles times.
  # Move in x direction first, then y
  def grind_rect(dx_mm, dy_mm, n_cycles):
    if n_cycles < 1:
      return True
    end
  
    # shape OK?
    shape = robot_part_geometry[0]
    if shape < 1 or shape > 3:
      return False
    end
  
    # Unit conversion
    dx_m = dx_mm / 1000.0
    dy_m = dy_mm / 1000.0
  
    # Find initial position p0
    p0 = get_actual_tcp_pose()
  
    # Move to start position
    if shape == 1:
      p1 = pose_trans(p0, p[-dx_m / 2, -dy_m / 2, 0, 0, 0, 0])
    elif shape == 2:
      radius_m = robot_part_geometry[1] / 2.0
      drx_rad = dy_m / radius_m
      p1 = pose_trans(p0, p[-dx_m / 2, 0, 0, -drx_rad / 2, 0, 0])
    elif shape == 3:
      radius_m = robot_part_geometry[1] / 2.0
      drx_rad = dy_m / radius_m
      dry_rad = dy_m / radius_m
      p1 = pose_trans(p0, p[0, 0, 0, -drx_rad / 2, -dry_rad / 2, 0])
    end
    movel(p1, a = robot_accel, v = robot_speed)
  
    if not set_grinding_state(True):
      movel(p0, a = robot_accel, v = robot_speed)
      return False
    end
  
    # Grind the pattern
    if shape == 1:
      pattern_rect_flat(dx_m, dy_m, n_cycles)
    elif shape == 2:
      pattern_rect_cylinder(dx_m, drx_rad, n_cycles)
    elif shape == 3:
      pattern_rect_sphere(drx_rad, dry_rad, n_cycles)
    end
  
    set_grinding_state(False)
  
    # Return robot back to initial position
    movel(p0, a = robot_accel, v = robot_speed)
  end
  
  # Move along a flat rect dx_m x dy_m starting at current position. Repeat n_cycles times.
  # Move in x direction first, then y
  def pattern_rect_flat(dx_m, dy_m, n_cycles):
    # We're in contact at sw side...
    p0 = get_actual_tcp_pose()
  
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      if ok_to_proceed():
        p1 = pose_trans(p0, p[dx_m, 0, 0, 0, 0, 0])
        movel(p1, a = grind_accel, v = grind_speed, r = grind_blend)
      end
  
      if ok_to_proceed():
        p1 = pose_trans(p0, p[dx_m, dy_m, 0, 0, 0, 0])
        movel(p1, a = grind_accel, v = grind_speed, r = grind_blend)
      end
  
      if ok_to_proceed():
        p1 = pose_trans(p0, p[0, dy_m, 0, 0, 0, 0])
        movel(p1, a = grind_accel, v = grind_speed, r = grind_blend)
      end
  
      if ok_to_proceed():
        movel(p0, a = grind_accel, v = grind_speed, r = grind_blend)
      end
      grind_cycle = grind_cycle + 1
    end
  end
  
  # Move along a cylindrical rect dx_mm,drx_rad starting at current position. Repeat n_cycles times.
  # Move in x direction first, then rx
  def pattern_rect_cylinder(dx_m, drx_rad, n_cycles):
    # We're in contact at sw side...
    p0 = get_actual_tcp_pose()
  
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      if ok_to_proceed():
        p1 = pose_trans(p0, p[dx_m, 0, 0, 0, 0, 0])
        movel(p1, a = grind_accel, v = grind_speed, r = grind_blend)
      end
  
      if ok_to_proceed():
        p1 = pose_trans(p0, p[dx_m, 0, 0, drx_rad, 0, 0])
        movel(p1, a = grind_accel, v = grind_speed * 2.0 * MATH_PI, r = grind_blend)
      end
  
      if ok_to_proceed():
        p1 = pose_trans(p0, p[0, 0, 0, drx_rad, 0, 0])
        movel(p1, a = grind_accel, v = grind_speed, r = grind_blend)
      end
  
      if ok_to_proceed():
        movel(p0, a = grind_accel, v = grind_speed * 2.0 * MATH_PI, r = grind_blend)
      end
      grind_cycle = grind_cycle + 1
    end
  end
  
  # Move along a sperical rect drx_rad,dry_rad starting at current tool position. Repeat n_cycles times.
  # Move in rx direction first, then ry
  def pattern_rect_sphere(drx_rad, dry_rad, n_cycles):
    # We're in contact at sw side...
    p0 = get_actual_tcp_pose()
  
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      if ok_to_proceed():
        p1 = pose_trans(p0, p[0, 0, 0, drx_rad, 0, 0])
        movel(p1, a = grind_accel, v = grind_speed * 2.0 * MATH_PI, r = grind_blend)
      end
  
      if ok_to_proceed():
        p1 = pose_trans(p0, p[0, 0, 0, drx_rad, dry_rad, 0])
        movel(p1, a = grind_accel, v = grind_speed * 2.0 * MATH_PI, r = grind_blend)
      end
  
      if ok_to_proceed():
        p1 = pose_trans(p0, p[0, 0, 0, 0, dry_rad, 0])
        movel(p1, a = grind_accel, v = grind_speed * 2.0 * MATH_PI, r = grind_blend)
      end
  
      if ok_to_proceed():
        movel(p0, a = grind_accel, v = grind_speed * 2.0 * MATH_PI, r = grind_blend)
      end
      grind_cycle = grind_cycle + 1
    end
  end
  
  # Grind along a rect in serpentine dx_mm,dy_mm incrementing by xstep_mm,ystep_mm centered on current tool position. Repeat n_cycles times.
  # Move in x direction first, then y
  def grind_serpentine(dx_mm, dy_mm, n_xsteps, n_ysteps, n_cycles):
    if n_cycles < 1:
      return True
    end
  
    # shape OK?
    shape = robot_part_geometry[0]
    if shape < 1 or shape > 3:
      return False
    end
  
    # Either n_xsteps or n_ysteps must be 1. Whichever one is one will be the direction of the first move.
    if n_xsteps != 1 and n_ysteps != 1:
      return False
    end
  
    # Unit conversion
    dx_m = dx_mm / 1000.0
    dy_m = dy_mm / 1000.0
  
    # Find initial position p0
    p0 = get_actual_tcp_pose()
  
    # Move to start position
    if shape == 1:
      p1 = pose_trans(p0, p[-dx_m / 2, -dy_m / 2, 0, 0, 0, 0])
    elif shape == 2:
      part_radius_m = robot_part_geometry[1] / 2.0
      drx_rad = dy_m / part_radius_m
      p1 = pose_trans(p0, p[-dx_m / 2, 0, 0, -drx_rad / 2, 0, 0])
    elif shape == 3:
      part_radius_m = robot_part_geometry[1] / 2.0
      drx_rad = dx_m / part_radius_m
      dry_rad = dy_m / part_radius_m
      p1 = pose_trans(p0, p[0, 0, 0, -drx_rad / 2, -dry_rad / 2, 0])
    end
    movel(p1, a = robot_accel, v = robot_speed)
  
    if not set_grinding_state(True):
      movel(p0, a = robot_accel, v = robot_speed)
      return False
    end
  
    # Grind the pattern
    if shape == 1:
      pattern_serpentine_flat(dx_m, dy_m, n_xsteps, n_ysteps, n_cycles)
    elif shape == 2:
      pattern_serpentine_cylinder(dx_m, drx_rad, n_xsteps, n_ysteps, n_cycles)
    elif shape == 3:
      pattern_serpentine_sphere(drx_rad, dry_rad, n_xsteps, n_ysteps, n_cycles)
    end
  
    set_grinding_state(False)
  
    # Return robot back to initial position
    movel(p0, a = robot_accel, v = robot_speed)
  end
  
  # Move along a flat serpentine dx_m,dy_m in n_xsteps,n_ysteps starting at current tool position. Repeat n_cycles times.
  # Move in direction of whichever nsteps is 1 first
  def pattern_serpentine_flat(dx_m, dy_m, n_xsteps, n_ysteps, n_cycles):
    # We're in contact at sw side...
    p0 = get_actual_tcp_pose()
  
    # Track our grid square number... we're in [0,0] and moving [+1,+1] in either x or y
    x_grid = 0
    y_grid = 0
    x_incr = 1
    y_incr = 1
    grid_dx_m = dx_m / n_xsteps
    grid_dy_m = dy_m / n_ysteps
  
    # How many moves does it take to complete a pass?
    global n_moves_per_pass = (n_xsteps + n_ysteps) * 2 - 1
  
    move_count = 0
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      # Skip first X move if we should start with a y move
      if grind_cycle != 1 or move_count != 0 or n_xsteps == 1:
        # Advance x_grid by x_incr
        x_grid = x_grid + x_incr
  
        # Move to the corresponding position
        p1 = pose_trans(p0, p[x_grid * grid_dx_m, y_grid * grid_dy_m, 0, 0, 0, 0])
        movel(p1, a = grind_accel, v = grind_speed, r = grind_blend)
  
        # Adjust x direction
        if x_grid >= n_xsteps:
          x_incr = -1
        elif x_grid <= 0:
          x_incr = 1
        end
        move_count = move_count + 1
      end
  
      if ok_to_proceed() and move_count < n_moves_per_pass:
        # Advance y_grid by y_incr
        y_grid = y_grid + y_incr
  
        # Move to the corresponding position
        p1 = pose_trans(p0, p[x_grid * grid_dx_m, y_grid * grid_dy_m, 0, 0, 0, 0])
        movel(p1, a = grind_accel, v = grind_speed, r = grind_blend)
  
        # Adjust y direction
        if y_grid >= n_ysteps:
          y_incr = -1
        elif y_grid <= 0:
          y_incr = 1
        end
        move_count = move_count + 1
      end
  
      # Detect when we've covered all the grid squares!
      if move_count >= n_moves_per_pass:
        grind_cycle = grind_cycle + 1
        move_count = 0
      end
    end
  end
  
  # Move along a cylindrical serpentine dx_m,drx_rad in n_xsteps,n_rxsteps starting at current tool position. Repeat n_cycles times.
  # Move in direction of whichever nsteps is 1 first
  def pattern_serpentine_cylinder(dx_m, drx_rad, n_xsteps, n_rxsteps, n_cycles):
    # We're in contact at sw side...
    p0 = get_actual_tcp_pose()
  
    # Track our grid square number... we're in [0,0] and moving [+1,+1] in either x or y
    x_grid = 0
    y_grid = 0
    x_incr = 1
    y_incr = 1
    grid_dx_m = dx_m / n_xsteps
    grid_drx_rad = drx_rad / n_rxsteps
  
    # How many moves does it take to complete a pass?
    global n_moves_per_pass = (n_xsteps + n_rxsteps) * 2 - 1
  
    move_count = 0
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      # Skip first X move if we should start with a y move
      if grind_cycle != 1 or move_count != 0 or n_xsteps == 1:
        # Advance x_grid by x_incr
        x_grid = x_grid + x_incr
  
        # Move to the corresponding position
        p1 = pose_trans(p0, p[x_grid * grid_dx_m, 0, 0, y_grid * grid_drx_rad, 0, 0])
        movel(p1, a = grind_accel, v = grind_speed, r = grind_blend)
  
        # Adjust x direction
        if x_grid >= n_xsteps:
          x_incr = -1
        elif x_grid <= 0:
          x_incr = 1
        end
        move_count = move_count + 1
      end
  
      if ok_to_proceed() and move_count < n_moves_per_pass:
        # Advance y_grid by y_incr
        y_grid = y_grid + y_incr
  
        # Move to the corresponding position
        p1 = pose_trans(p0, p[x_grid * grid_dx_m, 0, 0, y_grid * grid_drx_rad, 0, 0])
        # TODO Is this 2PI speed factor necessary
        movel(p1, a = grind_accel, v = grind_speed * 2.0 * MATH_PI, r = grind_blend)
  
        # Adjust y direction
        if y_grid >= n_rxsteps:
          y_incr = -1
        elif y_grid <= 0:
          y_incr = 1
        end
        move_count = move_count + 1
      end
  
      # Detect when we've covered all the grid squares!
      if move_count >= n_moves_per_pass:
        grind_cycle = grind_cycle + 1
        move_count = 0
      end
    end
  end
  
  # Move along a sperical serpentine drx_rad,dry_rad in n_rxsteps,n_rysteps starting at current tool position. Repeat n_cycles times.
  # Move in direction of whichever nsteps is 1 first
  def pattern_serpentine_sphere(drx_rad, dry_rad, n_rxsteps, n_rysteps, n_cycles):
    # We're in contact at sw side...
    p0 = get_actual_tcp_pose()
  
    # Track our grid square number... we're in [0,0] and moving [+1,+1] in either x or y
    x_grid = 0
    y_grid = 0
    x_incr = 1
    y_incr = 1
    grid_drx_rad = drx_rad / n_rxsteps
    grid_dry_rad = dry_rad / n_rysteps
  
    # How many moves does it take to complete a pass?
    global n_moves_per_pass = (n_rxsteps + n_rysteps) * 2 - 1
  
    move_count = 0
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      # Skip first X move if we should start with a y move
      if grind_cycle != 1 or move_count != 0 or n_rxsteps == 1:
        # Advance x_grid by x_incr
        x_grid = x_grid + x_incr
  
        # Move to the corresponding position
        p1 = pose_trans(p0, p[0, 0, 0, x_grid * grid_drx_rad, y_grid * grid_dry_rad, 0])
        # TODO Is this 2PI speed factor necessary
        movel(p1, a = grind_accel, v = grind_speed * 2.0 * MATH_PI, r = grind_blend)
  
        # Adjust x direction
        if x_grid >= n_rxsteps:
          x_incr = -1
        elif x_grid <= 0:
          x_incr = 1
        end
        move_count = move_count + 1
      end
  
      if ok_to_proceed() and move_count < n_moves_per_pass:
        # Advance y_grid by y_incr
        y_grid = y_grid + y_incr
  
        # Move to the corresponding position
        p1 = pose_trans(p0, p[0, 0, 0, x_grid * grid_drx_rad, y_grid * grid_dry_rad, 0])
        # TODO Is this 2PI speed factor necessary
        movel(p1, a = grind_accel, v = grind_speed * 2.0 * MATH_PI, r = grind_blend)
  
        # Adjust y direction
        if y_grid >= n_rysteps:
          y_incr = -1
        elif y_grid <= 0:
          y_incr = 1
        end
        move_count = move_count + 1
      end
  
      # Detect when we've covered all the grid squares!
      if move_count >= n_moves_per_pass:
        grind_cycle = grind_cycle + 1
        move_count = 0
      end
    end
  end
  
  # Grind along a circle with circle_diam_mm centered on current tool position. Repeat n_cycles times.
  def grind_circle(circle_diam_mm, n_cycles):
    if n_cycles < 1:
      return True
    end
  
    # shape OK?
    shape = robot_part_geometry[0]
    if shape < 1 or shape > 3:
      return False
    end
  
    # Unit conversion
    circle_diam_m = circle_diam_mm / 1000.0
  
    # Find initial position p0
    p0 = get_actual_tcp_pose()
  
    # Move to start position
    if shape == 1:
      p1 = pose_trans(p0, p[circle_diam_m / 2.0, 0, 0, 0, 0, 0])
    elif shape == 2:
      part_diam_m = robot_part_geometry[1]
      p1 = pose_trans(p0, p[circle_diam_m / 2.0, 0, 0, 0, 0, 0])
    elif shape == 3:
      part_diam_m = robot_part_geometry[1]
      p1 = pose_trans(p0, p[0, 0, 0, circle_diam_m / part_diam_m, 0, 0])
    end
    movel(p1, a = robot_accel, v = robot_speed)
  
    if not set_grinding_state(True):
      movel(p0, a = robot_accel, v = robot_speed)
      return False
    end
  
    # Grind the pattern
    if shape == 1:
      pattern_circle_flat(circle_diam_m, n_cycles)
    elif shape == 2:
      pattern_circle_cylinder(circle_diam_m, part_diam_m, n_cycles)
    elif shape == 3:
      pattern_circle_sphere(circle_diam_m, part_diam_m, n_cycles)
    end
  
    set_grinding_state(False)
  
    # Return robot back to initial position
    movel(p0, a = robot_accel, v = robot_speed)
  end
  
  # Grind along a flat circle circle_diam_m starting at current tool position. Repeat n_cycles times.
  def pattern_circle_flat(circle_diam_m, n_cycles):
  
    # Unit conversion
    n_points = ceil(circle_diam_m * 1000.0)   # 10 points in a 10mm diam circle... linear n_points up and down from there
    circle_radius_m = circle_diam_m / 2.0     # Circle radius is half of specified dx
  
    # We're in contact at east side... compute where contact position would be at center of circle
    p_center = pose_trans(get_forward_kin(), p[-circle_radius_m, 0, 0, 0, 0, 0])
  
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      i = 1
      while ok_to_proceed() and i <= n_points:
        theta = d2r(360.0 * i / n_points)
        x = circle_radius_m * cos(theta)
        y = circle_radius_m * sin(theta)
  
        p1 = pose_trans(p_center, p[x, y, 0, 0, 0, 0])
        movel(p1, a = grind_accel, v = grind_speed, r = grind_blend)
        i = i + 1
      end
  
      grind_cycle = grind_cycle + 1
    end
  end
  
  # Move along a cylindrical circle circle_diam_m on a cylinder_diam_m object starting at the current tool position. Repeat n_cycles times.
  def pattern_circle_cylinder(circle_diam_m, cylinder_radius_m, n_cycles):
    # Unit conversion
    n_points = ceil(circle_diam_m * 1000.0)   # 10 points in a 10mm diam circle... linear n_points up and down from there
    circle_radius_m = circle_diam_m / 2.0
  
    # We're in contact at east side... compute where contact position would be at center of circle
    p_center = pose_trans(get_forward_kin(), p[-circle_radius_m, 0, 0, 0, 0, 0])
  
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      i = 1
      while ok_to_proceed() and i <= n_points:
        theta = d2r(360.0 * i / n_points)
        x = circle_radius_m * cos(theta)
        y = circle_radius_m * sin(theta)
        rx = y / cylinder_radius_m
  
        p1 = pose_trans(p_center, p[x, 0, 0, rx, 0, 0])
        movel(p1, a = grind_accel, v = grind_speed * 2.0 * MATH_PI, r = grind_blend)
        i = i + 1
      end
  
      grind_cycle = grind_cycle + 1
    end
  end
  
  # Move along a spherical circle circle_diam_m on a sphere_diam_m object starting at the current tool position. Repeat n_cycles times.
  def pattern_circle_sphere(circle_diam_m, sphere_diam_m, n_cycles):
    # Unit conversion
    n_points = ceil(circle_diam_m * 1000.0)   # 10 points in a 10mm diam circle... linear n_points up and down from there
    circle_radius_m = circle_diam_m / 2.0
    sphere_radius_m = sphere_diam_m / 2.0
  
    # We're in contact at east side... compute where contact position would be at center of circle
    p_center = pose_trans(get_forward_kin(), p[0, 0, 0, -circle_diam_m / sphere_diam_m / 2.0, 0, 0])
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      i = 1
      while ok_to_proceed() and i <= n_points:
        theta = d2r(360.0 * i / n_points)
        x = circle_radius_m * cos(theta)
        rx = x / sphere_radius_m
        y = circle_radius_m * sin(theta)
        ry = y / sphere_radius_m
  
        p1 = pose_trans(p_center, p[0, 0, 0, rx, ry, 0])
        movel(p1, a = grind_accel, v = grind_speed * 2.0 * MATH_PI, r = grind_blend)
        i = i + 1
      end
  
      grind_cycle = grind_cycle + 1
    end
  end
  
  # Grind along a spiral circle1_diam_mm to circle2_diam_mm in n_spirals with rotations centered on current tool position. Repeat n_cycles times.
  def grind_spiral(circle1_diam_mm, circle2_diam_mm, n_spirals, n_cycles):
    if n_cycles < 1:
      return True
    end
  
    # shape OK?
    shape = robot_part_geometry[0]
    if shape < 1 or shape > 3:
      return False
    end
  
    # Unit conversion
    circle1_diam_m = circle1_diam_mm / 1000.0
    circle2_diam_m = circle2_diam_mm / 1000.0
  
    # Find initial position p0
    p0 = get_actual_tcp_pose()
  
    # Move to start position
    if shape == 1:
      p1 = pose_trans(p0, p[circle1_diam_m / 2.0, 0, 0, 0, 0, 0])
    elif shape == 2:
      part_diam_m = robot_part_geometry[1]
      p1 = pose_trans(p0, p[circle1_diam_m / 2.0, 0, 0, 0, 0, 0])
    elif shape == 3:
      part_diam_m = robot_part_geometry[1]
      p1 = pose_trans(p0, p[0, 0, 0, circle1_diam_m / part_diam_m / 2.0, 0, 0])
    end
    movel(p1, a = robot_accel, v = robot_speed)
  
    if not set_grinding_state(True):
      movel(p0, a = robot_accel, v = robot_speed)
      return False
    end
  
    # Grind the pattern
    if shape == 1:
      pattern_spiral_flat(circle1_diam_m, circle2_diam_m, n_spirals, n_cycles)
    elif shape == 2:
      #pattern_circle_cylinder(circle1_diam_m, circle2_diam_m, n_spirals, part_diam_m, n_cycles) # NOT IMPLEMENTED
    elif shape == 3:
      #pattern_circle_sphere(circle1_diam_m, circle2_diam_m, n_spirals, part_diam_m, n_cycles) # NOT IMPLEMENTED
    end
  
    set_grinding_state(False)
  
    # Return robot back to initial position
    movel(p0, a = robot_accel, v = robot_speed)
    return True
  end
  
  def pattern_spiral_flat(circle1_diam_m, circle2_diam_m, n_spirals, n_cycles):
    # Unit conversion
    circle1_radius_m = circle1_diam_m / 2.0
    circle2_radius_m = circle2_diam_m / 2.0
  
    max_diam_m = circle1_radius_m
    if circle2_diam_m > max_diam_m:
      max_diam_m = circle2_radius_m
    end
    n_points = ceil(max_diam_m * 1000.0) # 10 points in a 10mm diam circle... linear n_points up and down from there
    n_total_points = n_spirals * n_points
  
    # We're in contact at east side... compute where contact position would be at center of circle
    p_center = pose_trans(get_forward_kin(), p[-circle1_diam_m / 2.0, 0, 0, 0, 0, 0])
  
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      rslope = (circle2_radius_m - circle1_radius_m) / n_total_points
      i = 0
      while ok_to_proceed() and i <= n_total_points:
        theta = d2r(360.0 * (i % n_points) / n_points)
        r_instantaneous = i * rslope + circle1_radius_m
        x = r_instantaneous * cos(theta)
        y = r_instantaneous * sin(theta)
  
        p1 = pose_trans(p_center, p[x, y, 0, 0, 0, 0])
        movel(p1, a = grind_accel, v = grind_speed, r = grind_blend)
        i = i + 1
      end
  
      grind_cycle = grind_cycle + 1
      # Next cycle- swap diameters so we go in/out/in etc.
      old_circle1_radius_m = circle1_radius_m
      circle1_radius_m = circle2_radius_m
      circle2_radius_m = old_circle1_radius_m
    end
  end
  
  $ 5 "currentTcpPose≔get_actual_tcp_pose()"
  global currentTcpPose= get_actual_tcp_pose ()
  $ 6 "MoveJ"
  $ 7 "currentTcpPose" "breakAfter"
  movej(currentTcpPose, a=1.3962634015954636, v=1.0471975511965976)
  $ 10 "socket_is_open≔ False "
  global socket_is_open=  False  
  $ 11 "command_index≔0"
  global command_index=0
  while (True):
    $ 12 "Robot Program"
    $ 13 "Loop socket_is_open ≟  False "
    while (socket_is_open  ==    False  ):
      $ 14 "Wait: 0.25"
      sleep(0.25)
      $ 15 "socket_close()"
      socket_close()
      $ 16 "socket_is_open≔socket_open('192.168.25.1', 30000)"
      global socket_is_open=socket_open("192.168.25.1", 30000)
    end
    $ 17 "response≔'Unknown command'"
    global response="Unknown command"
    $ 18 "command≔socket_read_ascii_float(10)"
    global command=socket_read_ascii_float(10)
    $ 19 "If command[0]≥1"
    if (command[0] >= 1):
      $ 20 "socket_send_line('robot_ready=False')"
      socket_send_line("robot_ready=False")
      $ 21 "command_index≔command_index+1"
      global command_index=command_index+1
      $ 22 "socket_set_var('robot_index', command_index)"
      socket_set_var("robot_index", command_index)
      $ 23 "lastCommand≔command"
      global lastCommand=command
      $ 24 "Switch command[1]"
      switch_1 = command[1]
      $ 25 "Case 10"
      if (10 == switch_1):
        $ 26 "return_actual_tcp_pose()"
        return_actual_tcp_pose()
      elif (12 == switch_1):
        $ 27 "Case 12"
        $ 28 "return_tcp_offset()"
        return_tcp_offset()
      elif (13 == switch_1):
        $ 29 "Case 13"
        $ 30 "movel_relative_base(p[command[2], command[3], command[4], command[5], command[6], command[7]])"
        movel_relative_base(p[command[2], command[3], command[4], command[5], command[6], command[7]])
      elif (14 == switch_1):
        $ 31 "Case 14"
        $ 32 "movel_relative_tcp(p[command[2], command[3], command[4], command[5], command[6], command[7]])"
        movel_relative_tcp(p[command[2], command[3], command[4], command[5], command[6], command[7]])
      elif (15 == switch_1):
        $ 33 "Case 15"
        $ 34 "movel_relative_tcp_part(p[command[2], command[3], command[4], command[5], command[6], command[7]])"
        movel_relative_tcp_part(p[command[2], command[3], command[4], command[5], command[6], command[7]])
      elif (16 == switch_1):
        $ 35 "Case 16"
        $ 36 "movel_one_only(command[2],command[3])"
        movel_one_only(command[2],command[3])
      elif (18 == switch_1):
        $ 37 "Case 18"
        $ 38 "movel_rot_only(command[2],command[3],command[4])"
        movel_rot_only(command[2],command[3],command[4])
      elif (20 == switch_1):
        $ 39 "Case 20"
        $ 40 "return_get_actual_joint_positions()"
        return_get_actual_joint_positions()
      elif (21 == switch_1):
        $ 41 "Case 21"
        $ 42 "movej_ag([command[2], command[3], command[4], command[5], command[6], command[7]])"
        movej_ag([command[2], command[3], command[4], command[5], command[6], command[7]])
      elif (22 == switch_1):
        $ 43 "Case 22"
        $ 44 "movel_ag(p[command[2], command[3], command[4], command[5], command[6], command[7]])"
        movel_ag(p[command[2], command[3], command[4], command[5], command[6], command[7]])
      elif (25 == switch_1):
        $ 45 "Case 25"
        $ 46 "return_both_positions()"
        return_both_positions()
      elif (30 == switch_1):
        $ 47 "Case 30"
        $ 48 "set_variable()"
        set_variable()
      elif (40 == switch_1):
        $ 49 "Case 40"
        $ 50 "pattern_grind()"
        pattern_grind()
      elif (50 == switch_1):
        $ 51 "Case 50"
        $ 52 "Call AG_50"
        AG_50()
      elif (98 == switch_1):
        $ 53 "Case 98"
        $ 54 "response≔'socket reset'"
        global response="socket reset"
      elif (99 == switch_1):
        $ 55 "Case 99"
        $ 56 "response≔'exiting'"
        global response="exiting"
      else:
        $ 57 "Default Case"
        $ 58 "response≔'unknown command'"
        global response="unknown command"
      end
      $ 59 "socket_send_line('robot_response=' + response + '#robot_ready=True')"
      socket_send_line("robot_response=" + response + "#robot_ready=True")
      $ 60 "If command[1]≟98"
      if (command[1] == 98):
        $ 61 "Wait: 0.5"
        sleep(0.5)
        $ 62 "socket_close()"
        socket_close()
        $ 63 "socket_is_open≔ False "
        global socket_is_open=  False  
      end
      $ 64 "If command[1]≟99"
      if (command[1] == 99):
        $ 65 "Wait: 0.5"
        sleep(0.5)
        $ 66 "socket_close()"
        socket_close()
        $ 67 "socket_is_open≔ False "
        global socket_is_open=  False  
        $ 68 "Halt"
        halt
      end
    else:
      $ 69 "Else" "noBreak"
    end
  end
end
