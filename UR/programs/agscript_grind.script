# AutoGrind Grinding Functions
# File: agscript_grind.script
# Version 1.0
# Programmer: Ned Lecky

global listenerThread = 0
global threadCount = 0
global haltCount = 0
global haltCommand = [0, 0]

# TODO this should come from the TCP selected for the current tool
global tool_length_m = 0.175

global grind_ready = True
global grind_contact_enabled = False

def tool_power(on = False):

  return None
end

def coolant_flow(on = False):

  return None
end

def apply_force(on = False):

  return None
end

# Get into contact with part (or away from)
def contact_part(on = False):
  if on:
    # Advance until contact
    # Simulated....
    p1 = pose_trans(get_forward_kin(), p[0, 0, 0.020, 0, 0, 0])
    movel(p1, robot_accel, robot_speed)

    # TODO if fails should return to initial position
  else:
    p1 = pose_trans(get_forward_kin(), p[0, 0, -0.020, 0, 0, 0])
    movel(p1, robot_accel, robot_speed)
  end

  return True
end

# Setup for grinding
global grinding_state = False
def set_grinding_state(on = False):
  if on and not grinding_state:
    if not grind_contact_enabled:
      return True
    end
    if not contact_part(True):
      return False
    end
    tool_power(True)
    coolant_flow(True)
    apply_force(True)
    grinding_state = True
    return True
  elif not on and grinding_state:
    apply_force(False)
    contact_part(False)
    coolant_flow(False)
    tool_power(False)
    grinding_state = False
    return True
  end
  return True
end

# Abort system
thread listener_thread():
  global haltCommand = [0, 0]
  global haltCount = 0
  while (True):
    global threadCount = threadCount + 1
    global haltCommand = socket_read_ascii_float(1, timeout = 0.1)
    if haltCommand[0] > 0:
      global haltCount = haltCount + 1
    end
  end

  return False
end

def ok_to_proceed():
  return haltCount == 0
end

# Execute the desired pattern grind selected by command[2]...
def pattern_grind():
  global grind_ready = False
  socket_send_line("grind_ready=False")

  if listenerThread > 0:
    kill listenerThread
    listenerThread = 0
  end
  listenerThread = run listener_thread()

  global grind_cycle = 0
  global grind_n_cycles = 0
  global grind_dx_mm = 0
  global grind_dx2_mm = 0
  global grind_dy_mm = 0
  global grind_n_spirals = 0
  global grind_radius_mm = 0
  global grind_xstep_mm = 0
  global grind_ystep_mm = 0
  global grind_rstep_mm = 0

  if command[2] == 1:
    global response = "set grind_contact_enabled"
    if command[3] > 0:
      global grind_contact_enabled = True
      socket_send_line("grind_contact_enabled=True")
    else:
      global grind_contact_enabled = False
      socket_send_line("grind_contact_enabled=False")
    end

  # RECTANGLAR GRINDS
  elif command[2] == 10:
    global response = "grind_flat_rect"
    global grind_dx_mm = command[3]
    global grind_dy_mm = command[4]
    global grind_n_cycles = command[5]
    grind_flat_rect(grind_dx_mm, grind_dy_mm, grind_n_cycles)
  elif command[2] == 11:
    global response = "grind_cyl_rect"
    global grind_dx_mm = command[3]
    global grind_dy_mm = command[4]
    global grind_radius_mm = command[5]
    global grind_n_cycles = command[6]
    grind_cyl_rect(grind_dx_mm, grind_dy_mm, grind_radius_mm, grind_n_cycles)
  elif command[2] == 12:
    global response = "grind_sphere_rect"
    global grind_dx_mm = command[3]
    global grind_dy_mm = command[4]
    global grind_radius_mm = command[5]
    global grind_n_cycles = command[6]
    grind_sphere_rect(grind_dx_mm, grind_dy_mm, grind_radius_mm, grind_n_cycles)

  # SERPENTINE GRINDS
  elif command[2] == 20:
    global response = "grind_flat_serp"
    global grind_dx_mm = command[3]
    global grind_dy_mm = command[4]
    global grind_xstep_mm = command[5]
    global grind_ystep_mm = command[6]
    global grind_n_cycles = command[7]
    grind_flat_serp(grind_dx_mm, grind_dy_mm, grind_xstep_mm, grind_ystep_mm, grind_n_cycles)
  elif command[2] == 21:
    global response = "grind_cyl_serp"
    global grind_dx_mm = command[3]
    global grind_dy_mm = command[4]
    global grind_xstep_mm = command[5]
    global grind_ystep_mm = command[6]
    global grind_radius_mm = command[7]
    global grind_n_cycles = command[8]
    grind_cyl_serp(grind_dx_mm, grind_dy_mm, grind_xstep_mm, grind_ystep_mm, grind_radius_mm, grind_n_cycles)

  # CIRCULAR GRINDS
  elif command[2] == 30:
    global response = "grind_flat_circle"
    global grind_dx_mm = command[3]
    global grind_n_cycles = command[4]
    grind_flat_circle(grind_dx_mm, grind_n_cycles)
  elif command[2] == 31:
    global response = "grind_sphere_circle"
    global grind_dx_mm = command[3]
    global grind_dy_mm = command[4]
    global grind_radius_mm = command[5]
    global grind_n_cycles = command[6]
    grind_sphere_circle(grind_dx_mm, grind_radius_mm, grind_n_cycles)

  # SPIRAL GRINDS
  elif command[2] == 40:
    global response = "grind_flat_spiral"
    global grind_dx_mm = command[3]
    global grind_dx2_mm = command[4]
    global grind_n_spirals = command[5]
    global grind_n_cycles = command[6]
    grind_flat_spiral(grind_dx_mm, grind_dx2_mm, grind_n_spirals, grind_n_cycles)
  else:
    global response = "Unknown Grind Command"
  end

  kill listenerThread
  listenerThread = 0

  global grind_ready = True
  socket_send_line("grind_ready=True")
end

# Grind along a flat rect dx_mm x dy_mm centered on current tool position. Repeat n_cycles times.
# Move in x direction first, then y
def grind_flat_rect(dx_mm, dy_mm, n_cycles):
  if n_cycles < 1:
    return True
  end

  # Unit conversion
  dx_m = dx_mm / 1000.0
  dy_m = dy_mm / 1000.0

  # Find initial position p0
  set_tcp(p[0, 0, tool_length_m, 0, 0, 0])
  p0 = get_actual_tcp_pose()

  # Move to offset position bottom left of scan area
  p1 = pose_trans(get_forward_kin(), p[-dx_m / 2, -dy_m / 2, 0, 0, 0, 0])
  movel(p1, robot_accel, robot_speed)

  if not set_grinding_state(True):
    movel(p0, a=robot_accel, v=robot_speed)
    return False
  end

  # Grind box pattern
  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[dx_m, 0, 0, 0, 0, 0])
      movel(p1, a=robot_accel, v=robot_speed, r=robot_blend)
    end

    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[0, dy_m, 0, 0, 0, 0])
      movel(p1, a=robot_accel, v=robot_speed, r=robot_blend)
    end

    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[-dx_m, 0, 0, 0, 0, 0])
      movel(p1, a=robot_accel, v=robot_speed, r=robot_blend)
    end

    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[0, -dy_m, 0, 0, 0, 0])
      movel(p1, a=robot_accel, v=robot_speed, r=robot_blend)
    end
    grind_cycle = grind_cycle + 1
  end

  set_grinding_state(False)

  # Return robot back to initial position
  movel(p0, a=robot_accel, v=robot_speed)
  return True
end

# Grind along a cylindrical rect dx_mm,dy_mm with radius_mm centered on current tool position. Repeat n_cycles times.
# Move in x direction first, then r
def grind_cyl_rect(dx_mm, dy_mm, radius_mm, n_cycles):
  if n_cycles < 1:
    return False
  end

  # Unit conversion
  dx_m = dx_mm / 1000.0
  radius_m = radius_mm / 1000.0
  drx_rad = dy_mm / radius_mm

  # Find initial position p0
  set_tcp(p[0, 0, tool_length_m + radius_m, 0, 0, 0])
  p0 = get_actual_tcp_pose()

  # Move to offset position bottom left of scan area
  p1 = pose_trans(get_forward_kin(), p[-dx_m / 2, 0, 0, -drx_rad / 2, 0, 0])
  movel(p1, a=robot_accel, v=robot_speed)

  if not set_grinding_state(True):
    movel(p0, a=robot_accel, v=robot_speed)
    return False
  end

  # Grind cylindrical box pattern
  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[dx_m, 0, 0, 0, 0, 0])
      movel(p1, a=robot_accel, v=robot_speed, r=robot_blend)
    end

    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[0, 0, 0, drx_rad, 0, 0])
      movel(p1, a=robot_accel, v=robot_speed, r=robot_blend)
    end

    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[-dx_m, 0, 0, 0, 0, 0])
      movel(p1, a=robot_accel, v=robot_speed, r=robot_blend)
    end

    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[0, 0, 0, -drx_rad, 0, 0])
      movel(p1, a=robot_accel, v=robot_speed, r=robot_blend)
    end
    grind_cycle = grind_cycle + 1
  end

  set_grinding_state(False)

  # Return robot back to initial position
  movel(p0, a=robot_accel, v=robot_speed)
  return True
end

# Grind along a cylindrical rect dx_mm,dy_mm with radius_mm centered on current tool position. Repeat n_cycles times.
# Move in x direction first, then r
def grind_sphere_rect(dx_mm, dy_mm, radius_mm, n_cycles):
  if n_cycles < 1:
    return False
  end

  # Unit conversion
  radius_m = radius_mm / 1000.0
  drx_rad = dx_mm / radius_mm
  dry_rad = dy_mm / radius_mm

  # Find initial position p0
  set_tcp(p[0, 0, tool_length_m + radius_m, 0, 0, 0])
  p0 = get_actual_tcp_pose()

  # Move to offset position bottom left of scan area
  p1 = pose_trans(get_forward_kin(), p[0, 0, 0, -drx_rad / 2, -dry_rad / 2, 0])
  movel(p1, a=robot_accel, v=robot_speed)

  if not set_grinding_state(True):
    movel(p0, a=robot_accel, v=robot_speed)
    return False
  end

  # Grind cylindrical box pattern
  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[0, 0, 0, drx_rad, 0, 0])
      movel(p1, a=robot_accel, v=robot_speed, r=robot_blend)
    end

    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[0, 0, 0, 0, dry_rad, 0])
      movel(p1, a=robot_accel, v=robot_speed, r=robot_blend)
    end

    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[0, 0, 0, -drx_rad, 0, 0])
      movel(p1, a=robot_accel, v=robot_speed, r=robot_blend)
    end

    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[0, 0, 0, 0, -dry_rad, 0])
      movel(p1, a=robot_accel, v=robot_speed, r=robot_blend)
    end
    grind_cycle = grind_cycle + 1
  end

  set_grinding_state(False)

  # Return robot back to initial position
  movel(p0, a=robot_accel, v=robot_speed)
  return True
end

# Grind along a flat serpentine dx_mm,dy_mm incrementing by xstep_mm,ystep_mm centered on current tool position. Repeat n_cycles times.
# Move in x direction first, then y
def grind_flat_serp(dx_mm, dy_mm, xstep_mm, ystep_mm, n_cycles):
  if n_cycles < 1:
    return False
  end

  # Unit conversion
  dx_m = dx_mm / 1000.0
  dy_m = dy_mm / 1000.0
  xstep_m = xstep_mm / 1000.0
  ystep_m = ystep_mm / 1000.0
  x_grid_count = floor(dx_m / xstep_m)
  y_grid_count = floor(dy_m / ystep_m)

  # Find initial position
  set_tcp(p[0, 0, tool_length_m, 0, 0, 0])
  p0 = get_actual_tcp_pose()

  # Move to offset position bottom left of scan area
  p1 = pose_trans(get_forward_kin(), p[-dx_m / 2, -dy_m / 2, 0, 0, 0, 0])
  movel(p1, a=robot_accel, v=robot_speed)

  if not set_grinding_state(True):
    movel(p0, robot_accel, robot_speed)
    return False
  end

  # Grind serpentine pattern
  global grind_cycle = 1
  x_grid = 0
  y_grid = 0
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    # Advance x by xstep_m
    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[xstep_m, 0, 0, 0, 0, 0])
      movel(p1, a=robot_accel, v=robot_speed, r=robot_blend)

      # Track new grid square we're in
      if xstep_m > 0:
        x_grid = x_grid + 1
      else:
        x_grid = x_grid - 1
      end
    end
    # Adjust x direction
    if x_grid >= x_grid_count-1 and xstep_m > 0:
      xstep_m = -xstep_m
    elif x_grid == 0 and xstep_m < 0:
      xstep_m = -xstep_m
    end

    # Advance y by ystep_m
    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[0, ystep_m, 0, 0, 0, 0])
      movel(p1, a=robot_accel, v=robot_speed, r=robot_blend)
      # Track new grid square we're in
      if ystep_m > 0:
        y_grid = y_grid + 1
      else:
        y_grid = y_grid - 1
      end
    end
    # Adjust y direction
    if y_grid >= y_grid_count-1 and ystep_m > 0:
      ystep_m = -ystep_m
    elif y_grid == 0 and ystep_m < 0:
      ystep_m = -ystep_m
    end

    # Detect when we've covered all the grid squares!
    # That's when you reach n-1,n-1 or 0,0
    if x_grid == x_grid_count - 1 and y_grid == y_grid_count - 1:
      grind_cycle = grind_cycle + 1
    elif x_grid == 0 and y_grid == 0:
      grind_cycle = grind_cycle + 1
    end
  end

  set_grinding_state(False)

  # Return robot back to initial position
  movel(p0, a=robot_accel, v=robot_speed)
  return True
end

# Grind along a cylindrical serpentine dx_mm,dy_mm incrementing by xstep_mm,rstep_mm centered on current tool position. Repeat n_cycles times.
# Move in x direction first, then r
def grind_cyl_serp(dx_mm, dy_mm, xstep_mm, ystep_mm, radius_mm, n_cycles):
  if n_cycles < 1:
    return False
  end

  # Unit conversion
  dx_m = dx_mm / 1000.0
  radius_m = radius_mm / 1000.0
  drx_rad = dy_mm / radius_mm
  xstep_m = xstep_mm / 1000.0
  rstep_rad = ystep_mm / radius_mm
  x_grid_count = floor(dx_mm / xstep_mm)
  r_grid_count = floor(dy_mm / ystep_mm)

  # Find initial position
  set_tcp(p[0, 0, tool_length_m + radius_m, 0, 0, 0])
  p0 = get_actual_tcp_pose()

  # Move to offset position bottom left of scan area
  p1 = pose_trans(get_forward_kin(), p[-dx_m / 2, 0, 0, -drx_rad / 2, 0, 0])
  movel(p1, a=robot_accel, v=robot_speed)

  if not set_grinding_state(True):
    movel(p0, a=robot_accel, v=robot_speed)
    return False
  end

  # Grind serpentine pattern
  global grind_cycle = 1
  x_grid = 0
  r_grid = 0
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    # Advance x by xstep_m
    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[xstep_m, 0, 0, 0, 0, 0])
      movel(p1, a=robot_accel, v=robot_speed, r=robot_blend)
      # Track new grid square we're in
      if xstep_m > 0:
        x_grid = x_grid + 1
      else:
        x_grid = x_grid - 1
      end
    end
    # Adjust x direction
    if x_grid >= x_grid_count-1 and xstep_m > 0:
      xstep_m = -xstep_m
    elif x_grid == 0 and xstep_m < 0:
      xstep_m = -xstep_m
    end

    # Advance r by rstep_rad
    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[0, 0, 0, rstep_rad, 0, 0])
      movel(p1, a=robot_accel, v=robot_speed, r=robot_blend)
      # Track new grid square we're in
      if rstep_rad > 0:
        r_grid = r_grid + 1
      else:
        r_grid = r_grid - 1
      end
    end
    # Adjust r direction
    if r_grid >= r_grid_count-1 and rstep_rad > 0:
      rstep_rad = -rstep_rad
    elif r_grid == 0 and rstep_rad < 0:
      rstep_rad = -rstep_rad
    end

    # Detect when we've covered all the grid squares!
    # That's when you reach n-1,n-1 or 0,0
    if x_grid == x_grid_count - 1 and r_grid == r_grid_count - 1:
      grind_cycle = grind_cycle + 1
    elif r_grid == 0 and r_grid == 0:
      grind_cycle = grind_cycle + 1
    end
  end

  set_grinding_state(False)

  # Return robot back to initial position
  movel(p0, a=robot_accel, v=robot_speed)
  return True
end

# Grind along a flat circle diam dx_mm centered on current tool position. Repeat n_cycles times.
def grind_flat_circle(dx_mm, n_cycles):
  if n_cycles < 1:
    return True
  end

  # Unit conversion
  dx_m = dx_mm / 1000.0
  n_points = ceil(dx_mm * 1.0) # 10 points in a 10mm diam circle... linear n_points up and down from there
  radius_m = dx_m / 2          # Circle radius is half of specified dx

  # Find initial position p0
  set_tcp(p[0, 0, tool_length_m, 0, 0, 0])  #
  p0 = get_actual_tcp_pose()

  # Move to offset position east edge of circle
  p1 = pose_trans(get_forward_kin(), p[radius_m, 0, 0, 0, 0, 0])
  movel(p1, a=robot_accel, v=robot_speed)

  if not set_grinding_state(True):
    movel(p0, a=robot_accel, v=robot_speed)
    return False
  end

  # Grind circle pattern
  # We're in contact at east side... compute where contact position would be at center of circle
  p_center = pose_trans(get_forward_kin(), p[-radius_m, 0, 0, 0, 0, 0])
  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    i = 1
    while ok_to_proceed() and i <= n_points:
      theta = d2r(360.0 * i / n_points)
      x = radius_m * cos(theta)
      y = radius_m * sin(theta)

      p1 = pose_trans(p_center, p[x, y, 0, 0, 0, 0])
      movel(p1, a=robot_accel, v=robot_speed, r=robot_blend)
      i = i + 1
    end

    grind_cycle = grind_cycle + 1
  end

  set_grinding_state(False)

  # Return robot back to initial position
  movel(p0, a=robot_accel, v=robot_speed)
  return True
end

# Grind along a shperical circle diam dx_mm centered on current tool position. Repeat n_cycles times.
def grind_sphere_circle(dx_mm, sphere_radius_mm, n_cycles):
  if n_cycles < 1:
    return True
  end

  # Unit conversion
  dx_m = dx_mm / 1000.0
  n_points = ceil(dx_mm * 1.0) # 10 points in a 10mm diam circle... linear n_points up and down from there
  radius_m = dx_m / 2          # Circle radius is half of specified dx
  sphere_radius_m = sphere_radius_mm / 1000

  # Find initial position p0
  set_tcp(p[0, 0, tool_length_m + sphere_radius_m, 0, 0, 0])  #
  p0 = get_actual_tcp_pose()

  # Move to offset position east edge of circle
  p1 = pose_trans(get_forward_kin(), p[radius_m, 0, 0, 0, 0, 0])
  movel(p1, a=robot_accel, v=robot_speed)

  if not set_grinding_state(True):
    movel(p0, a=robot_accel, v=robot_speed)
    return False
  end

  # Grind circle pattern
  # We're in contact at east side... compute where contact position would be at center of circle
  p_center = pose_trans(get_forward_kin(), p[-radius_m, 0, 0, 0, 0, 0])
  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    i = 1
    while ok_to_proceed() and i <= n_points:
      theta = d2r(360.0 * i / n_points)
      x = radius_m * cos(theta)
      rx = x / sphere_radius_m
      y = radius_m * sin(theta)
      ry = y / sphere_radius_m

      p1 = pose_trans(p_center, p[0, 0, 0, rx, ry, 0])
      movel(p1, a=robot_accel, v=robot_speed, r=robot_blend)
      i = i + 1
    end

    grind_cycle = grind_cycle + 1
  end

  set_grinding_state(False)

  # Return robot back to initial position
  movel(p0, a=robot_accel, v=robot_speed)
  return True
end

# Grind along a flat spiral diam dx_mm to dx2_mm in n_spirals rotations centered on current tool position. Repeat n_cycles times.
def grind_flat_spiral(dx_mm, dx2_mm, n_spirals, n_cycles):
  if n_cycles < 1:
    return True
  end

  # Unit conversion
  dx_m = dx_mm / 1000.0
  dx2_m = dx2_mm / 1000.0
  n_points = ceil(dx_mm * 1.0) # 10 points in a 10mm diam circle... linear n_points up and down from there
  radius_m = dx_m / 2          # Circle radius is half of specified dx
  radius2_m = dx2_m / 2

  # Find initial position p0
  set_tcp(p[0, 0, tool_length_m, 0, 0, 0])  #
  p0 = get_actual_tcp_pose()

  # Move to offset position east edge of circle
  p1 = pose_trans(get_forward_kin(), p[radius_m, 0, 0, 0, 0, 0])
  movel(p1, a=robot_accel, v=robot_speed)

  if not set_grinding_state(True):
    movel(p0, a=robot_accel, v=robot_speed)
    return False
  end

  # Grind spiral pattern
  # We're in contact at east side... compute where contact position would be at center of circle
  p_center = pose_trans(get_forward_kin(), p[-radius_m, 0, 0, 0, 0, 0])
  n_total_points = n_spirals * n_points
  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    i = 0
    while ok_to_proceed() and i <= n_total_points:
      theta = d2r(360.0 * (i % n_points) / n_points)
      r_instantaneous = i * (radius2_m - radius_m) / n_total_points + radius_m
      x = r_instantaneous * cos(theta)
      y = r_instantaneous * sin(theta)

      p1 = pose_trans(p_center, p[x, y, 0, 0, 0, 0])
      movel(p1, a=robot_accel, v=robot_speed, r=robot_blend)
      i = i + 1
    end

    grind_cycle = grind_cycle + 1
    # Next cycle- swap diameters so we go in/out/in etc.
    old_radius_m = radius_m
    radius_m = radius2_m
    radius2_m = old_radius_m
  end

  set_grinding_state(False)

  # Return robot back to initial position
  movel(p0, a=robot_accel, v=robot_speed)
  return True
end

