# AutoGrind Grinding Functions
# File: agscript_grind.script
# Version 1.0
# Programmer: Ned Lecky

global listenerThread = 0
global threadCount = 0
global haltCount = 0
global haltCommand = [0, 0]

global tool_length_m = 0.100

# Abort system
thread listener_thread():
  global haltCommand = [0, 0]
  global haltCount = 0
  while (True):
    global threadCount = threadCount + 1
    global haltCommand = socket_read_ascii_float(1, timeout = 0.1)
    if haltCommand[0] > 0:
      global haltCount = haltCount + 1
    end
  end

  return False
end

def ok_to_proceed():
  return haltCount == 0
end

# Execute the desired pattern grind selected by command[2]
def pattern_grind():
  #global listen_thread
  if listenerThread > 0:
    kill listenerThread
    listenerThread = 0
  end
  listenerThread = run listener_thread()

  global grind_cycle = 0
  global grind_n_cycles = 0
  global grind_dx_mm = 0
  global grind_dy_mm = 0
  global grind_dz_mm = 0
  global grind_dr_mm = 0
  global grind_dp_mm = 0
  global grind_dy_mm = 0
  global grind_radius_mm = 0
  global grind_xstep_mm = 0
  global grind_ystep_mm = 0
  global grind_rstep_deg = 0

  if command[2] == 10:
    global response = "grind_flat_rect"
    global grind_dx_mm = command[3]
    global grind_dy_mm = command[4]
    global grind_n_cycles = command[5]
    grind_flat_rect(grind_dx_mm, grind_dy_mm, grind_n_cycles)
  elif command[2] == 20:
    global response = "grind_cyl_rect"
    global grind_dx_mm = command[3]
    global grind_dr_deg = command[4]
    global grind_radius_mm = command[5]
    global grind_n_cycles = command[6]
    grind_cyl_rect(grind_dx_mm, grind_dr_deg, grind_radius_mm, grind_n_cycles)
  elif command[2] == 30:
    global response = "grind_flat_serp"
    global grind_dx_mm = command[3]
    global grind_dy_mm = command[4]
    global grind_xstep_mm = command[5]
    global grind_ystep_mm = command[6]
    global grind_n_cycles = command[7]
    grind_flat_serp(grind_dx_mm, grind_dy_mm, grind_xstep_mm, grind_ystep_mm, grind_n_cycles)
  else:
    global response = "Unknown Grind Command"
  end

  kill listenerThread
  listenerThread = 0
end

# Grind along a flat rect dx_mm x dy_mm centered on current XY. Repeat n_cycles times.
# Move in x direction first, then y
def grind_flat_rect(dx_mm, dy_mm, n_cycles):
  if n_cycles < 1:
    return False
  end

  # Unit conversion
  dx_m = dx_mm / 1000.0
  dy_m = dy_mm / 1000.0

  # Find initial position p0
  set_tcp(p[0, 0, tool_length_m, 0, 0, 0])
  p0 = get_actual_tcp_pose()

  # Move to offset position bottom left of scan area
  p1 = pose_trans(get_forward_kin(), p[-dx_m / 2, -dy_m / 2, 0, 0, 0, 0])
  movel(p1, accel, speed)

  # Advance until contact
  # Simulated....
  p1 = pose_trans(get_forward_kin(), p[0, 0, 0.020, 0, 0, 0])
  movel(p1, accel, speed)

  # Turn on tool

  # Turn on force

  # Grind box pattern
  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[dx_m, 0, 0, 0, 0, 0])
      movel(p1, accel, speed)
    end

    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[0, dy_m, 0, 0, 0, 0])
      movel(p1, accel, speed)
    end

    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[-dx_m, 0, 0, 0, 0, 0])
      movel(p1, accel, speed)
    end

    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[0, -dy_m, 0, 0, 0, 0])
      movel(p1, accel, speed)
    end
    grind_cycle = grind_cycle + 1
  end

  # Turn off force

  # Lift tool in z
  p1 = pose_trans(get_forward_kin(), p[0, 0, -0.020, 0, 0, 0])
  movel(p1, accel, speed)

  # Turn off tool

  # Return robot back to initial position
  movel(p0, accel, speed)
  return True
end

# Grind along a cylindrical rect dx_mm,dr_deg with radius_mm centered on current XR. Repeat n_cycles times.
# Move in x direction first, then r
def grind_cyl_rect(dx_mm, dr_deg, radius_mm, n_cycles):
  if n_cycles < 1:
    return False
  end

  # Unit conversion
  dx_m = dx_mm / 1000.0
  radius_m = radius_mm / 1000.0
  dr_rad = d2r(dr_deg)

  # Find initial position p0 and compute target corners (x,r) 0 and 1
  set_tcp(p[0, 0, tool_length_m + radius_m, 0, 0, 0])
  p0 = get_actual_tcp_pose()

  # Move to offset position bottom left of scan area
  p1 = pose_trans(get_forward_kin(), p[-dx_m / 2, 0, 0, -dr_rad / 2, 0, 0])
  movel(p1, accel, speed)

  # Advance until contact
  # Simulated
  p1 = pose_trans(get_forward_kin(), p[0, 0, 0.020, 0, 0, 0])
  movel(p1, accel, speed)

  # Turn on tool

  # Turn on force

  # Grind cylindrical box pattern
  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[dx_m, 0, 0, 0, 0, 0])
      movel(p1, accel, speed)
    end

    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[0, 0, 0, dr_rad, 0, 0])
      movel(p1, accel, speed)
    end

    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[-dx_m, 0, 0, 0, 0, 0])
      movel(p1, accel, speed)
    end

    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[0, 0, 0, -dr_rad, 0, 0])
      movel(p1, accel, speed)
    end
    grind_cycle = grind_cycle + 1
  end

  # Turn off force

  # Lift tool in z
  p1 = pose_trans(get_forward_kin(), p[0, 0, -0.020, 0, 0, 0])
  movel(p1, accel, speed)

  # Turn off tool

  # Return robot back to initial position
  movel(p0, accel, speed)
  return True
end

# Grind along a flat serpentine dx_mm,dy_mm incrementing by xstep_mm,ystep_mm centered on current XY. Repeat n_cycles times.
# Move in x direction first, then y
def grind_flat_serp(dx_mm, dy_mm, xstep_mm, ystep_mm, n_cycles):
  if n_cycles < 1:
    return False
  end

  # Unit conversion
  dx_m = dx_mm / 1000.0
  dy_m = dy_mm / 1000.0
  xstep_m = xstep_mm / 1000.0
  ystep_m = ystep_mm / 1000.0
  x_grid_count = floor(dx_m / xstep_m)
  y_grid_count = floor(dy_m / ystep_m)

  # Find initial position
  set_tcp(p[0, 0, tool_length_m, 0, 0, 0])
  p0 = get_actual_tcp_pose()

  # Move to offset position bottom left of scan area
  p1 = pose_trans(get_forward_kin(), p[-dx_m / 2, -dy_m / 2, 0, 0, 0, 0])
  movel(p1, accel, speed)

  # Advance until contact
  # Simulated....
  p1 = pose_trans(get_forward_kin(), p[0, 0, 0.020, 0, 0, 0])
  movel(p1, accel, speed)

  # Turn on tool

  # Turn on force

  # Grind serpentine pattern
  global grind_cycle = 1
  x_grid = 0
  y_grid = 0
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    # Advance x by xstep_m
    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[xstep_m, 0, 0, 0, 0, 0])
      movel(p1, accel, speed)
      # Track new grid square we're in
      if xstep_m > 0:
        x_grid = x_grid + 1
      else:
        x_grid = x_grid - 1
      end
    end
    # Adjust x direction
    if x_grid >= x_grid_count-1 and xstep_m > 0:
      xstep_m = -xstep_m
    elif x_grid == 0 and xstep_m < 0:
      xstep_m = -xstep_m
    end

    # Advance y by ystep_m
    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[0, ystep_m, 0, 0, 0, 0])
      movel(p1, accel, speed)
      # Track new grid square we're in
      if ystep_m > 0:
        y_grid = y_grid + 1
      else:
        y_grid = y_grid - 1
      end
    end
    # Adjust y direction
    if y_grid >= y_grid_count-1 and ystep_m > 0:
      ystep_m = -ystep_m
    elif y_grid == 0 and ystep_m < 0:
      ystep_m = -ystep_m
    end

    # Detect when we've covered all the grid squares!
    # That's when you reach n-1,n-1 or 0,0
    if x_grid == x_grid_count - 1 and y_grid == y_grid_count - 1:
      grind_cycle = grind_cycle + 1
    elif x_grid == 0 and y_grid == 0:
      grind_cycle = grind_cycle + 1
    end
  end

  # Turn off force

  # Lift tool in z
  p1 = pose_trans(get_forward_kin(), p[0, 0, -0.020, 0, 0, 0])
  movel(p1, accel, speed)

  # Turn off tool

  # Return robot back to initial position
  movel(p0, accel, speed)
  return True
end


