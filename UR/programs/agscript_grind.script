# AutoGrind Grinding Functions
# File: agscript_grind.script
# Version 1.0
# Programmer: Ned Lecky

global listenerThread = 0
global threadCount = 0
global haltCount = 0
global haltCommand = [0, 0]

global grind_ready = True
# grind_contact_enable:  0=No Contact   1=Touch but no tool/coolant on or force  2=Touch, Tool, Coolant, and Force
global grind_contact_enable = 0
global grind_touch_retract_mm = 3

MATH_PI = 3.1415926535

# Execute the desired pattern grind selected by command[2]...
def pattern_grind():
  global grind_ready = False
  socket_send_line("grind_ready=False")

  if listenerThread > 0:
    kill listenerThread
    listenerThread = 0
  end
  listenerThread = run listener_thread()

  global grind_cycle = 0
  socket_set_var("grind_cycle", grind_cycle)
  global grind_n_cycles = 0
  global grind_dx_mm = 0
  global grind_dy_mm = 0
  global grind_circle1_diam_mm = 0
  global grind_circle2_diam_mm = 0
  global grind_n_spirals = 0
  global grind_xstep_mm = 0
  global grind_ystep_mm = 0
  global grind_accel = 1
  global grind_blend = 3

  # Install tcp that puts tcp at center of part (noop for flat parts!)
  set_tcp(robot_tcp_part)

  if command[2] == 1:
    global response = "set grind_contact_enable"
    if command[3] >= 0 and command[3] <= 2:
      global grind_contact_enable = command[3]
    end
    socket_set_var("grind_contact_enable", grind_contact_enable)
  elif command[2] == 2:
    global response = "set grind_touch_retract_mm"
    if command[3] >= 0:
      global grind_touch_retract_mm = command[3]
    end
    socket_set_var("grind_touch_retract_mm", grind_touch_retract_mm)
    # LINEAR GRINDS
  elif command[2] == 10:
    global response = "grind_line"
    global grind_dx_mm = command[3]
    global grind_dy_mm = command[4]
    global grind_n_cycles = command[5]
    socket_set_var("grind_n_cycles", grind_n_cycles)
    global grind_speed = command[6] / 1000.0
    global grind_force = command[7]
    # These may get calculated later!
    global grind_accel = robot_linear_accel_mpss
    global grind_blend = robot_blend_radius_m
    grind_line(grind_dx_mm, grind_dy_mm, grind_n_cycles)

    # RECTANGULAR GRINDS
  elif command[2] == 20:
    global response = "grind_rect"
    global grind_dx_mm = command[3]
    global grind_dy_mm = command[4]
    global grind_n_cycles = command[5]
    socket_set_var("grind_n_cycles", grind_n_cycles)
    global grind_speed = command[6] / 1000.0
    global grind_force = command[7]
    # These may get calculated later!
    global grind_accel = robot_linear_accel_mpss
    global grind_blend = robot_blend_radius_m
    grind_rect(grind_dx_mm, grind_dy_mm, grind_n_cycles)

    # SERPENTINE GRINDS
  elif command[2] == 30:
    global response = "grind_serpentine"
    global grind_dx_mm = command[3]
    global grind_dy_mm = command[4]
    global grind_n_xsteps = limiter(command[5], 1, 10)
    global grind_n_ysteps = limiter(command[6], 1, 10)
    global grind_n_cycles = command[7]
    socket_set_var("grind_n_cycles", grind_n_cycles)
    global grind_speed = command[8] / 1000.0
    global grind_force = command[9]
    # These may get calculated later!
    global grind_accel = robot_linear_accel_mpss
    global grind_blend = robot_blend_radius_m
    grind_serpentine(grind_dx_mm, grind_dy_mm, grind_n_xsteps, grind_n_ysteps, grind_n_cycles)

    # CIRCULAR GRINDS
  elif command[2] == 40:
    global response = "grind_circle"
    global grind_circle1_diam_mm = command[3]
    global grind_n_cycles = command[4]
    socket_set_var("grind_n_cycles", grind_n_cycles)
    global grind_speed = command[5] / 1000.0
    global grind_force = command[6]
    # These may get calculated later!
    global grind_accel = robot_linear_accel_mpss
    global grind_blend = robot_blend_radius_m
    grind_circle(grind_circle1_diam_mm, grind_n_cycles)

    # SPIRAL GRINDS
  elif command[2] == 50:
    global response = "grind_spiral"
    global grind_circle1_diam_mm = command[3]
    global grind_circle2_diam_mm = command[4]
    global grind_n_spirals = command[5]
    global grind_n_cycles = command[6]
    global grind_speed = command[7] / 1000.0
    global grind_force = command[8]
    # These may get calculated later!
    global grind_accel = robot_linear_accel_mpss
    global grind_blend = robot_blend_radius_m
    grind_spiral(grind_circle1_diam_mm, grind_circle2_diam_mm, grind_n_spirals, grind_n_cycles)
  else:
    global response = "Unknown grind command"
  end

  # Restore tool-only tcp
  set_tcp(robot_tcp)

  kill listenerThread
  listenerThread = 0

  global grind_ready = True
  socket_send_line("grind_ready=True")
end

# Get into contact with part (or away from)
# enable:  0=No Contact   1=Touch but no tool/coolant on or force  2=Touch, Tool, Coolant, and Force
def contact_part(on = False, enable = 0):
  if on:
    if enable == 0:
      # Just do a small forward motion in the direction of touchoff
      p1 = pose_trans(get_forward_kin(), p[0, 0, 0.005, 0, 0, 0])
      movel(p1, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
    elif enable == 1:
      # Advance until contact but retract 2X grind distance
      return touchoff(grind_touch_retract_mm * 2.0)
    elif enable == 2:
      # Advance until contact
      return touchoff(grind_touch_retract_mm)
    end
  else:  # Contact off
    p1 = pose_trans(get_forward_kin(), p[0, 0, -0.010, 0, 0, 0])
    movel(p1, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
  end

  return True
end

# enable:  0=No Contact   1=Touch but no tool/coolant on or force  2=Touch, Tool, Coolant, and Force
def tool_power(on = False, enable = 0):
  if enable < 2:
    return None
  end

  if on:
    # ON IO
  else:
    # OFF IO
  end

  return None
end

# enable:  0=No Contact   1=Touch but no tool/coolant on or force  2=Touch, Tool, Coolant, and Force
def coolant_flow(on = False, enable = 0):
  if enable < 2:
    return None
  end

  if on:
    # ON IO
  else:
    # OFF IO
  end

  return None
end

# enable:  0=No Contact   1=Touch but no tool/coolant on or force  2=Touch, Tool, Coolant, and Force
def apply_force(on = False, enable = 0):
  if enable < 2:
    return None
  end

  if on:
    sleep(0.02)
    zero_ftsensor()
    # TODO All params correct??
    force_mode(tool_pose(), [0, 0, 1, 0, 0, 0], [0.0, 0.0, grind_force, 0.0, 0.0, 0.0], 2, [0.1, 0.1, 0.15, 0.3490658503988659, 0.3490658503988659, 0.3490658503988659])
  else:
    end_force_mode()
  end

  return None
end

# Setup for grinding
global grinding_state = False
def set_grinding_state(on = False):
  if on and not grinding_state:
    if not contact_part(True, grind_contact_enable):
      return False
    end
    tool_power(True, grind_contact_enable)
    coolant_flow(True, grind_contact_enable)
    apply_force(True, grind_contact_enable)
    grinding_state = True
    return True
  elif not on and grinding_state:
    apply_force(False, grind_contact_enable)
    contact_part(False, grind_contact_enable)
    coolant_flow(False, grind_contact_enable)
    tool_power(False, grind_contact_enable)
    grinding_state = False
    return True
  end
  return True
end

# Interruptible Movel
global movel_int_p = p[0, 0, 0, 0, 0, 0]
global movel_int_a = 1.2
global movel_int_v = 0.25
global movel_int_t = 0
global movel_int_r = 0
global movel_int_in_process = False
global movelThread = 0

thread movel_int_thread():
  movel_int_in_process = True
  movel(movel_int_p, movel_int_a, movel_int_v, movel_int_t, movel_int_r)
  movel_int_in_process = False
end

def movel_int(p, a = 1.2, v = 0.25, t = 0, r = 0):
  global movel_int_in_process = True
  if movelThread > 0:
    kill movelThread
    movelThread = 0
  end
  global movel_int_p = p
  global movel_int_a = a
  global movel_int_v = v
  global movel_int_t = t
  global movel_int_r = r
  global movel_int_in_process = True
  movelThread = run movel_int_thread()
  while movel_int_in_process and ok_to_proceed():
    sleep(0.01)
  end
  if movelThread > 0:
    kill movelThread
    movelThread = 0
  end
end

# Listens while grinding
thread listener_thread():
  global haltCommand = [0, 0]
  global haltCount = 0
  while (True):
    global threadCount = threadCount + 1
    global haltCommand = socket_read_ascii_float(1, timeout = 0.1)
    if haltCommand[0] > 0 or not is_door_closed():
      global haltCount = haltCount + 1
    end
  end

  return False
end

def ok_to_proceed():
  return haltCount == 0
end

# Grind along a line dx_mm x dy_mm centered on current tool position. Repeat n_cycles times.
def grind_line(dx_mm, dy_mm, n_cycles):
  if n_cycles < 1:
    return True
  end

  # shape OK?
  shape = robot_part_geometry[0]
  if shape < 1 or shape > 3:
    return False
  end

  # Unit conversion
  dx_m = dx_mm / 1000.0
  dy_m = dy_mm / 1000.0

  # Find initial position p0
  p0 = get_actual_tcp_pose()

  # Move to start position
  if shape == 1:
    p1 = pose_trans(p0, p[-dx_m / 2, -dy_m / 2, 0, 0, 0, 0])
  elif shape == 2:
    radius_m = robot_part_geometry[1] / 2.0
    drx_rad = dy_m / radius_m
    p1 = pose_trans(p0, p[-dx_m / 2, 0, 0, -drx_rad / 2, 0, 0])
  elif shape == 3:
    radius_m = robot_part_geometry[1] / 2.0
    drx_rad = dy_m / radius_m
    dry_rad = dy_m / radius_m
    p1 = pose_trans(p0, p[0, 0, 0, -drx_rad / 2, -dry_rad / 2, 0])
  end
  movel(p1, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)

  if not set_grinding_state(True):
    movel(p0, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
    return False
  end

  # Grind the pattern
  if shape == 1:
    pattern_line_flat(dx_m, dy_m, n_cycles)
  elif shape == 2:
    pattern_line_cylinder(dx_m, drx_rad, n_cycles)
  elif shape == 3:
    pattern_line_sphere(drx_rad, dry_rad, n_cycles)
  end

  set_grinding_state(False)

  # Return robot back to initial position
  movel(p0, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
end

# Move along a flat line dx_m x dy_m starting at current position. Repeat n_cycles times.
# Move in x direction first, then y
def pattern_line_flat(dx_m, dy_m, n_cycles):
  # We're in contact at sw side...
  p0 = get_actual_tcp_pose()
  p1 = pose_trans(p0, p[dx_m, dy_m, 0, 0, 0, 0])
  pdest = p1

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    if ok_to_proceed():
      movel_int(pdest, a = grind_accel, v = grind_speed, r = grind_blend)
    end

    # Alternate directions for multiple cycles
    if pdest == p0:
      pdest = p1
    else:
      pdest = p0
    end

    grind_cycle = grind_cycle + 1
  end
end

# Move along a cylindrical line dx_mm,drx_rad starting at current position. Repeat n_cycles times.
# Move in x direction first, then rx
def pattern_line_cylinder(dx_m, drx_rad, n_cycles):
  # We're in contact at sw side...
  p0 = get_actual_tcp_pose()
  p1 = pose_trans(p0, p[dx_m, 0, 0, drx_rad, 0, 0])
  pdest = p1

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    if ok_to_proceed():
      # TODO What should the speed adjustment be here? Pure rotation seems to need a 2*PI
      movel(pdest, a = grind_accel, v = grind_speed * 2.0 * MATH_PI, r = grind_blend)
    end

    # Alternate directions for multiple cycles
    if pdest == p0:
      pdest = p1
    else:
      pdest = p0
    end

    grind_cycle = grind_cycle + 1
  end
end

# Move along a spherical line drx_rad,dry_rad starting at current tool position. Repeat n_cycles times.
# Move in rx direction first, then ry
def pattern_line_sphere(drx_rad, dry_rad, n_cycles):
  # We're in contact at sw side...
  p0 = get_actual_tcp_pose()
  p1 = pose_trans(p0, p[0, 0, 0, drx_rad, dry_rad, 0])
  pdest = p1

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    if ok_to_proceed():
      # TODO What should the speed adjustment be here? Pure rotation seems to need a 2*PI
      movel(pdest, a = grind_accel, v = grind_speed * 2.0 * MATH_PI, r = grind_blend)
    end
    # Alternate directions for multiple cycles
    if pdest == p0:
      pdest = p1
    else:
      pdest = p0
    end

    grind_cycle = grind_cycle + 1
  end
end

# Grind along a rect dx_mm x dy_mm centered on current tool position. Repeat n_cycles times.
# Move in x direction first, then y
def grind_rect(dx_mm, dy_mm, n_cycles):
  if n_cycles < 1:
    return True
  end

  # shape OK?
  shape = robot_part_geometry[0]
  if shape < 1 or shape > 3:
    return False
  end

  # Unit conversion
  dx_m = dx_mm / 1000.0
  dy_m = dy_mm / 1000.0

  # Find initial position p0
  p0 = get_actual_tcp_pose()

  # Move to start position
  if shape == 1:
    p1 = pose_trans(p0, p[-dx_m / 2, -dy_m / 2, 0, 0, 0, 0])
  elif shape == 2:
    radius_m = robot_part_geometry[1] / 2.0
    drx_rad = dy_m / radius_m
    p1 = pose_trans(p0, p[-dx_m / 2, 0, 0, -drx_rad / 2, 0, 0])
  elif shape == 3:
    radius_m = robot_part_geometry[1] / 2.0
    drx_rad = dy_m / radius_m
    dry_rad = dy_m / radius_m
    p1 = pose_trans(p0, p[0, 0, 0, -drx_rad / 2, -dry_rad / 2, 0])
  end
  movel(p1, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)

  if not set_grinding_state(True):
    movel(p0, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
    return False
  end

  # Grind the pattern
  if shape == 1:
    pattern_rect_flat(dx_m, dy_m, n_cycles)
  elif shape == 2:
    pattern_rect_cylinder(dx_m, drx_rad, n_cycles)
  elif shape == 3:
    pattern_rect_sphere(drx_rad, dry_rad, n_cycles)
  end

  set_grinding_state(False)

  # Return robot back to initial position
  movel(p0, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
end

# Move along a flat rect dx_m x dy_m starting at current position. Repeat n_cycles times.
# Move in x direction first, then y
def pattern_rect_flat(dx_m, dy_m, n_cycles):
  # We're in contact at sw side...
  p0 = get_actual_tcp_pose()

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    if ok_to_proceed():
      p1 = pose_trans(p0, p[dx_m, 0, 0, 0, 0, 0])
      movel(p1, a = grind_accel, v = grind_speed, r = grind_blend)
    end

    if ok_to_proceed():
      p1 = pose_trans(p0, p[dx_m, dy_m, 0, 0, 0, 0])
      movel(p1, a = grind_accel, v = grind_speed, r = grind_blend)
    end

    if ok_to_proceed():
      p1 = pose_trans(p0, p[0, dy_m, 0, 0, 0, 0])
      movel(p1, a = grind_accel, v = grind_speed, r = grind_blend)
    end

    if ok_to_proceed():
      movel(p0, a = grind_accel, v = grind_speed, r = grind_blend)
    end
    grind_cycle = grind_cycle + 1
  end
end

# Move along a cylindrical rect dx_mm,drx_rad starting at current position. Repeat n_cycles times.
# Move in x direction first, then rx
def pattern_rect_cylinder(dx_m, drx_rad, n_cycles):
  # We're in contact at sw side...
  p0 = get_actual_tcp_pose()

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    if ok_to_proceed():
      p1 = pose_trans(p0, p[dx_m, 0, 0, 0, 0, 0])
      movel(p1, a = grind_accel, v = grind_speed, r = grind_blend)
    end

    if ok_to_proceed():
      p1 = pose_trans(p0, p[dx_m, 0, 0, drx_rad, 0, 0])
      movel(p1, a = grind_accel, v = grind_speed * 2.0 * MATH_PI, r = grind_blend)
    end

    if ok_to_proceed():
      p1 = pose_trans(p0, p[0, 0, 0, drx_rad, 0, 0])
      movel(p1, a = grind_accel, v = grind_speed, r = grind_blend)
    end

    if ok_to_proceed():
      movel(p0, a = grind_accel, v = grind_speed * 2.0 * MATH_PI, r = grind_blend)
    end
    grind_cycle = grind_cycle + 1
  end
end

# Move along a sperical rect drx_rad,dry_rad starting at current tool position. Repeat n_cycles times.
# Move in rx direction first, then ry
def pattern_rect_sphere(drx_rad, dry_rad, n_cycles):
  # We're in contact at sw side...
  p0 = get_actual_tcp_pose()

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    if ok_to_proceed():
      p1 = pose_trans(p0, p[0, 0, 0, drx_rad, 0, 0])
      movel(p1, a = grind_accel, v = grind_speed * 2.0 * MATH_PI, r = grind_blend)
    end

    if ok_to_proceed():
      p1 = pose_trans(p0, p[0, 0, 0, drx_rad, dry_rad, 0])
      movel(p1, a = grind_accel, v = grind_speed * 2.0 * MATH_PI, r = grind_blend)
    end

    if ok_to_proceed():
      p1 = pose_trans(p0, p[0, 0, 0, 0, dry_rad, 0])
      movel(p1, a = grind_accel, v = grind_speed * 2.0 * MATH_PI, r = grind_blend)
    end

    if ok_to_proceed():
      movel(p0, a = grind_accel, v = grind_speed * 2.0 * MATH_PI, r = grind_blend)
    end
    grind_cycle = grind_cycle + 1
  end
end

# Grind along a rect in serpentine dx_mm,dy_mm incrementing by xstep_mm,ystep_mm centered on current tool position. Repeat n_cycles times.
# Move in x direction first, then y
def grind_serpentine(dx_mm, dy_mm, n_xsteps, n_ysteps, n_cycles):
  if n_cycles < 1:
    return True
  end

  # shape OK?
  shape = robot_part_geometry[0]
  if shape < 1 or shape > 3:
    return False
  end

  # Either n_xsteps or n_ysteps must be 1. Whichever one is one will be the direction of the first move.
  if n_xsteps != 1 and n_ysteps != 1:
    return False
  end

  # Unit conversion
  dx_m = dx_mm / 1000.0
  dy_m = dy_mm / 1000.0

  # Find initial position p0
  p0 = get_actual_tcp_pose()

  # Move to start position
  if shape == 1:
    p1 = pose_trans(p0, p[-dx_m / 2, -dy_m / 2, 0, 0, 0, 0])
  elif shape == 2:
    part_radius_m = robot_part_geometry[1] / 2.0
    drx_rad = dy_m / part_radius_m
    p1 = pose_trans(p0, p[-dx_m / 2, 0, 0, -drx_rad / 2, 0, 0])
  elif shape == 3:
    part_radius_m = robot_part_geometry[1] / 2.0
    drx_rad = dx_m / part_radius_m
    dry_rad = dy_m / part_radius_m
    p1 = pose_trans(p0, p[0, 0, 0, -drx_rad / 2, -dry_rad / 2, 0])
  end
  movel(p1, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)

  if not set_grinding_state(True):
    movel(p0, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
    return False
  end

  # Grind the pattern
  if shape == 1:
    pattern_serpentine_flat(dx_m, dy_m, n_xsteps, n_ysteps, n_cycles)
  elif shape == 2:
    pattern_serpentine_cylinder(dx_m, drx_rad, n_xsteps, n_ysteps, n_cycles)
  elif shape == 3:
    pattern_serpentine_sphere(drx_rad, dry_rad, n_xsteps, n_ysteps, n_cycles)
  end

  set_grinding_state(False)

  # Return robot back to initial position
  movel(p0, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
end

# Move along a flat serpentine dx_m,dy_m in n_xsteps,n_ysteps starting at current tool position. Repeat n_cycles times.
# Move in direction of whichever nsteps is 1 first
def pattern_serpentine_flat(dx_m, dy_m, n_xsteps, n_ysteps, n_cycles):
  # We're in contact at sw side...
  p0 = get_actual_tcp_pose()

  # Track our grid square number... we're in [0,0] and moving [+1,+1] in either x or y
  x_grid = 0
  y_grid = 0
  x_incr = 1
  y_incr = 1
  grid_dx_m = dx_m / n_xsteps
  grid_dy_m = dy_m / n_ysteps

  # How many moves does it take to complete a pass?
  global n_moves_per_pass = (n_xsteps + n_ysteps) * 2 - 1

  move_count = 0
  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    # Skip first X move if we should start with a y move
    if grind_cycle != 1 or move_count != 0 or n_xsteps == 1:
      # Advance x_grid by x_incr
      x_grid = x_grid + x_incr

      # Move to the corresponding position
      p1 = pose_trans(p0, p[x_grid * grid_dx_m, y_grid * grid_dy_m, 0, 0, 0, 0])
      movel(p1, a = grind_accel, v = grind_speed, r = grind_blend)

      # Adjust x direction
      if x_grid >= n_xsteps:
        x_incr = -1
      elif x_grid <= 0:
        x_incr = 1
      end
      move_count = move_count + 1
    end

    if ok_to_proceed() and move_count < n_moves_per_pass:
      # Advance y_grid by y_incr
      y_grid = y_grid + y_incr

      # Move to the corresponding position
      p1 = pose_trans(p0, p[x_grid * grid_dx_m, y_grid * grid_dy_m, 0, 0, 0, 0])
      movel(p1, a = grind_accel, v = grind_speed, r = grind_blend)

      # Adjust y direction
      if y_grid >= n_ysteps:
        y_incr = -1
      elif y_grid <= 0:
        y_incr = 1
      end
      move_count = move_count + 1
    end

    # Detect when we've covered all the grid squares!
    if move_count >= n_moves_per_pass:
      grind_cycle = grind_cycle + 1
      move_count = 0
    end
  end
end

# Move along a cylindrical serpentine dx_m,drx_rad in n_xsteps,n_rxsteps starting at current tool position. Repeat n_cycles times.
# Move in direction of whichever nsteps is 1 first
def pattern_serpentine_cylinder(dx_m, drx_rad, n_xsteps, n_rxsteps, n_cycles):
  # We're in contact at sw side...
  p0 = get_actual_tcp_pose()

  # Track our grid square number... we're in [0,0] and moving [+1,+1] in either x or y
  x_grid = 0
  y_grid = 0
  x_incr = 1
  y_incr = 1
  grid_dx_m = dx_m / n_xsteps
  grid_drx_rad = drx_rad / n_rxsteps

  # How many moves does it take to complete a pass?
  global n_moves_per_pass = (n_xsteps + n_rxsteps) * 2 - 1

  move_count = 0
  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    # Skip first X move if we should start with a y move
    if grind_cycle != 1 or move_count != 0 or n_xsteps == 1:
      # Advance x_grid by x_incr
      x_grid = x_grid + x_incr

      # Move to the corresponding position
      p1 = pose_trans(p0, p[x_grid * grid_dx_m, 0, 0, y_grid * grid_drx_rad, 0, 0])
      movel(p1, a = grind_accel, v = grind_speed, r = grind_blend)

      # Adjust x direction
      if x_grid >= n_xsteps:
        x_incr = -1
      elif x_grid <= 0:
        x_incr = 1
      end
      move_count = move_count + 1
    end

    if ok_to_proceed() and move_count < n_moves_per_pass:
      # Advance y_grid by y_incr
      y_grid = y_grid + y_incr

      # Move to the corresponding position
      p1 = pose_trans(p0, p[x_grid * grid_dx_m, 0, 0, y_grid * grid_drx_rad, 0, 0])
      # TODO Is this 2PI speed factor necessary
      movel(p1, a = grind_accel, v = grind_speed * 2.0 * MATH_PI, r = grind_blend)

      # Adjust y direction
      if y_grid >= n_rxsteps:
        y_incr = -1
      elif y_grid <= 0:
        y_incr = 1
      end
      move_count = move_count + 1
    end

    # Detect when we've covered all the grid squares!
    if move_count >= n_moves_per_pass:
      grind_cycle = grind_cycle + 1
      move_count = 0
    end
  end
end

# Move along a sperical serpentine drx_rad,dry_rad in n_rxsteps,n_rysteps starting at current tool position. Repeat n_cycles times.
# Move in direction of whichever nsteps is 1 first
def pattern_serpentine_sphere(drx_rad, dry_rad, n_rxsteps, n_rysteps, n_cycles):
  # We're in contact at sw side...
  p0 = get_actual_tcp_pose()

  # Track our grid square number... we're in [0,0] and moving [+1,+1] in either x or y
  x_grid = 0
  y_grid = 0
  x_incr = 1
  y_incr = 1
  grid_drx_rad = drx_rad / n_rxsteps
  grid_dry_rad = dry_rad / n_rysteps

  # How many moves does it take to complete a pass?
  global n_moves_per_pass = (n_rxsteps + n_rysteps) * 2 - 1

  move_count = 0
  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    # Skip first X move if we should start with a y move
    if grind_cycle != 1 or move_count != 0 or n_rxsteps == 1:
      # Advance x_grid by x_incr
      x_grid = x_grid + x_incr

      # Move to the corresponding position
      p1 = pose_trans(p0, p[0, 0, 0, x_grid * grid_drx_rad, y_grid * grid_dry_rad, 0])
      # TODO Is this 2PI speed factor necessary
      movel(p1, a = grind_accel, v = grind_speed * 2.0 * MATH_PI, r = grind_blend)

      # Adjust x direction
      if x_grid >= n_rxsteps:
        x_incr = -1
      elif x_grid <= 0:
        x_incr = 1
      end
      move_count = move_count + 1
    end

    if ok_to_proceed() and move_count < n_moves_per_pass:
      # Advance y_grid by y_incr
      y_grid = y_grid + y_incr

      # Move to the corresponding position
      p1 = pose_trans(p0, p[0, 0, 0, x_grid * grid_drx_rad, y_grid * grid_dry_rad, 0])
      # TODO Is this 2PI speed factor necessary
      movel(p1, a = grind_accel, v = grind_speed * 2.0 * MATH_PI, r = grind_blend)

      # Adjust y direction
      if y_grid >= n_rysteps:
        y_incr = -1
      elif y_grid <= 0:
        y_incr = 1
      end
      move_count = move_count + 1
    end

    # Detect when we've covered all the grid squares!
    if move_count >= n_moves_per_pass:
      grind_cycle = grind_cycle + 1
      move_count = 0
    end
  end
end

# Grind along a circle with circle_diam_mm centered on current tool position. Repeat n_cycles times.
def grind_circle(circle_diam_mm, n_cycles):
  if n_cycles < 1:
    return True
  end

  # shape OK?
  shape = robot_part_geometry[0]
  if shape < 1 or shape > 3:
    return False
  end

  # Unit conversion
  circle_diam_m = circle_diam_mm / 1000.0

  # Find initial position p0
  p0 = get_actual_tcp_pose()

  # Move to start position
  if shape == 1:
    p1 = pose_trans(p0, p[circle_diam_m / 2.0, 0, 0, 0, 0, 0])
  elif shape == 2:
    part_diam_m = robot_part_geometry[1]
    p1 = pose_trans(p0, p[circle_diam_m / 2.0, 0, 0, 0, 0, 0])
  elif shape == 3:
    part_diam_m = robot_part_geometry[1]
    p1 = pose_trans(p0, p[0, 0, 0, circle_diam_m / part_diam_m, 0, 0])
  end
  movel(p1, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)

  if not set_grinding_state(True):
    movel(p0, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
    return False
  end

  # Grind the pattern
  if shape == 1:
    pattern_circle_flat(circle_diam_m, n_cycles)
  elif shape == 2:
    pattern_circle_cylinder(circle_diam_m, part_diam_m, n_cycles)
  elif shape == 3:
    pattern_circle_sphere(circle_diam_m, part_diam_m, n_cycles)
  end

  set_grinding_state(False)

  # Return robot back to initial position
  movel(p0, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
end

# Grind along a flat circle circle_diam_m starting at current tool position. Repeat n_cycles times.
def pattern_circle_flat(circle_diam_m, n_cycles):

  # Unit conversion
  n_points = ceil(circle_diam_m * 1000.0)   # 10 points in a 10mm diam circle... linear n_points up and down from there
  circle_radius_m = circle_diam_m / 2.0     # Circle radius is half of specified dx

  # We're in contact at east side... compute where contact position would be at center of circle
  p_center = pose_trans(get_forward_kin(), p[-circle_radius_m, 0, 0, 0, 0, 0])

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    i = 1
    while ok_to_proceed() and i <= n_points:
      theta = d2r(360.0 * i / n_points)
      x = circle_radius_m * cos(theta)
      y = circle_radius_m * sin(theta)

      p1 = pose_trans(p_center, p[x, y, 0, 0, 0, 0])
      movel(p1, a = grind_accel, v = grind_speed, r = grind_blend)
      i = i + 1
    end

    grind_cycle = grind_cycle + 1
  end
end

# Move along a cylindrical circle circle_diam_m on a cylinder_diam_m object starting at the current tool position. Repeat n_cycles times.
def pattern_circle_cylinder(circle_diam_m, cylinder_radius_m, n_cycles):
  # Unit conversion
  n_points = ceil(circle_diam_m * 1000.0)   # 10 points in a 10mm diam circle... linear n_points up and down from there
  circle_radius_m = circle_diam_m / 2.0

  # We're in contact at east side... compute where contact position would be at center of circle
  p_center = pose_trans(get_forward_kin(), p[-circle_radius_m, 0, 0, 0, 0, 0])

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    i = 1
    while ok_to_proceed() and i <= n_points:
      theta = d2r(360.0 * i / n_points)
      x = circle_radius_m * cos(theta)
      y = circle_radius_m * sin(theta)
      rx = y / cylinder_radius_m

      p1 = pose_trans(p_center, p[x, 0, 0, rx, 0, 0])
      movel(p1, a = grind_accel, v = grind_speed * 2.0 * MATH_PI, r = grind_blend)
      i = i + 1
    end

    grind_cycle = grind_cycle + 1
  end
end

# Move along a spherical circle circle_diam_m on a sphere_diam_m object starting at the current tool position. Repeat n_cycles times.
def pattern_circle_sphere(circle_diam_m, sphere_diam_m, n_cycles):
  # Unit conversion
  n_points = ceil(circle_diam_m * 1000.0)   # 10 points in a 10mm diam circle... linear n_points up and down from there
  circle_radius_m = circle_diam_m / 2.0
  sphere_radius_m = sphere_diam_m / 2.0

  # We're in contact at east side... compute where contact position would be at center of circle
  p_center = pose_trans(get_forward_kin(), p[0, 0, 0, -circle_diam_m / sphere_diam_m, 0, 0])
  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    i = 1
    while ok_to_proceed() and i <= n_points:
      theta = d2r(360.0 * i / n_points)
      x = circle_radius_m * cos(theta)
      rx = x / sphere_radius_m
      y = circle_radius_m * sin(theta)
      ry = y / sphere_radius_m

      p1 = pose_trans(p_center, p[0, 0, 0, rx, ry, 0])
      movel(p1, a = grind_accel, v = grind_speed * 2.0 * MATH_PI, r = grind_blend)
      i = i + 1
    end

    grind_cycle = grind_cycle + 1
  end
end

# Grind along a spiral circle1_diam_mm to circle2_diam_mm in n_spirals with rotations centered on current tool position. Repeat n_cycles times.
def grind_spiral(circle1_diam_mm, circle2_diam_mm, n_spirals, n_cycles):
  if n_cycles < 1:
    return True
  end

  # shape OK?
  shape = robot_part_geometry[0]
  if shape < 1 or shape > 3:
    return False
  end

  # Unit conversion
  circle1_diam_m = circle1_diam_mm / 1000.0
  circle2_diam_m = circle2_diam_mm / 1000.0

  # Find initial position p0
  p0 = get_actual_tcp_pose()

  # Move to start position
  if shape == 1:
    p1 = pose_trans(p0, p[circle1_diam_m / 2.0, 0, 0, 0, 0, 0])
  elif shape == 2:
    part_diam_m = robot_part_geometry[1]
    p1 = pose_trans(p0, p[circle1_diam_m / 2.0, 0, 0, 0, 0, 0])
  elif shape == 3:
    part_diam_m = robot_part_geometry[1]
    p1 = pose_trans(p0, p[0, 0, 0, circle1_diam_m / part_diam_m / 2.0, 0, 0])
  end
  movel(p1, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)

  if not set_grinding_state(True):
    movel(p0, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
    return False
  end

  # Grind the pattern
  if shape == 1:
    pattern_spiral_flat(circle1_diam_m, circle2_diam_m, n_spirals, n_cycles)
  elif shape == 2:
    #pattern_circle_cylinder(circle1_diam_m, circle2_diam_m, n_spirals, part_diam_m, n_cycles) # NOT IMPLEMENTED
  elif shape == 3:
    #pattern_circle_sphere(circle1_diam_m, circle2_diam_m, n_spirals, part_diam_m, n_cycles) # NOT IMPLEMENTED
  end

  set_grinding_state(False)

  # Return robot back to initial position
  movel(p0, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
  return True
end

def pattern_spiral_flat(circle1_diam_m, circle2_diam_m, n_spirals, n_cycles):
  # Unit conversion
  circle1_radius_m = circle1_diam_m / 2.0
  circle2_radius_m = circle2_diam_m / 2.0

  max_diam_m = circle1_radius_m
  if circle2_diam_m > max_diam_m:
    max_diam_m = circle2_radius_m
  end
  n_points = ceil(max_diam_m * 1000.0) # 10 points in a 10mm diam circle... linear n_points up and down from there
  n_total_points = n_spirals * n_points

  # We're in contact at east side... compute where contact position would be at center of circle
  p_center = pose_trans(get_forward_kin(), p[-circle1_diam_m / 2.0, 0, 0, 0, 0, 0])

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    rslope = (circle2_radius_m - circle1_radius_m) / n_total_points
    i = 0
    while ok_to_proceed() and i <= n_total_points:
      theta = d2r(360.0 * (i % n_points) / n_points)
      r_instantaneous = i * rslope + circle1_radius_m
      x = r_instantaneous * cos(theta)
      y = r_instantaneous * sin(theta)

      p1 = pose_trans(p_center, p[x, y, 0, 0, 0, 0])
      movel(p1, a = grind_accel, v = grind_speed, r = grind_blend)
      i = i + 1
    end

    grind_cycle = grind_cycle + 1
    # Next cycle- swap diameters so we go in/out/in etc.
    old_circle1_radius_m = circle1_radius_m
    circle1_radius_m = circle2_radius_m
    circle2_radius_m = old_circle1_radius_m
  end
end

