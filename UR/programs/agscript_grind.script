# AutoGrind Grinding Functions
# File: agscript_grind.script
# Version 1.0
# Programmer: Ned Lecky

global listenerThread = 0
global threadCount = 0
global haltCount = 0
global haltCommand = [0, 0]

# TODO this should come from the TCP selected for the current tool
global tool_length_m = 0.175

global grind_ready = True
global grind_contact_enabled = False
global grind_simulated = False

# Get into contact with part (or away from)
def contact_part(on = False, enabled = False):
  if on:
    if enabled:
      # Advance until contact
      return touchoff()
    else:
      # Simulated....
      p1 = pose_trans(get_forward_kin(), p[0, 0, 0.010, 0, 0, 0])
      movel(p1, robot_accel, robot_speed)
    end
  else:
    p1 = pose_trans(get_forward_kin(), p[0, 0, -0.010, 0, 0, 0])
    movel(p1, robot_accel, robot_speed)
  end

  return True
end

def tool_power(on = False, enabled = False):
  if not enabled:
    return None
  end

  return None
end

def coolant_flow(on = False, enabled = False):
  if not enabled:
    return None
  end

  return None
end

def apply_force(on = False, enabled = False):
  if not enabled:
    return None
  end

  return None
end

# Setup for grinding
global grinding_state = False
def set_grinding_state(on = False):
  if on and not grinding_state:
    if not contact_part(True, grind_contact_enabled):
      return False
    end
    tool_power(True, grind_contact_enabled)
    coolant_flow(True, grind_contact_enabled)
    apply_force(True, grind_contact_enabled)
    grinding_state = True
    return True
  elif not on and grinding_state:
    apply_force(False, grind_contact_enabled)
    contact_part(False, grind_contact_enabled)
    coolant_flow(False, grind_contact_enabled)
    tool_power(False, grind_contact_enabled)
    grinding_state = False
    return True
  end
  return True
end

# Abort system
thread listener_thread():
  global haltCommand = [0, 0]
  global haltCount = 0
  while (True):
    global threadCount = threadCount + 1
    global haltCommand = socket_read_ascii_float(1, timeout = 0.1)
    if haltCommand[0] > 0:
      global haltCount = haltCount + 1
    end
  end

  return False
end

def ok_to_proceed():
  return haltCount == 0
end

# Execute the desired pattern grind selected by command[2]...
def pattern_grind():
  global grind_ready = False
  socket_send_line("grind_ready=False")

  if listenerThread > 0:
    kill listenerThread
    listenerThread = 0
  end
  listenerThread = run listener_thread()

  global grind_cycle = 0
  global grind_n_cycles = 0
  global grind_dx_mm = 0
  global grind_dy_mm = 0
  global grind_circle1_diam_mm = 0
  global grind_circle2_diam_mm = 0
  global grind_n_spirals = 0
  global grind_xstep_mm = 0
  global grind_ystep_mm = 0

  # Install tcp that puts tcp at center of part (noop for flat parts!)
  set_tcp(robot_tcp_part)

  if command[2] == 1:
    global response = "set grind_contact_enabled"
    if command[3] > 0:
      global grind_contact_enabled = True
      socket_send_line("grind_contact_enabled=True")
    else:
      global grind_contact_enabled = False
      socket_send_line("grind_contact_enabled=False")
    end
    # RECTANGULAR GRINDS
  elif command[2] == 2:
    global response = "grind_rect"
    global grind_dx_mm = command[3]
    global grind_dy_mm = command[4]
    global grind_n_cycles = command[5]
    grind_rect(grind_dx_mm, grind_dy_mm, grind_n_cycles)

    # SERPENTINE GRINDS
  elif command[2] == 3:
    global response = "grind_serpentine"
    global grind_dx_mm = command[3]
    global grind_dy_mm = command[4]
    global grind_xstep_mm = command[5]
    global grind_ystep_mm = command[6]
    global grind_n_cycles = command[7]
    grind_serpentine(grind_dx_mm, grind_dy_mm, grind_xstep_mm, grind_ystep_mm, grind_n_cycles)

    # CIRCULAR GRINDS
  elif command[2] == 4:
    global response = "grind_circle"
    global grind_circle1_diam_mm = command[3]
    global grind_n_cycles = command[4]
    grind_circle(grind_circle1_diam_mm, grind_n_cycles)

    # SPIRAL GRINDS
  elif command[2] == 5:
    global response = "grind_spiral"
    global grind_circle1_diam_mm = command[3]
    global grind_circle2_diam_mm = command[4]
    global grind_n_spirals = command[5]
    global grind_n_cycles = command[6]
    grind_spiral(grind_circle1_diam_mm, grind_circle2_diam_mm, grind_n_spirals, grind_n_cycles)
  else:
    global response = "Unknown Grind Command"
  end

  # Restore tool-only tcp
  set_tcp(robot_tcp)

  kill listenerThread
  listenerThread = 0

  global grind_ready = True
  socket_send_line("grind_ready=True")
end

# Grind along a rect dx_mm x dy_mm centered on current tool position. Repeat n_cycles times.
# Move in x direction first, then y
def grind_rect(dx_mm, dy_mm, n_cycles):
  if n_cycles < 1:
    return True
  end

  # shape OK?
  shape = robot_part_geometry[0]
  if shape < 1 or shape > 3:
    return False
  end

  # Unit conversion
  dx_m = dx_mm / 1000.0
  dy_m = dy_mm / 1000.0

  # Find initial position p0
  p0 = get_actual_tcp_pose()

  # Move to start position
  if shape == 1:
    p1 = pose_trans(get_forward_kin(), p[-dx_m / 2, -dy_m / 2, 0, 0, 0, 0])
  elif shape == 2:
    radius_m = robot_part_geometry[1] / 2.0
    drx_rad = dy_m / radius_m
    p1 = pose_trans(get_forward_kin(), p[-dx_m / 2, 0, 0, -drx_rad / 2, 0, 0])
  elif shape == 3:
    radius_m = robot_part_geometry[1] / 2.0
    drx_rad = dy_m / radius_m
    dry_rad = dy_m / radius_m
    p1 = pose_trans(get_forward_kin(), p[0, 0, 0, -drx_rad / 2, -dry_rad / 2, 0])
  end
  movel(p1, a = robot_accel, v = robot_speed)

  if not set_grinding_state(True):
    movel(p0, a = robot_accel, v = robot_speed)
    return False
  end

  # Grind the pattern
  if shape == 1:
    pattern_rect_flat(dx_m, dy_m, n_cycles)
  elif shape == 2:
    pattern_rect_cylinder(dx_m, drx_rad, n_cycles)
  elif shape == 3:
    pattern_rect_sphere(drx_rad, dry_rad, n_cycles)
  end

  set_grinding_state(False)

  # Return robot back to initial position
  movel(p0, a = robot_accel, v = robot_speed)
end

# Move along a flat rect dx_m x dy_m starting at cuirrent position. Repeat n_cycles times.
# Move in x direction first, then y
def pattern_rect_flat(dx_m, dy_m, n_cycles):
  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[dx_m, 0, 0, 0, 0, 0])
      movel(p1, a = robot_accel, v = robot_speed, r = robot_blend)
    end

    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[0, dy_m, 0, 0, 0, 0])
      movel(p1, a = robot_accel, v = robot_speed, r = robot_blend)
    end

    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[-dx_m, 0, 0, 0, 0, 0])
      movel(p1, a = robot_accel, v = robot_speed, r = robot_blend)
    end

    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[0, -dy_m, 0, 0, 0, 0])
      movel(p1, a = robot_accel, v = robot_speed, r = robot_blend)
    end
    grind_cycle = grind_cycle + 1
  end
end

# Move along a cylindrical rect dx_mm,drx_rad starting at current position. Repeat n_cycles times.
# Move in x direction first, then rx
def pattern_rect_cylinder(dx_m, drx_rad, n_cycles):
  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[dx_m, 0, 0, 0, 0, 0])
      movel(p1, a = robot_accel, v = robot_speed, r = robot_blend)
    end

    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[0, 0, 0, drx_rad, 0, 0])
      movel(p1, a = robot_accel, v = robot_speed, r = robot_blend)
    end

    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[-dx_m, 0, 0, 0, 0, 0])
      movel(p1, a = robot_accel, v = robot_speed, r = robot_blend)
    end

    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[0, 0, 0, -drx_rad, 0, 0])
      movel(p1, a = robot_accel, v = robot_speed, r = robot_blend)
    end
    grind_cycle = grind_cycle + 1
  end
end

# Move along a sperical rect drx_rad,dry_rad starting at current tool position. Repeat n_cycles times.
# Move in rx direction first, then ry
def pattern_rect_sphere(drx_rad, dry_rad, n_cycles):
  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[0, 0, 0, drx_rad, 0, 0])
      movel(p1, a = robot_accel, v = robot_speed, r = robot_blend)
    end

    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[0, 0, 0, 0, dry_rad, 0])
      movel(p1, a = robot_accel, v = robot_speed, r = robot_blend)
    end

    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[0, 0, 0, -drx_rad, 0, 0])
      movel(p1, a = robot_accel, v = robot_speed, r = robot_blend)
    end

    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[0, 0, 0, 0, -dry_rad, 0])
      movel(p1, a = robot_accel, v = robot_speed, r = robot_blend)
    end
    grind_cycle = grind_cycle + 1
  end
end

# Grind along a rect in serpentine dx_mm,dy_mm incrementing by xstep_mm,ystep_mm centered on current tool position. Repeat n_cycles times.
# Move in x direction first, then y
def grind_serpentine(dx_mm, dy_mm, xstep_mm, ystep_mm, n_cycles):
  if n_cycles < 1:
    return True
  end

  # shape OK?
  shape = robot_part_geometry[0]
  if shape < 1 or shape > 3:
    return False
  end

  # Unit conversion
  dx_m = dx_mm / 1000.0
  dy_m = dy_mm / 1000.0
  xstep_m = xstep_mm / 1000.0
  ystep_m = ystep_mm / 1000.0

  # Find initial position p0
  p0 = get_actual_tcp_pose()

  # Move to start position
  if shape == 1:
    p1 = pose_trans(get_forward_kin(), p[-dx_m / 2, -dy_m / 2, 0, 0, 0, 0])
  elif shape == 2:
    part_radius_m = robot_part_geometry[1] / 2.0
    drx_rad = dy_m / part_radius_m
    rxstep_rad = ystep_m / part_radius_m
    p1 = pose_trans(get_forward_kin(), p[-dx_m / 2, 0, 0, -drx_rad / 2, 0, 0])
  elif shape == 3:
    part_radius_m = robot_part_geometry[1] / 2.0
    drx_rad = dy_m / part_radius_m
    dry_rad = dy_m / part_radius_m
    p1 = pose_trans(get_forward_kin(), p[0, 0, 0, -drx_rad / 2, -dry_rad / 2, 0])
  end
  movel(p1, a = robot_accel, v = robot_speed)

  if not set_grinding_state(True):
    movel(p0, a = robot_accel, v = robot_speed)
    return False
  end

  # Grind the pattern
  if shape == 1:
    pattern_serpentine_flat(dx_m, dy_m, xstep_m, ystep_m, n_cycles)
  elif shape == 2:
    pattern_serpentine_cylinder(dx_m, drx_rad, xstep_m, rxstep_rad, n_cycles)
  elif shape == 3:
    #pattern_serpentine_sphere(dx_m, drx_rad, xstep_m, rxstep_rad, n_cycles)  # NOT IMPLEMENTED
  end

  set_grinding_state(False)

  # Return robot back to initial position
  movel(p0, a = robot_accel, v = robot_speed)
end

# Move along a flat serpentine dx_m,dy_m incrementing by xstep_m,ystep_m starting at current tool position. Repeat n_cycles times.
# Move in x direction first, then y
def pattern_serpentine_flat(dx_m, dy_m, xstep_m, ystep_m, n_cycles):
  global grind_cycle = 1
  global x_grid_count = ceil(dx_m / xstep_m) + 1
  global y_grid_count = ceil(dy_m / ystep_m) + 1
  x_grid = 0
  y_grid = 0
  global cur_xstep_m = xstep_m
  global cur_ystep_m = ystep_m
  n_moves_per_pass = x_grid_count * y_grid_count - 1
  move_count = 0
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    # Advance x by cur_xstep_m
    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[cur_xstep_m, 0, 0, 0, 0, 0])
      movel(p1, a = robot_accel, v = robot_speed, r = robot_blend)

      # Track new grid square we're in
      if cur_xstep_m > 0:
        x_grid = x_grid + 1
      else:
        x_grid = x_grid - 1
      end
    end
    # Adjust x direction
    if x_grid >= x_grid_count-1:
      cur_xstep_m = -xstep_m
    elif x_grid <= 0:
      cur_xstep_m = xstep_m
    end
    move_count = move_count + 1

    # Advance y by cur_ystep_m
    if ok_to_proceed() and move_count < n_moves_per_pass:
      p1 = pose_trans(get_forward_kin(), p[0, cur_ystep_m, 0, 0, 0, 0])
      movel(p1, a = robot_accel, v = robot_speed, r = robot_blend)
      # Track new grid square we're in
      if cur_ystep_m > 0:
        y_grid = y_grid + 1
      else:
        y_grid = y_grid - 1
      end
    end
    # Adjust y direction
    if y_grid >= y_grid_count-1:
      cur_ystep_m = -ystep_m
    elif y_grid <= 0:
      cur_ystep_m = ystep_m
    end
    move_count = move_count + 1

    # Detect when we've covered all the grid squares!
    if move_count >= n_moves_per_pass:
      grind_cycle = grind_cycle + 1
      move_count = 0
    end
  end
end

# Move along a cylindrical serpentine dx_m,drx_rad incrementing by xstep_m,rxstep_rad starting at current tool position. Repeat n_cycles times.
# Move in x direction first, then rx
def pattern_serpentine_cylinder(dx_m, drx_rad, xstep_m, rxstep_rad, n_cycles):
  global grind_cycle = 1
  global x_grid_count = ceil(dx_m / xstep_m) + 1
  global rx_grid_count = ceil(drx_rad / rxstep_rad) + 1
  x_grid = 0
  rx_grid = 0
  global cur_xstep_m = xstep_m
  global cur_rxstep_rad = rxstep_rad
  n_moves_per_pass = x_grid_count * rx_grid_count - 1
  move_count = 0

  while (ok_to_proceed() and grind_cycle <= n_cycles):
    # Advance x by cur_xstep_m
    if ok_to_proceed():
      p1 = pose_trans(get_forward_kin(), p[cur_xstep_m, 0, 0, 0, 0, 0])
      movel(p1, a = robot_accel, v = robot_speed, r = robot_blend)
      # Track new grid square we're in
      if cur_xstep_m > 0:
        x_grid = x_grid + 1
      else:
        x_grid = x_grid - 1
      end
    end
    # Adjust x direction
    if x_grid >= x_grid_count-1:
      cur_xstep_m = -xstep_m
    elif x_grid <= 0:
      cur_xstep_m = xstep_m
    end
    move_count = move_count + 1

    # Advance rx by cur_rxstep_rad
    if ok_to_proceed() and move_count < n_moves_per_pass:
      p1 = pose_trans(get_forward_kin(), p[0, 0, 0, cur_rxstep_rad, 0, 0])
      movel(p1, a = robot_accel, v = robot_speed, r = robot_blend)
      # Track new grid square we're in
      if cur_rxstep_rad > 0:
        rx_grid = rx_grid + 1
      else:
        rx_grid = rx_grid - 1
      end
    end
    # Adjust rx direction
    if rx_grid >= rx_grid_count-1:
      cur_rxstep_rad = -rxstep_rad
    elif rx_grid <= 0:
      cur_rxstep_rad = rxstep_rad
    end
    move_count = move_count + 1

    # Detect when we've covered all the grid squares!
    if move_count >= n_moves_per_pass:
      grind_cycle = grind_cycle + 1
      move_count = 0
    end
  end
end

# Grind along a circle with circle_diam_mm centered on current tool position. Repeat n_cycles times.
def grind_circle(circle_diam_mm, n_cycles):
  if n_cycles < 1:
    return True
  end

  # shape OK?
  shape = robot_part_geometry[0]
  if shape < 1 or shape > 3:
    return False
  end

  # Unit conversion
  circle_diam_m = circle_diam_mm / 1000.0

  # Find initial position p0
  p0 = get_actual_tcp_pose()

  # Move to start position
  if shape == 1:
    p1 = pose_trans(get_forward_kin(), p[circle_diam_m / 2.0, 0, 0, 0, 0, 0])
  elif shape == 2:
    part_diam_m = robot_part_geometry[1]
    p1 = pose_trans(get_forward_kin(), p[circle_diam_m / 2.0, 0, 0, 0, 0, 0])
  elif shape == 3:
    part_diam_m = robot_part_geometry[1]
    p1 = pose_trans(get_forward_kin(), p[0, 0, 0, circle_diam_m / part_diam_m / 2.0, 0, 0])
  end
  movel(p1, a = robot_accel, v = robot_speed)

  if not set_grinding_state(True):
    movel(p0, a = robot_accel, v = robot_speed)
    return False
  end

  # Grind the pattern
  if shape == 1:
    pattern_circle_flat(circle_diam_m, n_cycles)
  elif shape == 2:
    #pattern_circle_cylinder(circle_diam_m, part_diam_m, n_cycles)  # NOT IMPLEMENTED
  elif shape == 3:
    pattern_circle_sphere(circle_diam_m, part_diam_m, n_cycles)
  end

  set_grinding_state(False)

  # Return robot back to initial position
  movel(p0, a = robot_accel, v = robot_speed)
end

# Grind along a flat circle circle_diam_m starting at current tool position. Repeat n_cycles times.
def pattern_circle_flat(circle_diam_m, n_cycles):

  # Unit conversion
  n_points = ceil(circle_diam_m * 1000.0)   # 10 points in a 10mm diam circle... linear n_points up and down from there
  circle_radius_m = circle_diam_m / 2.0     # Circle radius is half of specified dx

  # We're in contact at east side... compute where contact position would be at center of circle
  p_center = pose_trans(get_forward_kin(), p[-circle_radius_m, 0, 0, 0, 0, 0])

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    i = 1
    while ok_to_proceed() and i <= n_points:
      theta = d2r(360.0 * i / n_points)
      x = circle_radius_m * cos(theta)
      y = circle_radius_m * sin(theta)

      p1 = pose_trans(p_center, p[x, y, 0, 0, 0, 0])
      movel(p1, a = robot_accel, v = robot_speed, r = robot_blend)
      i = i + 1
    end

    grind_cycle = grind_cycle + 1
  end
end

# Move along a spherical circle circle_diam_m on a sphere_diam_m object starting at the current tool position. Repeat n_cycles times.
def pattern_circle_sphere(circle_diam_m, sphere_diam_m, n_cycles):
  # Unit conversion
  n_points = ceil(circle_diam_m * 1000.0)   # 10 points in a 10mm diam circle... linear n_points up and down from there
  circle_radius_m = circle_diam_m / 2.0
  sphere_radius_m = sphere_diam_m / 2.0

  # We're in contact at east side... compute where contact position would be at center of circle
  p_center = pose_trans(get_forward_kin(), p[0, 0, 0, -circle_diam_m / sphere_diam_m / 2.0, 0, 0])
  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    i = 1
    while ok_to_proceed() and i <= n_points:
      theta = d2r(360.0 * i / n_points)
      x = circle_radius_m * cos(theta)
      rx = x / sphere_radius_m
      y = circle_radius_m * sin(theta)
      ry = y / sphere_radius_m

      p1 = pose_trans(p_center, p[0, 0, 0, rx, ry, 0])
      movel(p1, a = robot_accel, v = robot_speed, r = robot_blend)
      i = i + 1
    end

    grind_cycle = grind_cycle + 1
  end
end

# Grind along a spiral circle1_diam_mm to circle2_diam_mm in n_spirals with rotations centered on current tool position. Repeat n_cycles times.
def grind_spiral(circle1_diam_mm, circle2_diam_mm, n_spirals, n_cycles):
  if n_cycles < 1:
    return True
  end

  # shape OK?
  shape = robot_part_geometry[0]
  if shape < 1 or shape > 3:
    return False
  end

  # Unit conversion
  circle1_diam_m = circle1_diam_mm / 1000.0
  circle2_diam_m = circle1_diam_mm / 1000.0

  # Find initial position p0
  p0 = get_actual_tcp_pose()

  # Move to start position
  if shape == 1:
    p1 = pose_trans(get_forward_kin(), p[circle1_diam_m / 2.0, 0, 0, 0, 0, 0])
  elif shape == 2:
    part_diam_m = robot_part_geometry[1]
    p1 = pose_trans(get_forward_kin(), p[circle1_diam_m / 2.0, 0, 0, 0, 0, 0])
  elif shape == 3:
    part_diam_m = robot_part_geometry[1]
    p1 = pose_trans(get_forward_kin(), p[0, 0, 0, circle1_diam_m / part_diam_m / 2.0, 0, 0])
  end
  movel(p1, a = robot_accel, v = robot_speed)

  if not set_grinding_state(True):
    movel(p0, a = robot_accel, v = robot_speed)
    return False
  end

  # Grind the pattern
  if shape == 1:
    pattern_spiral_flat(circle1_diam_m, circle2_diam_m, n_spirals, n_cycles)
  elif shape == 2:
    #pattern_circle_cylinder(circle1_diam_m, circle2_diam_m, n_spirals, part_diam_m, n_cycles) # NOT IMPLEMENTED
  elif shape == 3:
    #pattern_circle_sphere(circle1_diam_m, circle2_diam_m, n_spirals, part_diam_m, n_cycles) # NOT IMPLEMENTED
  end

  set_grinding_state(False)

  # Return robot back to initial position
  movel(p0, a = robot_accel, v = robot_speed)
  return True
end

def pattern_spiral_flat(circle1_diam_m, circle2_diam_m, n_spirals, n_cycles):
  # Unit conversion
  circle1_radius_m = circle1_diam_m / 2.0
  circle2_radius_m = circle2_diam_m / 2.0
  
  max_diam_m = circle1_radius_m
  if circle2_diam_m > max_diam_m:
    max_diam_m = circle2_radius_m
  end
  n_points = ceil(max_diam_m * 1000.0) # 10 points in a 10mm diam circle... linear n_points up and down from there
  n_total_points = n_spirals * n_points
  
  # We're in contact at east side... compute where contact position would be at center of circle
  p_center = pose_trans(get_forward_kin(), p[-circle1_diam_m / 2.0, 0, 0, 0, 0, 0])

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    rslope = (circle2_radius_m - circle1_radius_m) / n_total_points
    i = 0
    while ok_to_proceed() and i <= n_total_points:
      theta = d2r(360.0 * (i % n_points) / n_points)
      r_instantaneous = i * rslope + circle1_radius_m
      x = r_instantaneous * cos(theta)
      y = r_instantaneous * sin(theta)

      p1 = pose_trans(p_center, p[x, y, 0, 0, 0, 0])
      movel(p1, a = robot_accel, v = robot_speed, r = robot_blend)
      i = i + 1
    end

    grind_cycle = grind_cycle + 1
    # Next cycle- swap diameters so we go in/out/in etc.
    old_circle1_radius_m = circle1_radius_m
    circle1_radius_m = circle2_radius_m
    circle2_radius_m = old_circle1_radius_m
  end
end

