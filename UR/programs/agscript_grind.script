# AutoGrind Grinding Functions
# File: agscript_grind.script
# Version 2022.04 A
# Programmer: Ned Lecky

global grind_abort_listener_thread_handle = 0
global pattern_grind_thread_handle = 0

global halt_count = 0
global halt_command = [0, 0]

global grind_ready = True
# grind_contact_enable:  0=No Contact   1=Touch but no tool/coolant on or force  2=Touch, Tool, Coolant, and Force
global grind_contact_enable = 0
global grind_touch_retract_mm = 3       # How far to retract after touch  (we do 2X this for ghrind_contact_enable=1)
global grind_touch_speed_mmps = 0.1     # How fast to go in for the touch
global grind_force_dwell_ms = 500       # How long to dwell after turning force more on
global grind_blend_radius_m = 0.001     # Blend radius to use while grinding
global grind_trial_speed_mmps = 20      # Grinding speed when not really grinding!

# Planning points
global p_operator_init = p[0, 0, 0, 0, 0, 0]    # Where we were when operator issued first grind command
global p_contact_init = p[0, 0, 0, 0, 0, 0]     # Where we first contacted the part
global p_contact_center = p[0, 0, 0, 0, 0, 0]   # Computed where center of pattern would be in contact with part

MATH_PI = 3.1415926535

def speed_setter(speed_mmps):
  if grind_contact_enable == 2:
    global grind_speed_mps = speed_mmps / 1000.0
  else:
    global grind_speed_mps = grind_trial_speed_mmps / 1000.0
  end

  global grind_accel_mpss = 2.0

  # Default rotational speeds same as linear
  global grind_rot_speed_rps = grind_speed_mps
  global grind_rot_accel_rpss = grind_accel_mpss
  global grind_rot_blend_radius_rad = grind_blend_radius_m

  # If part is cylinder or spherical, diameter will by >0
  diam_m = robot_part_geometry[1]
  if diam_m > 0.0:
    # These are 1/4 actual speeds but we need to command these to get movel to rotate correctly ???
    global grind_rot_speed_rps = grind_speed_mps * 0.5 / diam_m
    global grind_rot_accel_rpss = grind_accel_mpss * 0.5 / diam_m
    global grind_rot_blend_radius_rad = grind_blend_radius_m * 0.5 / diam_m
  end
end

# Execute the desired pattern grind selected by command[2]...
def pattern_grind():
  global grind_ready = False
  socket_send_line("grind_ready=False")

  if grind_abort_listener_thread_handle > 0:
    kill grind_abort_listener_thread_handle
    grind_abort_listener_thread_handle = 0
  end
  grind_abort_listener_thread_handle = run grind_abort_listener_thread()

  global grind_cycle = 0
  socket_set_var("grind_cycle", grind_cycle)

  # Defaults but any used should be set as needed below
  global grind_dx_mm = 0
  global grind_dy_mm = 0
  global grind_n_cycles = 0
  global grind_force_N = 10.0
  global grind_continue = False
  global grind_circle1_diam_mm = 0
  global grind_circle2_diam_mm = 0
  global grind_n_spirals = 0
  global grind_n_xsteps = 1
  global grind_n_ysteps = 1
  global grind_xstep_mm = 0
  global grind_ystep_mm = 0
  speed_setter(20)

  # Install tcp that puts tcp at center of part (noop for flat parts!)
  set_tcp(robot_tcp_part)

  # Variable Setting
  if command[2] == 0:
    global response = "grind retract"
    set_grind_process_state(False)
  elif command[2] == 1:
    global response = "set grind_contact_enable"
    if command[3] >= 0 and command[3] <= 2:
      global grind_contact_enable = command[3]
    end
    socket_set_var("grind_contact_enable", grind_contact_enable)
  elif command[2] == 2:
    global response = "set grind_touch_retract_mm"
    if command[3] >= 0:
      global grind_touch_retract_mm = command[3]
    end
    socket_set_var("grind_touch_retract_mm", grind_touch_retract_mm)
  elif command[2] == 3:
    global response = "set grind_touch_speed_mmps"
    if command[3] >= 0:
      global grind_touch_speed_mmps = command[3]
    end
    socket_set_var("grind_touch_speed_mmps", grind_touch_speed_mmps)
  elif command[2] == 4:
    global response = "set grind_force_dwell_ms"
    if command[3] >= 0:
      global grind_force_dwell_ms = command[3]
    end
    socket_set_var("grind_force_dwell_ms", grind_force_dwell_ms)
  elif command[2] == 5:
    global response = "set grind_max_wait_ms"
    if command[3] >= 0:
      global grind_max_wait_ms = command[3]
    end
    socket_set_var("grind_max_wait_ms", grind_max_wait_ms)
  elif command[2] == 6:
    global response = "set grind_blend_radius_mm"
    if command[3] >= 0:
      global grind_blend_radius_m = command[3] / 1000.0
    end
    socket_send_string("grind_blend_radius_mm=")
    socket_send_string(grind_blend_radius_m * 1000.0)
    socket_send_lf()
  elif command[2] == 7:
    global response = "set grind_trial_speed_mmps"
    if command[3] > 0:
      global grind_trial_speed_mmps = command[3]
    end
    socket_set_var("grind_trial_speed_mmps", grind_trial_speed_mmps)

    # LINEAR GRINDS
  elif command[2] == 10:
    global response = "grind_line"
    global grind_dx_mm = command[3]
    global grind_dy_mm = command[4]
    global grind_n_cycles = command[5]
    socket_set_var("grind_n_cycles", grind_n_cycles)
    speed_setter(command[6])
    global grind_force_N = command[7]
    global grind_continue = command[8] > 0
    grind_line(grind_dx_mm, grind_dy_mm, grind_n_cycles, grind_continue)

    # RECTANGULAR GRINDS
  elif command[2] == 20:
    global response = "grind_rect"
    global grind_dx_mm = command[3]
    global grind_dy_mm = command[4]
    global grind_n_cycles = command[5]
    socket_set_var("grind_n_cycles", grind_n_cycles)
    speed_setter(command[6])
    global grind_force_N = command[7]
    global grind_continue = command[8] > 0
    grind_rect(grind_dx_mm, grind_dy_mm, grind_n_cycles, grind_continue)

    # SERPENTINE GRINDS
  elif command[2] == 30:
    global response = "grind_serpentine"
    global grind_dx_mm = command[3]
    global grind_dy_mm = command[4]
    global grind_n_xsteps = limiter(command[5], 1, 10)
    global grind_n_ysteps = limiter(command[6], 1, 10)
    global grind_n_cycles = command[7]
    socket_set_var("grind_n_cycles", grind_n_cycles)
    speed_setter(command[8])
    global grind_force_N = command[9]
    global grind_continue = command[10] > 0
    grind_serpentine(grind_dx_mm, grind_dy_mm, grind_n_xsteps, grind_n_ysteps, grind_n_cycles, grind_continue)

    # CIRCULAR GRINDS
  elif command[2] == 40:
    global response = "grind_circle"
    global grind_circle1_diam_mm = command[3]
    global grind_n_cycles = command[4]
    socket_set_var("grind_n_cycles", grind_n_cycles)
    speed_setter(command[5])
    global grind_force_N = command[6]
    global grind_continue = command[7] > 0
    grind_circle(grind_circle1_diam_mm, grind_n_cycles, grind_continue)

    # SPIRAL GRINDS
  elif command[2] == 50:
    global response = "grind_spiral"
    global grind_circle1_diam_mm = command[3]
    global grind_circle2_diam_mm = command[4]
    global grind_n_spirals = command[5]
    global grind_n_cycles = command[6]
    socket_set_var("grind_n_cycles", grind_n_cycles)
    speed_setter(command[7])
    global grind_force_N = command[8]
    global grind_continue = command[9] > 0
    grind_spiral(grind_circle1_diam_mm, grind_circle2_diam_mm, grind_n_spirals, grind_n_cycles, grind_continue)
  else:
    global response = "Unknown grind command"
  end

  # Restore tool-only tcp
  set_tcp(robot_tcp)

  if grind_abort_listener_thread_handle > 0:
    kill grind_abort_listener_thread_handle
    grind_abort_listener_thread_handle = 0
  end

  global grind_ready = True
  socket_send_line("grind_ready=True")
end

# Get into contact with part (or away from)
# enable:  0=No Contact   1=Touch but no tool/coolant on or force  2=Touch, Tool, Coolant, and Force
def contact_part(on = False, enable = 0):
  if on:
    if enable == 0:
      # Just do a small forward motion in the direction of touchoff- this is a simulated p_contact_init
      p_contact_init = pose_trans(get_forward_kin(), p[0, 0, 0.005, 0, 0, 0])
      movel(p_contact_init, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
    elif enable == 1:
      # Advance until contact but retract 2X grind distance and use this as a simulated p_contact_init
      success = touchoff(grind_touch_speed_mmps, grind_touch_retract_mm * 2.0)
      p_contact_init = get_target_tcp_pose()
      return success
    elif enable == 2:
      # Advance until contact
      success = touchoff(grind_touch_speed_mmps, grind_touch_retract_mm)
      # Touchoff has backed off by grind_touch_retract_mm so we need to compute that actual p_contact_init
      p_contact_init = pose_trans(get_forward_kin(), p[0, 0, grind_touch_retract_mm / 1000.0, 0, 0, 0])
      return success
    end
  else:  # Back off
    p1 = pose_trans(get_forward_kin(), p[0, 0, -0.010, 0, 0, 0])
    movel(p1, a = robot_linear_accel_mpss, v = robot_linear_speed_mps, r = 0.003)
  end

  return True
end

# Takes an 8-element list DOUT#,State x 4.  -1 indicates unused slot
def set_digital_output_list(list):
  i = 0
  while i < 8:
    if list[i] >= 0:
      b = list[i + 1] == 1
      set_digital_out(list[i], b)
    end
    i = i + 2
  end
end

# enable:  0=No Contact   1=Touch but no tool/coolant on or force  2=Touch, Tool, Coolant, and Force
def tool_power(on = False, enable = 0):
  if enable < 2:
    return None
  end

  if on:
    # ON IO
    set_digital_output_list(robot_tool_on_outputs)
  else:
    # OFF IO
    set_digital_output_list(robot_tool_off_outputs)
  end

  return None
end

# enable:  0=No Contact   1=Touch but no tool/coolant on or force  2=Touch, Tool, Coolant, and Force
def coolant_flow(on = False, enable = 0):
  if enable < 2:
    return None
  end

  if on:
    # ON IO
    set_digital_output_list(robot_coolant_on_outputs)
  else:
    # OFF IO
    set_digital_output_list(robot_coolant_off_outputs)
  end

  return None
end

# enable:  0=No Contact   1=Touch but no tool/coolant on or force  2=Touch, Tool, Coolant, and Force
def apply_force(on = False, enable = 0, approach_speed_mmps = 10):
  if enable < 2:
    return None
  end

  if on:
    sleep(0.02)
    zero_ftsensor()
    # Force is in tool frame
    # Compliant in Tool Z
    # Applying grind_force_N in Z+
    # 2: Force frame not transformed
    # Speed limits
    force_mode(tool_pose(), [0, 0, 1, 0, 0, 0], [0.0, 0.0, grind_force_N, 0.0, 0.0, 0.0], 2, [0.1, 0.1, approach_speed_mmps / 1000.0, 0.3490658503988659, 0.3490658503988659, 0.3490658503988659])
    sleep(grind_force_dwell_ms / 1000.0)
  else:
    end_force_mode()
  end

  return None
end

# Setup for grinding
global grind_process_state = False
def set_grind_process_state(on = False, pose_to_center = [p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0]]):
  if on and not grind_process_state:
    global p_operator_init = get_target_tcp_pose()

    # Move to start position for touchoff
    shape = robot_part_geometry[0]
    if shape < 1 or shape > 3:
      return False
    end

    p1 = pose_trans(p_operator_init, pose_to_center[shape-1])
    movel(p1, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)

    # Touch part and set p_contact_init
    if not contact_part(True, grind_contact_enable):
      # Failure to contact part should abort... don't set grind_process_state and return False
      movel(p_operator_init, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
      socket_send_line("grind_process_state=False")
      return False
    end

    # Compute p_contact_center... where we would have been if we had touched off from the operator teach position!
    reverse_pose_to_center = pose_to_center[shape-1]
    i = 0
    while i < 6:
      reverse_pose_to_center[i] = -reverse_pose_to_center[i]
      i = i + 1
    end
    global p_contact_center = pose_trans(p_contact_init, reverse_pose_to_center)

    tool_power(True, grind_contact_enable)
    coolant_flow(True, grind_contact_enable)
    apply_force(True, grind_contact_enable, grind_touch_speed_mmps)
    grind_process_state = True
  elif not on and grind_process_state:
    apply_force(False, grind_contact_enable, 0)
    contact_part(False, grind_contact_enable)
    coolant_flow(False, grind_contact_enable)
    tool_power(False, grind_contact_enable)
    global aaa_p_operator_init = p_operator_init
    movel(p_operator_init, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
    grind_process_state = False
  end

  # Always let the host know status
  if grind_process_state:
    socket_send_line("grind_process_state=True")
  else:
    socket_send_line("grind_process_state=False")
  end
  return True
end

######################################################################################
# Thread to listen for abort messages while grinding
#
thread grind_abort_listener_thread():
  global halt_command = [0, 0]
  global halt_count = 0
  while (True):
    global halt_command = socket_read_ascii_float(1, timeout = 0.1)
    if halt_command[0] > 0 or not is_door_closed():
      global halt_count = halt_count + 1
    end
    sync()
  end
  return None
end

# Has the thread not heard a stop message?
def ok_to_proceed():
  return halt_count == 0
end
#
# Thread to listen for abort messages while grinding
######################################################################################


######################################################################################
# TOP LEVEL GRIND FUNCTIONS
######################################################################################

# Grind along a line dx_mm x dy_mm centered on current tool position. Repeat n_cycles times. If stay_in_contact, stay_in_contact at end.
def grind_line(dx_mm, dy_mm, n_cycles, stay_in_contact):
  if n_cycles < 1:
    return True
  end

  # Unit conversion
  dx_m = dx_mm / 1000.0
  dy_m = dy_mm / 1000.0
  radius_m = robot_part_geometry[1] / 2.0
  drx_rad = dx_m / radius_m
  dry_rad = dy_m / radius_m

  # Grind time estimate
  time_ms = sqrt(dx_mm * dx_mm + dy_mm * dy_mm) * n_cycles / grind_speed_mps
  socket_set_var("robot_step_time_estimate_ms", time_ms)

  if not set_grind_process_state(True, [p[-dx_m / 2.0, -dy_m / 2.0, 0, 0, 0, 0], p[-dx_m / 2.0, 0, 0, -dry_rad / 2.0, 0, 0], p[0, 0, 0, -drx_rad / 2.0, -dry_rad / 2.0, 0]]):
    return False
  end

  # Grind the pattern
  shape = robot_part_geometry[0]
  if shape == 1:
    pattern_line_flat(p_contact_center, dx_m, dy_m, n_cycles)
  elif shape == 2:
    # Speed factor is 0.5/diam for pure rotational (all y) and 1.0 for pure translational (all x)
    max_speed_factor = 0.5 / robot_part_geometry[1]
    theta = atan2(abs(dy_mm), abs(dx_mm))
    speed_factor = 1.0 + (max_speed_factor-1.0) * abs(sin(theta))
    pattern_line_cylinder(p_contact_center, dx_m, dry_rad, speed_factor, n_cycles)
  elif shape == 3:
    speed_factor = 0.5 / robot_part_geometry[1]
    pattern_line_sphere(p_contact_center, drx_rad, dry_rad, n_cycles)
  end

  if not stay_in_contact or not ok_to_proceed():
    set_grind_process_state(False)
  else:
    stopl(1.0)
  end
  return True
end

# Grind along a rect dx_mm x dy_mm centered on current tool position. Repeat n_cycles times. If stay_in_contact, stay_in_contact at end.
# Move in x direction first, then y
def grind_rect(dx_mm, dy_mm, n_cycles, stay_in_contact):
  if n_cycles < 1:
    return True
  end

  # Unit conversion
  dx_m = dx_mm / 1000.0
  dy_m = dy_mm / 1000.0
  radius_m = robot_part_geometry[1] / 2.0
  drx_rad = dx_m / radius_m
  dry_rad = dy_m / radius_m
  speed_factor = 0.5 / robot_part_geometry[1]  # 0.5 / diam_m is the speedup needed on rotational moves

  # Grind time estimate
  time_ms = 2 * (dx_mm + dy_mm) * n_cycles / grind_speed_mps
  socket_set_var("robot_step_time_estimate_ms", time_ms)

  if not set_grind_process_state(True, [p[-dx_m / 2.0, -dy_m / 2.0, 0, 0, 0, 0], p[-dx_m / 2.0, 0, 0, -dry_rad / 2.0, 0, 0], p[0, 0, 0, -drx_rad / 2.0, -dry_rad / 2.0, 0]]):
    return False
  end

  # Grind the pattern
  shape = robot_part_geometry[0]
  if shape == 1:
    pattern_rect_flat(p_contact_center, dx_m, dy_m, n_cycles)
  elif shape == 2:
    pattern_rect_cylinder(p_contact_center, dx_m, dry_rad, n_cycles)
  elif shape == 3:
    pattern_rect_sphere(p_contact_center, drx_rad, dry_rad, n_cycles)
  end

  if not stay_in_contact or not ok_to_proceed():
    set_grind_process_state(False)
  else:
    stopl(1.0)
  end
  return True
end

# Grind along a rect in serpentine dx_mm,dy_mm incrementing by xstep_mm,ystep_mm centered on current tool position. Repeat n_cycles times. If stay_in_contact, stay_in_contact at end.
# Move in x direction first, then y
def grind_serpentine(dx_mm, dy_mm, n_xsteps, n_ysteps, n_cycles, stay_in_contact):
  if n_cycles < 1:
    return True
  end

  # Either n_xsteps or n_ysteps must be 1. Whichever one is one will be the direction of the first move.
  if n_xsteps != 1 and n_ysteps != 1:
    return False
  end

  # Unit conversion
  dx_m = dx_mm / 1000.0
  dy_m = dy_mm / 1000.0
  part_radius_m = robot_part_geometry[1] / 2.0
  drx_rad = dy_m / part_radius_m
  dry_rad = dy_m / part_radius_m

  # Grind time estimate
  time_ms = (dx_mm * n_ysteps + dy_mm * n_xsteps) * n_cycles / grind_speed_mps
  socket_set_var("robot_step_time_estimate_ms", time_ms)

  if not set_grind_process_state(True, [p[-dx_m / 2.0, -dy_m / 2.0, 0, 0, 0, 0], p[-dx_m / 2.0, 0, 0, -dry_rad / 2.0, 0, 0], p[0, 0, 0, -drx_rad / 2.0, -dry_rad / 2.0, 0]]):
    return False
  end

  # Grind the pattern
  shape = robot_part_geometry[0]
  if shape == 1:
    pattern_serpentine_flat(p_contact_center, dx_m, dy_m, n_xsteps, n_ysteps, n_cycles)
  elif shape == 2:
    pattern_serpentine_cylinder(p_contact_center, dx_m, drx_rad, n_xsteps, n_ysteps, n_cycles)
  elif shape == 3:
    pattern_serpentine_sphere(p_contact_center, drx_rad, dry_rad, n_xsteps, n_ysteps, n_cycles)
  end

  if not stay_in_contact or not ok_to_proceed():
    set_grind_process_state(False)
  else:
    stopl(1.0)
  end
  return True
end

# Grind along a circle with circle_diam_mm centered on p_center. Repeat n_cycles times. If stay_in_contact, stay_in_contact at end.
def grind_circle(circle_diam_mm, n_cycles, stay_in_contact):
  if n_cycles < 1:
    return True
  end

  # Unit conversion
  circle_diam_m = circle_diam_mm / 1000.0
  part_diam_m = robot_part_geometry[1]

  # Grind time estimate
  time_ms = MATH_PI * circle_diam_mm * n_cycles / grind_speed_mps
  socket_set_var("robot_step_time_estimate_ms", time_ms)


  if not set_grind_process_state(True, [p[-circle_diam_m / 2.0, 0, 0, 0, 0, 0], p[-circle_diam_m / 2.0, 0, 0, 0, 0, 0], p[0, 0, 0, -circle_diam_m / part_diam_m, 0, 0]]):
    return False
  end

  # Grind the pattern
  shape = robot_part_geometry[0]
  if shape == 1:
    pattern_circle_flat(p_contact_center, circle_diam_m, n_cycles)
  elif shape == 2:
    pattern_circle_cylinder(p_contact_center, circle_diam_m, part_diam_m, n_cycles)
  elif shape == 3:
    pattern_circle_sphere(p_contact_center, circle_diam_m, part_diam_m, n_cycles)
  end

  if not stay_in_contact or not ok_to_proceed():
    set_grind_process_state(False)
  else:
    stopl(1.0)
  end
  return True
end

# Grind along a spiral circle1_diam_mm to circle2_diam_mm in n_spirals with rotations centered on current tool position. Repeat n_cycles times. If stay_in_contact, stay_in_contact at end.
def grind_spiral(circle1_diam_mm, circle2_diam_mm, n_spirals, n_cycles, stay_in_contact):
  if n_cycles < 1:
    return True
  end

  # Unit conversion
  circle1_diam_m = circle1_diam_mm / 1000.0
  circle2_diam_m = circle2_diam_mm / 1000.0
  part_diam_m = robot_part_geometry[1]

  # Grind time estimate based on avergae diam
  time_ms = MATH_PI * (circle1_diam_mm + circle2_diam_mm) / 2 * n_cycles / grind_speed_mps
  socket_set_var("robot_step_time_estimate_ms", time_ms)

  if not set_grind_process_state(True, [p[-circle1_diam_m / 2.0, 0, 0, 0, 0, 0], p[-circle1_diam_m / 2.0, 0, 0, 0, 0, 0], p[0, 0, 0, -circle1_diam_m / part_diam_m, 0, 0]]):
    return False
  end

  # Grind the pattern
  shape = robot_part_geometry[0]
  if shape == 1:
    pattern_spiral_flat(p_contact_center, circle1_diam_m, circle2_diam_m, n_spirals, n_cycles)
  elif shape == 2:
    pattern_spiral_cylinder(p_contact_center, circle1_diam_m, circle2_diam_m, n_spirals, part_diam_m, n_cycles)
  elif shape == 3:
    pattern_spiral_sphere(p_contact_center, circle1_diam_m, circle2_diam_m, n_spirals, part_diam_m, n_cycles)
  end

  if not stay_in_contact or not ok_to_proceed():
    set_grind_process_state(False)
  else:
    stopl(1.0)
  end
  return True
end



######################################################################################
# LINE PATTERNS
######################################################################################

# Move along a flat line dx_m x dy_m centered on p_center. Repeat n_cycles times.
# Move in x direction first, then y
def pattern_line_flat(p_center, dx_m, dy_m, n_cycles):
  p0 = pose_trans(p_center, p[-dx_m / 2.0, -dy_m / 2.0, 0, 0, 0, 0])
  p1 = pose_trans(p_center, p[dx_m / 2.0, dy_m / 2.0, 0, 0, 0, 0])
  t_move = sqrt(dx_m * dx_m + dy_m * dy_m) / grind_speed_mps
  pdest = p0

  global grind_cycle = 0
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    if ok_to_proceed():
      movel_int(pdest, a = grind_accel_mpss, v = grind_speed_mps, r = grind_blend_radius_m, t_move = t_move)
    end

    # Alternate directions for multiple cycles
    if pdest == p0:
      pdest = p1
    else:
      pdest = p0
    end

    grind_cycle = grind_cycle + 1
  end
end

# Move along a cylindrical line dx_mm,drx_rad centered on p_center. Repeat n_cycles times.
# Move in x direction first, then rx
def pattern_line_cylinder(p_center, dx_m, drx_rad, speed_factor, n_cycles):
  p0 = pose_trans(p_center, p[-dx_m / 2.0, 0, 0, -drx_rad / 2.0, 0, 0])
  p1 = pose_trans(p_center, p[dx_m / 2.0, 0, 0, drx_rad / 2.0, 0, 0])
  t_move = sqrt(pow(dx_m / grind_speed_mps, 2) + pow(drx_rad / grind_rot_speed_rps / 4, 2))
  pdest = p0

  global grind_cycle = 0
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    if ok_to_proceed():
      movel_int(pdest, a = grind_accel_mpss * speed_factor, v = grind_speed_mps * speed_factor, r = grind_blend_radius_m * speed_factor, t_move = t_move)
    end

    # Alternate directions for multiple cycles
    if pdest == p0:
      pdest = p1
    else:
      pdest = p0
    end

    grind_cycle = grind_cycle + 1
  end
end

# Move along a spherical line drx_rad,dry_rad centered on p_center. Repeat n_cycles times.
# Move in rx direction first, then ry
def pattern_line_sphere(p_center, drx_rad, dry_rad, n_cycles):
  p0 = pose_trans(p_center, p[0, 0, 0, -drx_rad / 2.0, -dry_rad / 2.0, 0])
  p1 = pose_trans(p_center, p[0, 0, 0, drx_rad / 2.0, dry_rad / 2.0, 0])
  pdest = p0
  t_move = sqrt(drx_rad * drx_rad + dry_rad * dry_rad) / grind_rot_speed_rps / 4

  global grind_cycle = 0
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    if ok_to_proceed():
      movel_int(pdest, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, r = grind_rot_blend_radius_rad, t_move = t_move)
    end
    # Alternate directions for multiple cycles
    if pdest == p0:
      pdest = p1
    else:
      pdest = p0
    end

    grind_cycle = grind_cycle + 1
  end
end


######################################################################################
# RECT PATTERNS
######################################################################################

# Move along a flat rect dx_m x dy_m centered on p_center. Repeat n_cycles times.
# Move in x direction first, then y
def pattern_rect_flat(p_center, dx_m, dy_m, n_cycles):
  t_move_x = dx_m / grind_speed_mps
  t_move_y = dy_m / grind_speed_mps

  global grind_cycle = 1
  if ok_to_proceed():
    p1 = pose_trans(p_center, p[-dx_m / 2.0, -dy_m / 2.0, 0, 0, 0, 0])
    movel_int(p1, a = grind_accel_mpss, v = grind_speed_mps, r = grind_blend_radius_m, t_move = 1)
  end
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)

    if ok_to_proceed():
      p1 = pose_trans(p_center, p[dx_m / 2.0, -dy_m / 2.0, 0, 0, 0, 0])
      movel_int(p1, a = grind_accel_mpss, v = grind_speed_mps, r = grind_blend_radius_m, t_move = t_move_x)
    end

    if ok_to_proceed():
      p1 = pose_trans(p_center, p[dx_m / 2.0, dy_m / 2.0, 0, 0, 0, 0])
      movel_int(p1, a = grind_accel_mpss, v = grind_speed_mps, r = grind_blend_radius_m, t_move = t_move_y)
    end

    if ok_to_proceed():
      p1 = pose_trans(p_center, p[-dx_m / 2.0, dy_m / 2.0, 0, 0, 0, 0])
      movel_int(p1, a = grind_accel_mpss, v = grind_speed_mps, r = grind_blend_radius_m, t_move = t_move_x)
    end

    if ok_to_proceed():
      p1 = pose_trans(p_center, p[-dx_m / 2.0, -dy_m / 2.0, 0, 0, 0, 0])
      movel_int(p1, a = grind_accel_mpss, v = grind_speed_mps, r = grind_blend_radius_m, t_move = t_move_y)
    end
    grind_cycle = grind_cycle + 1
  end
end

# Move along a cylindrical rect dx_mm,drx_rad centered on p_center. Repeat n_cycles times.
# Move in x direction first, then rx
def pattern_rect_cylinder(p_center, dx_m, drx_rad, n_cycles):
  t_move_x = dx_m / grind_speed_mps
  t_move_rx = drx_rad / grind_rot_speed_rps / 4

  if ok_to_proceed():
    p1 = pose_trans(p_center, p[-dx_m / 2.0, 0, 0, -drx_rad / 2.0, 0, 0])
    movel_int(p1, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, r = grind_rot_blend_radius_rad, t_move = 1)
  end

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    if ok_to_proceed():
      p1 = pose_trans(p_center, p[dx_m / 2.0, 0, 0, -drx_rad / 2.0, 0, 0])
      movel_int(p1, a = grind_accel_mpss, v = grind_speed_mps, r = grind_blend_radius_m, t_move = t_move_x)
    end

    if ok_to_proceed():
      p1 = pose_trans(p_center, p[dx_m / 2.0, 0, 0, drx_rad / 2.0, 0, 0])
      movel_int(p1, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, r = grind_rot_blend_radius_rad, t_move = t_move_rx)
    end

    if ok_to_proceed():
      p1 = pose_trans(p_center, p[-dx_m / 2.0, 0, 0, drx_rad / 2.0, 0, 0])
      movel_int(p1, a = grind_accel_mpss, v = grind_speed_mps, r = grind_blend_radius_m, t_move = t_move_x)
    end

    if ok_to_proceed():
      p1 = pose_trans(p_center, p[-dx_m / 2.0, 0, 0, -drx_rad / 2.0, 0, 0])
      movel_int(p1, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, r = grind_rot_blend_radius_rad, t_move = t_move_rx)
    end
    grind_cycle = grind_cycle + 1
  end
end

# Move along a spherical rect drx_rad,dry_rad centered on p_center. Repeat n_cycles times.
# Move in rx direction first, then ry
def pattern_rect_sphere(p_center, drx_rad, dry_rad, n_cycles):
  t_move_rx = drx_rad / grind_rot_speed_rps / 4
  t_move_ry = dry_rad / grind_rot_speed_rps / 4

  if ok_to_proceed():
    p1 = pose_trans(p_center, p[0, 0, 0, -drx_rad / 2.0, -dry_rad / 2.0, 0])
    movel_int(p1, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, r = grind_rot_blend_radius_rad, t_move = 1)
  end

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    if ok_to_proceed():
      p1 = pose_trans(p_center, p[0, 0, 0, drx_rad / 2.0, -dry_rad / 2.0, 0])
      movel_int(p1, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, r = grind_rot_blend_radius_rad, t_move = t_move_rx)
    end

    if ok_to_proceed():
      p1 = pose_trans(p_center, p[0, 0, 0, drx_rad / 2.0, dry_rad / 2.0, 0])
      movel_int(p1, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, r = grind_rot_blend_radius_rad, t_move = t_move_ry)
    end

    if ok_to_proceed():
      p1 = pose_trans(p_center, p[0, 0, 0, -drx_rad / 2.0, dry_rad / 2.0, 0])
      movel_int(p1, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, r = grind_rot_blend_radius_rad, t_move = t_move_rx)
    end

    if ok_to_proceed():
      p1 = pose_trans(p_center, p[0, 0, 0, -drx_rad / 2.0, -dry_rad / 2.0, 0])
      movel_int(p1, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, r = grind_rot_blend_radius_rad, t_move = t_move_ry)
    end
    grind_cycle = grind_cycle + 1
  end
end


######################################################################################
# SERPENTINE PATTERNS
######################################################################################

# Move along a flat serpentine dx_m,dy_m in n_xsteps,n_ysteps centered on p_center. Repeat n_cycles times.
# Move in direction of whichever nsteps is 1 first
def pattern_serpentine_flat(p_center, dx_m, dy_m, n_xsteps, n_ysteps, n_cycles):
  t_move_x = dx_m / grind_speed_mps
  t_move_y = dy_m / grind_speed_mps

  # Bottom left corner, grid 0,0
  p0 = pose_trans(p_center, p[-dx_m / 2.0, -dy_m / 2.0, 0, 0, 0, 0])

  # Track our grid square number... we're in [0,0] and moving [+1,+1] in either x or y
  x_grid = 0
  y_grid = 0
  x_incr = 1
  y_incr = 1
  grid_dx_m = dx_m / n_xsteps
  grid_dy_m = dy_m / n_ysteps

  # How many moves does it take to complete a pass?
  global n_moves_per_pass = (n_xsteps + n_ysteps) * 2 - 1

  move_count = 0
  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    # Skip first X move if we should start with a y move
    if grind_cycle != 1 or move_count != 0 or n_xsteps == 1:
      # Advance x_grid by x_incr
      x_grid = x_grid + x_incr

      # Move to the corresponding position
      p1 = pose_trans(p0, p[x_grid * grid_dx_m, y_grid * grid_dy_m, 0, 0, 0, 0])
      movel_int(p1, a = grind_accel_mpss, v = grind_speed_mps, r = grind_blend_radius_m, t_move = t_move_x / n_xsteps)

      # Adjust x direction
      if x_grid >= n_xsteps:
        x_incr = -1
      elif x_grid <= 0:
        x_incr = 1
      end
      move_count = move_count + 1
    end

    if ok_to_proceed() and move_count < n_moves_per_pass:
      # Advance y_grid by y_incr
      y_grid = y_grid + y_incr

      # Move to the corresponding position
      p1 = pose_trans(p0, p[x_grid * grid_dx_m, y_grid * grid_dy_m, 0, 0, 0, 0])
      movel_int(p1, a = grind_accel_mpss, v = grind_speed_mps, r = grind_blend_radius_m, t_move = t_move_y / n_ysteps)

      # Adjust y direction
      if y_grid >= n_ysteps:
        y_incr = -1
      elif y_grid <= 0:
        y_incr = 1
      end
      move_count = move_count + 1
    end

    # Detect when we've covered all the grid squares!
    if move_count >= n_moves_per_pass:
      grind_cycle = grind_cycle + 1
      move_count = 0
    end
  end
end

# Move along a cylindrical serpentine dx_m,drx_rad in n_xsteps,n_rxsteps centered on p_center. Repeat n_cycles times.
# Move in direction of whichever nsteps is 1 first
def pattern_serpentine_cylinder(p_center, dx_m, drx_rad, n_xsteps, n_rxsteps, n_cycles):
  t_move_x = dx_m / grind_speed_mps
  t_move_rx = drx_rad / grind_rot_speed_rps / 4

  # Bottom left corner, grid 0,0
  p0 = pose_trans(p_center, p[-dx_m / 2.0, 0, 0, -drx_rad / 2.0, 0, 0])

  # Track our grid square number... we're in [0,0] and moving [+1,+1] in either x or y
  x_grid = 0
  y_grid = 0
  x_incr = 1
  y_incr = 1
  grid_dx_m = dx_m / n_xsteps
  grid_drx_rad = drx_rad / n_rxsteps

  # How many moves does it take to complete a pass?
  global n_moves_per_pass = (n_xsteps + n_rxsteps) * 2 - 1

  move_count = 0
  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    # Skip first X move if we should start with a y move
    if grind_cycle != 1 or move_count != 0 or n_xsteps == 1:
      # Advance x_grid by x_incr
      x_grid = x_grid + x_incr

      # Move to the corresponding position
      p1 = pose_trans(p0, p[x_grid * grid_dx_m, 0, 0, y_grid * grid_drx_rad, 0, 0])
      movel_int(p1, a = grind_accel_mpss, v = grind_speed_mps, r = grind_blend_radius_m, t_move = t_move_x / n_xsteps)

      # Adjust x direction
      if x_grid >= n_xsteps:
        x_incr = -1
      elif x_grid <= 0:
        x_incr = 1
      end
      move_count = move_count + 1
    end

    if ok_to_proceed() and move_count < n_moves_per_pass:
      # Advance y_grid by y_incr
      y_grid = y_grid + y_incr

      # Move to the corresponding position
      p1 = pose_trans(p0, p[x_grid * grid_dx_m, 0, 0, y_grid * grid_drx_rad, 0, 0])
      movel_int(p1, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, r = grind_rot_blend_radius_rad, t_move = t_move_rx / n_rxsteps)

      # Adjust y direction
      if y_grid >= n_rxsteps:
        y_incr = -1
      elif y_grid <= 0:
        y_incr = 1
      end
      move_count = move_count + 1
    end

    # Detect when we've covered all the grid squares!
    if move_count >= n_moves_per_pass:
      grind_cycle = grind_cycle + 1
      move_count = 0
    end
  end
end

# Move along a sperical serpentine drx_rad,dry_rad in n_rxsteps,n_rysteps centered on p_center. Repeat n_cycles times.
# Move in direction of whichever nsteps is 1 first
def pattern_serpentine_sphere(p_center, drx_rad, dry_rad, n_rxsteps, n_rysteps, n_cycles):
  t_move_rx = drx_rad / grind_rot_speed_rps / 4
  t_move_ry = dry_rad / grind_rot_speed_rps / 4

  # Bottom left corner, grid 0,0
  p0 = pose_trans(p_center, p[0, 0, 0, -drx_rad / 2.0, -dry_rad / 2.0, 0])

  # Track our grid square number... we're in [0,0] and moving [+1,+1] in either x or y
  x_grid = 0
  y_grid = 0
  x_incr = 1
  y_incr = 1
  grid_drx_rad = drx_rad / n_rxsteps
  grid_dry_rad = dry_rad / n_rysteps

  # How many moves does it take to complete a pass?
  global n_moves_per_pass = (n_rxsteps + n_rysteps) * 2 - 1

  move_count = 0
  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    # Skip first X move if we should start with a y move
    if grind_cycle != 1 or move_count != 0 or n_rxsteps == 1:
      # Advance x_grid by x_incr
      x_grid = x_grid + x_incr

      # Move to the corresponding position
      p1 = pose_trans(p0, p[0, 0, 0, x_grid * grid_drx_rad, y_grid * grid_dry_rad, 0])
      movel_int(p1, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, r = grind_rot_blend_radius_rad, t_move = t_move_rx / n_rxsteps)

      # Adjust x direction
      if x_grid >= n_rxsteps:
        x_incr = -1
      elif x_grid <= 0:
        x_incr = 1
      end
      move_count = move_count + 1
    end

    if ok_to_proceed() and move_count < n_moves_per_pass:
      # Advance y_grid by y_incr
      y_grid = y_grid + y_incr

      # Move to the corresponding position
      p1 = pose_trans(p0, p[0, 0, 0, x_grid * grid_drx_rad, y_grid * grid_dry_rad, 0])
      movel_int(p1, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, r = grind_rot_blend_radius_rad, t_move = t_move_ry / n_rysteps)

      # Adjust y direction
      if y_grid >= n_rysteps:
        y_incr = -1
      elif y_grid <= 0:
        y_incr = 1
      end
      move_count = move_count + 1
    end

    # Detect when we've covered all the grid squares!
    if move_count >= n_moves_per_pass:
      grind_cycle = grind_cycle + 1
      move_count = 0
    end
  end
end


######################################################################################
# CIRCULAR PATTERNS
######################################################################################
# What is a good number of points to use for a circular pattern?
def recommend_npoints(diam_m, blend_radius_m):
  circum_m = diam_m * MATH_PI
  if blend_radius_m > 0:
    # How many blend_radii to cover the circumference
    n_points = ceil(circum_m / blend_radius_m)
  else:
    # Blend radius is 0... model would be 10 points for a 10mm diameter (1000 points for 1m diameter!)
    n_points = ceil(diam_m * 1000.0)
  end
  return limiter(n_points, 1, 100)
end

# Grind along a flat circle circle_diam_m centered on p_center. Repeat n_cycles times.
def pattern_circle_flat(p_center, circle_diam_m, n_cycles):

  # Local calculations
  n_points = recommend_npoints(circle_diam_m, grind_blend_radius_m)
  circle_radius_m = circle_diam_m / 2.0

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    i = 0
    while ok_to_proceed() and i <= n_points:
      theta = d2r(180.0 + 360.0 * i / n_points)
      x = circle_radius_m * cos(theta)
      y = circle_radius_m * sin(theta)

      p1 = pose_trans(p_center, p[x, y, 0, 0, 0, 0])
      movel(p1, a = grind_accel_mpss, v = grind_speed_mps, r = grind_blend_radius_m)
      i = i + 1
    end

    grind_cycle = grind_cycle + 1
  end
end

# Move along a cylindrical circle circle_diam_m on a cylinder_diam_m object starting at the current tool position. Repeat n_cycles times.
def pattern_circle_cylinder(p_center, circle_diam_m, cylinder_radius_m, n_cycles):

  # Local calculations
  n_points = recommend_npoints(circle_diam_m, grind_blend_radius_m)
  circle_radius_m = circle_diam_m / 2.0
  speed_factor = 0.5 / robot_part_geometry[1]

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    i = 0
    while ok_to_proceed() and i <= n_points:
      theta = d2r(180.0 + 360.0 * i / n_points)
      x = circle_radius_m * cos(theta)
      y = circle_radius_m * sin(theta)
      rx = 2.0 * y / cylinder_radius_m

      p1 = pose_trans(p_center, p[x, 0, 0, rx, 0, 0])
      # Speed_factor needs to be applied when running radially, and needs to be 1.0 when running laterally. This smooths it all the way around!
      this_speed_factor = (speed_factor - 1) * abs(cos(theta)) + 1.0
      movel(p1, a = grind_accel_mpss * this_speed_factor, v = grind_speed_mps * this_speed_factor, r = grind_blend_radius_m * this_speed_factor)
      i = i + 1
    end

    grind_cycle = grind_cycle + 1
  end
end

# Move along a spherical circle circle_diam_m on a sphere_diam_m object starting at the current tool position. Repeat n_cycles times.
def pattern_circle_sphere(p_center, circle_diam_m, sphere_diam_m, n_cycles):
  # Local calculations
  n_points = recommend_npoints(circle_diam_m, grind_blend_radius_m)
  circle_radius_m = circle_diam_m / 2.0
  sphere_radius_m = sphere_diam_m / 2.0

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    i = 0
    while ok_to_proceed() and i <= n_points:
      theta = d2r(180.0 + 360.0 * i / n_points)
      x = circle_radius_m * cos(theta)
      rx = x / sphere_radius_m
      y = circle_radius_m * sin(theta)
      ry = y / sphere_radius_m

      p1 = pose_trans(p_center, p[0, 0, 0, rx, ry, 0])
      movel(p1, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, r = grind_rot_blend_radius_rad)
      i = i + 1
    end

    grind_cycle = grind_cycle + 1
  end
end


######################################################################################
# SPIRAL PATTERNS
######################################################################################
def pattern_spiral_flat(p_center, circle1_diam_m, circle2_diam_m, n_spirals, n_cycles):
  # Local calculations
  max_diam_m = max(circle1_diam_m, circle2_diam_m)
  n_points = recommend_npoints(max_diam_m, grind_blend_radius_m)
  n_total_points = n_spirals * n_points
  circle1_radius_m = circle1_diam_m / 2.0
  circle2_radius_m = circle2_diam_m / 2.0

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    rslope = (circle2_radius_m - circle1_radius_m) / n_total_points
    i = 0
    while ok_to_proceed() and i <= n_total_points:
      theta = d2r(180.0 + 360.0 * (i % n_points) / n_points)
      r_instantaneous = i * rslope + circle1_radius_m
      x = r_instantaneous * cos(theta)
      y = r_instantaneous * sin(theta)

      p1 = pose_trans(p_center, p[x, y, 0, 0, 0, 0])
      movel(p1, a = grind_accel_mpss, v = grind_speed_mps, r = grind_blend_radius_m)
      i = i + 1
    end

    grind_cycle = grind_cycle + 1
    # Next cycle- swap diameters so we go in/out/in etc.
    old_circle1_radius_m = circle1_radius_m
    circle1_radius_m = circle2_radius_m
    circle2_radius_m = old_circle1_radius_m
  end
end

def pattern_spiral_cylinder(p_center, circle1_diam_m, circle2_diam_m, n_spirals, cylinder_radius_m, n_cycles):
  # Local calculations
  max_diam_m = max(circle1_diam_m, circle2_diam_m)
  n_points = recommend_npoints(max_diam_m, grind_blend_radius_m)
  n_total_points = n_spirals * n_points
  circle1_radius_m = circle1_diam_m / 2.0
  circle2_radius_m = circle2_diam_m / 2.0
  speed_factor = 0.5 / robot_part_geometry[1]

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    rslope = (circle2_radius_m - circle1_radius_m) / n_total_points
    i = 0
    while ok_to_proceed() and i <= n_total_points:
      theta = d2r(180.0 + 360.0 * (i % n_points) / n_points)
      r_instantaneous = i * rslope + circle1_radius_m
      x = r_instantaneous * cos(theta)
      y = r_instantaneous * sin(theta)
      rx = 2.0 * y / cylinder_radius_m

      p1 = pose_trans(p_center, p[x, 0, 0, rx, 0, 0])

      # Speed_factor needs to be applied when running radially, and needs to be 1.0 when running laterally. This smooths it all the way around!
      this_speed_factor = (speed_factor - 1) * abs(cos(theta)) + 1.0
      movel(p1, a = grind_accel_mpss * this_speed_factor, v = grind_speed_mps * this_speed_factor, r = grind_blend_radius_m * this_speed_factor)
      i = i + 1
    end

    grind_cycle = grind_cycle + 1
    # Next cycle- swap diameters so we go in/out/in etc.
    old_circle1_radius_m = circle1_radius_m
    circle1_radius_m = circle2_radius_m
    circle2_radius_m = old_circle1_radius_m
  end
end

def pattern_spiral_sphere(p_center, circle1_diam_m, circle2_diam_m, n_spirals, sphere_diam_m, n_cycles):
  # Local calculations
  max_diam_m = max(circle1_diam_m, circle2_diam_m)
  n_points = recommend_npoints(max_diam_m, grind_blend_radius_m)
  n_total_points = n_spirals * n_points
  circle1_radius_m = circle1_diam_m / 2.0
  circle2_radius_m = circle2_diam_m / 2.0
  sphere_radius_m = sphere_diam_m / 2.0

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    rslope = (circle2_radius_m - circle1_radius_m) / n_total_points
    i = 0
    while ok_to_proceed() and i <= n_total_points:
      theta = d2r(180.0 + 360.0 * (i % n_points) / n_points)
      r_instantaneous = i * rslope + circle1_radius_m
      x = r_instantaneous * cos(theta)
      rx = x / sphere_radius_m
      y = r_instantaneous * sin(theta)
      ry = y / sphere_radius_m

      p1 = pose_trans(p_center, p[0, 0, 0, rx, ry, 0])
      movel(p1, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, r = grind_rot_blend_radius_rad)
      i = i + 1
    end

    grind_cycle = grind_cycle + 1
    # Next cycle- swap diameters so we go in/out/in etc.
    old_circle1_radius_m = circle1_radius_m
    circle1_radius_m = circle2_radius_m
    circle2_radius_m = old_circle1_radius_m
  end
end
