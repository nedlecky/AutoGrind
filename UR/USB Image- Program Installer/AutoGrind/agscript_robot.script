# File: agscript_robot.cs
# Project: AutoGrind
# Author: Ned Lecky, Olympus Controls
# Purpose: Robot control commands supporting the AutoGrind application

global response = "unknown"
global robot_index = 0
global robot_checkvalue = 0

global robot_linear_speed_mps = 0.2
global robot_linear_accel_mpss = 0.4
global robot_blend_radius_m = 0.003
global robot_joint_speed_rps = 1.0
global robot_joint_accel_rpss = 4.0
global robot_tcp = p[0, 0, 0.175, 0, 0, 0]
global robot_tcp_part = robot_tcp
global robot_payload_mass_kg = 1.0
global robot_payload_cog_m = [0, 0, 0.50]
# Geometry [1=FLAT 2=CYL 3=SPHERE, diameter_mm)
global robot_part_geometry = [0, 0]
global robot_door_closed_input = [-1, -1]
global robot_footswitch_pressed_input = [-1, -1]
global robot_tool_on_outputs = [-1, -1, -1, -1, -1, -1, -1, -1]
global robot_tool_off_outputs = [-1, -1, -1, -1, -1, -1, -1, -1]
global robot_coolant_on_outputs = [-1, -1, -1, -1, -1, -1, -1, -1]
global robot_coolant_off_outputs = [-1, -1, -1, -1, -1, -1, -1, -1]
global robot_freedrive_mode = 0

# Defaults get set on load... and can be queried (or changed) from C#
set_tcp(robot_tcp)
set_payload(robot_payload_mass_kg, robot_payload_cog_m)
set_gravity([0.0, 0.0, 9.82])

# command should be[nElements,index,checkval,param[0],param[1],...]
# put index into robot_index
# validate checkval
# Remove both from command so we get command = [nElements-2, param[0], param[1],...]
def command_validate():
  # must be at least index, check, and 1 param
  if command[0] < 3:
    command[0] = 0
    return False
  end

  # Now make sure checksum matches what we expect
  global test_index = command[1]
  global test_checksum = command[2]
  if test_checksum != 1000 - test_index:
    command[0] = 0
    return False
  end

  # Now if we are still in the grind state and we are not getting a grind command (40) make sure we're are off the part!
  if grind_process_state and command[3] != 40:
    # Using set_grind_process_state which assumes robot_tcp_part!
    set_tcp(robot_tcp_part)
    set_grind_process_state(False)
    set_tcp(robot_tcp)
  end

  # Slide the robot commands and parameters back in command[] to remove the index and checksum
  local i = 3
  while (i < command[0] + 1):
    command[i-2] = command[i]
    i = i + 1
  end
  command[i-1] = 0
  command[i-2] = 0
  command[0] = command[0] - 2    # 2 fewer elements in the array now!

  global robot_index = test_index
  return True
end

# Call this when starting command execution
def command_start():
  global last_comand = command

  # This one signifies we're starting a new command!
  global robot_starting = robot_index
  socket_set_var("robot_starting", robot_starting)
  socket_send_line("robot_ready=False")
end

# Call this when a command is complete
def command_finish():
  local retval = "robot_response=" + response + "#robot_ready=True"
  socket_send_line(retval)

  global robot_completed = robot_index
  socket_set_var("robot_completed", robot_completed)
end

# Set variable interface. Interprets command[2] to select what to set and returns result to socket
# Can also be used for validation and enforcing limits
def set_variable():
  if command[2] == 1:
    # Set speed to s if s>0. Always returns current value
    s = command[3]
    if s > 0:
      robot_linear_speed_mps = s / 1000.0
    end
    socket_set_var("robot_linear_speed_mmps", robot_linear_speed_mps * 1000.0)
    global response = "set_linear_speed()"
  elif command[2] == 2:
    # Set accel to a if a>0. Always returns current value
    a = command[3]
    if a > 0:
      robot_linear_accel_mpss = a / 1000.0
    end
    socket_set_var("robot_linear_accel_mmpss", robot_linear_accel_mpss * 1000.0)
    global response = "set_linear_accel()"
  elif command[2] == 3:
    # Set blend to b if b>=0. Always returns current value
    b = command[3]
    if b >= 0:
      robot_blend_radius_m = b / 1000.0
    end
    socket_set_var("robot_blend_radius_mm", robot_blend_radius_m * 1000.0)
    global response = "set_blend_radius()"
  elif command[2] == 4:
    # Set joint speed to s if s>0. Always returns current value
    s = command[3]
    if s > 0:
      robot_joint_speed_rps = d2r(s)
    end
    socket_set_var("robot_joint_speed_dps", r2d(robot_joint_speed_rps))
    global response = "set_joint_speed()"
  elif command[2] == 5:
    # Set joint accel to a if a>0. Always returns current value
    a = command[3]
    if a > 0:
      robot_joint_accel_rpss = d2r(a)
    end
    socket_set_var("robot_joint_accel_dpss", r2d(robot_joint_accel_rpss))
    global response = "set_joint_accel()"
  elif command[2] == 6:
    # Set part_geometry to [shape, diameter_mm] if shape==1,2,3. Always returns "robot_part_geometry=[current geometry]"
    # Also updates robot_part_tcp using update_robot_tcp_part
    shape = command[3]
    if shape == 1:
      robot_part_geometry = [1, 0]
    elif shape == 2 or shape == 3:
      diameter_mm = limiter(command[4], 50, 3000)
      robot_part_geometry = [shape, diameter_mm]
    end

    update_robot_tcp_part()

    socket_send_string("robot_part_geometry=")
    return_vector(robot_part_geometry, 2)
    socket_send_lf()
    global response = "set_part_geometry()"
  elif command[2] == 10:
    # Set door closed input
    if command[3] >= 0:
      robot_door_closed_input[0] = command[3]
      robot_door_closed_input[1] = command[4]
    end

    socket_send_string("robot_door_closed_input=")
    return_vector(robot_door_closed_input, 2)
    socket_send_lf()
    socket_set_var("robot_door_closed", is_door_closed())
    global response = "set_door_closed_input()"
  elif command[2] == 11:
    # Set tool on output
    robot_tool_on_outputs = command_3_padded_8(command)

    socket_send_string("robot_tool_on_outputs=")
    return_vector(robot_tool_on_outputs, 8)
    socket_send_lf()
    global response = "set_tool_on_outputs()"
  elif command[2] == 12:
    # Set tool off output
    robot_tool_off_outputs = command_3_padded_8(command)

    socket_send_string("robot_tool_off_outputs=")
    return_vector(robot_tool_off_outputs, 8)
    socket_send_lf()
    global response = "set_tool_off_outputs()"
  elif command[2] == 13:
    # Set coolant on output
    robot_coolant_on_outputs = command_3_padded_8(command)

    socket_send_string("robot_coolant_on_outputs=")
    return_vector(robot_coolant_on_outputs, 8)
    socket_send_lf()
    global response = "set_coolant_on_outputs()"
  elif command[2] == 14:
    # Set coolant off output
    robot_coolant_off_outputs = command_3_padded_8(command)

    socket_send_string("robot_coolant_off_outputs=")
    return_vector(robot_coolant_off_outputs, 8)
    socket_send_lf()
    global response = "set_coolant_off_outputs()"
  elif command[2] == 15:
    # tool_on
    tool_power(True, 2)
    global response = "tool_on()"
  elif command[2] == 16:
    # tool_off
    tool_power(False, 2)
    global response = "tool_off()"
  elif command[2] == 17:
    # coolant_on
    coolant_flow(True, 2)
    global response = "coolant_on()"
  elif command[2] == 18:
    # coolant_off
    coolant_flow(False, 2)
    global response = "coolant_off()"
  elif command[2] == 19:
    # freedrive 1=on/0=off, 0=base|1=tcp|2=tcp_part, 6 axisEnables
    if command[3] == 0:
      end_freedrive_mode()
      set_tcp(robot_tcp)
      robot_freedrive_mode = 0
      socket_set_var("robot_freedrive_mode", robot_freedrive_mode)
    else:
      local coordSys = command[4]
      local freeAxes = [command[5], command[6], command[7], command[8], command[9], command[10]]
      if coordSys == 1:
        set_tcp(robot_tcp)
        freedrive_mode(freeAxes = freeAxes, feature = "tool")
      elif coordSys == 2:
        set_tcp(robot_tcp_part)
        freedrive_mode(freeAxes = freeAxes, feature = "tool")
      else:
        # Base
        freedrive_mode(freeAxes = freeAxes)
      end
      robot_freedrive_mode = 1
      socket_set_var("robot_freedrive_mode", robot_freedrive_mode)
    end
    global response = "freedrive_mode()"
  elif command[2] == 20:
    # set_tcp if command[3] > -10. Always returns robot_tcp=p[...]
    if command[3] > -10:
      robot_tcp = p[command[3], command[4], command[5], command[6], command[7], command[8]]
      set_tcp(robot_tcp)
    end
    return_pose("robot_tcp", get_tcp_offset())
    # Recompute robot_tcp_part based on current geometry
    update_robot_tcp_part()
    global response = "set_tcp()"
  elif command[2] == 21:
    # set_payload if command[3] > 0. Always return robot_m and robot_cog
    if command[3] > 0:
      robot_payload_mass_kg = command[3]
      robot_payload_cog_m = [command[4], command[5], command[6]]
      set_payload(robot_payload_mass_kg, robot_payload_cog_m)
    end
    socket_set_var("robot_payload_mass_kg", robot_payload_mass_kg)
    socket_send_string("robot_payload_cog_m=")
    return_vector(robot_payload_cog_m, 3)
    socket_send_lf()
    global response = "set_payload()"
  elif command[2] == 22:
    # Set footswitch pressed input
    if command[3] >= 0:
      robot_footswitch_pressed_input[0] = command[3]
      robot_footswitch_pressed_input[1] = command[4]
    end

    socket_send_string("robot_footswitch_pressed_input=")
    return_vector(robot_footswitch_pressed_input, 2)
    socket_send_lf()
    socket_set_var("robot_footswitch_pressed", is_footswitch_pressed())
    global response = "set footswitch_pressed_input()"
elif command[2] == 30:
    # set_output
    local out = command[3]
    local state = command[4]>0
    set_digital_out(out,state)
    global response = "set_output()"
  else:
    global response = "set_variable ERROR"
  end
end

# Compute appropriate robot_tcp for the part based on robot_tcp and robot_part_geometry
# They're the same for flat parts, but the TCP is adjusted to the center of the cylinder or sphere
def update_robot_tcp_part():
  shape = robot_part_geometry[0]
  if shape == 1:  # Flat
    robot_tcp_part = robot_tcp
  else:  # Cylinder or Sphere
    robot_tcp_part = pose_trans(robot_tcp, p[0, 0, robot_part_geometry[1] / 2000.0, 0, 0, 0])
  end
  return_pose("robot_tcp_part", robot_tcp_part)
end

# Send get_tcp_offset() result to socket
def return_tcp_offset():
  p = get_tcp_offset()
  return_pose("tcp_offset", p)
  global response = "return_tcp_offset()"
end

# Send get_actual_tcp_pose() to socket
def return_actual_tcp_pose():
  p = get_actual_tcp_pose()
  return_pose("actual_tcp_pose", p)
  global response = "return_actual_tcp_pose()"
end

# Send get_actual_joint_positions() to socket
def return_get_actual_joint_positions():
  p = get_actual_joint_positions()
  return_joints("actual_joint_positions", p)
  global response = "return_get_actual_joint_positions()"
end

# Send both joints and pose to socket labeled position_p and position_q
def return_both_positions():
  return_joints("position_q", get_actual_joint_positions())
  return_pose("position_p", get_actual_tcp_pose())
  global response = "return_both_positions()"
end

# Movel relatively in base coordinates
def movel_relative_base(p1):
  local p0 = get_actual_tcp_pose()
  local p2 = pose_add(p0, p1)
  if p1[0] == 0 and p1[1] == 0 and p1[2] == 0:  # Rotational move
    movel(p2, robot_joint_accel_rpss, robot_joint_speed_rps)
  else:
    movel(p2, robot_linear_accel_mpss, robot_linear_speed_mps)
  end
  global response = "movel_relative_base()"
end

# Movel relatively in TCP coordinates
def movel_relative_tcp(p1):
  local p2 = pose_trans(get_forward_kin(), p1)
  if p1[0] == 0 and p1[1] == 0 and p1[2] == 0:  # Rotational move
    movel(p2, robot_joint_accel_rpss, robot_joint_speed_rps)
  else:
    movel(p2, robot_linear_accel_mpss, robot_linear_speed_mps)
  end
  global response = "movel_relative_tcp()"
end

# Movel relatively in TCP_part coordinates
def movel_relative_tcp_part(p1):
  set_tcp(robot_tcp_part)
  local p2 = pose_trans(get_forward_kin(), p1)
  if p1[0] == 0 and p1[1] == 0 and p1[2] == 0:  # Rotational move
    movel(p2, robot_joint_accel_rpss, robot_joint_speed_rps)
  else:
    movel(p2, robot_linear_accel_mpss, robot_linear_speed_mps)
  end
  set_tcp(robot_tcp)
  global response = "movel_relative_tcp_part()"
end

# Change one element of current pose and movel there
def movel_one_only(index = 0, val = 0):
  local p = get_actual_tcp_pose()
  p[index] = val
  if index < 3:  # Translational
    movel(p, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
  else:
    movel(p, a = robot_joint_accel_rpss, v = robot_joint_speed_rps)
  end
  global response = "movel_one_only()"
end

# Change only rotation elements of current pose and movel there
def movel_rot_only(r1 = 0, r2 = 0, r3 = 0):
  local p = get_actual_tcp_pose()
  p[3] = r1
  p[4] = r2
  p[5] = r3
  movel(p, a = robot_joint_accel_rpss, v = robot_joint_speed_rps)
  global response = "movel_rot_only()"
end

# Movej to position (works with joints or poses)
def movej_ag(p):
  movej(p, a = robot_joint_accel_rpss, v = robot_joint_speed_rps)
  global response = "movej_ag()"
end

# Movel to position (works with joints or poses)
def movel_ag(p):
  movel(p, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
  global response = "movel_ag()"
end

# ####################################################################################
# Interrupting Motion
# Motion and force_mode and part contact muct all end if any of 3 things happen
#  1) Door is opened
#  2) We're in contact with the part and grinding, but no grind command comes within some time (default 1.5s)
#  3) We receive an abort message from the host
#
# How is it implemented?
#
# 1) io_monitor_thread (below) is ALWAYS running. Fires every time_door_check_rate_s (0.25s)
#    - Whenever it sees the state of the door change, it sends SET robot_door_closed state to host
#    - Whenever it sees the state of the footswitch (DIN7) change, it sends SET robot_footswitch state to host
#    - It monitors if we're still in contact wth the part butr not grinding (grind_process_state and grind_ready)
#      - If that goes beyond grind_max_wait_ms it sets halt_grind=True
# 2) no_command function (below). Called by PolScript everyu time it's waiting for a command and doesn't get one with a second
#    - If halt_grind is set (by door monitor thread above)
#      - stopl and simulate receiving a grind_retract
#      - THIS FORCES THE force_off and motion commands to come from the primary thread, as they must
# 3) listener_thread started by grind()
#    - This runs only while a grind is in progress
#    - It listens for commands from the host since PolyScope is blocked
#    - Any command received increments halt_count which makes ok_to_proceed() false
#    - That is checked in all the grinding programs and forces them to finish up and get off the part in an orderly fashion

# ####################################################################################
# START AUTOMATED DOOR MONITORING THREAD
#
# Return True if door in closed state (or if door input is undefined)
def is_door_closed():
  if robot_door_closed_input[0] < 0:
    return True
  end
  if get_standard_digital_in(robot_door_closed_input[0]):
    f = 1
  else:
    f = 0
  end
  return f == robot_door_closed_input[1]
end

# Would be nice to have this din programmable like door_closed above! TODO
def is_footswitch_pressed():
  if robot_footswitch_pressed_input[0] < 0:
    return False
  end
  if get_standard_digital_in(robot_footswitch_pressed_input[0]):
    f = 1
  else:
    f = 0
  end
  return f == robot_footswitch_pressed_input[1]
end

global robot_door_closed = is_door_closed()
global robot_footswitch_pressed = is_footswitch_pressed()
global time_in_uncommanded_grind = 0
global time_door_check_rate_s = 0.250
global grind_max_wait_ms = 1500
# Also monitors footswitch!
thread io_monitor_thread():
  # Send current state on start... in future will only be sent on change
  socket_set_var("robot_door_closed", robot_door_closed)
  socket_set_var("robot_footswitch_pressed", robot_footswitch_pressed)
  
  while True:
    sleep(time_door_check_rate_s)
    local new_door_closed = is_door_closed()
    local new_footswitch_pressed = is_footswitch_pressed()

    # Notify host if door state has changed
    if robot_door_closed != new_door_closed:
      robot_door_closed = new_door_closed
      socket_set_var("robot_door_closed", robot_door_closed)
    end

    # Notify host if footswitch state has changed
    if robot_footswitch_pressed != new_footswitch_pressed:
      robot_footswitch_pressed = new_footswitch_pressed
      socket_set_var("robot_footswitch_pressed", robot_footswitch_pressed)
    end

    # Check for still in grind process but not executing a grind command
    # This is what happens after a grind_...(....,1) executes while waiting for next command
    if grind_process_state and grind_ready:
      time_in_uncommanded_grind = time_in_uncommanded_grind + time_door_check_rate_s
      # No new grind commands for grind_max_wait_ms... schedule a grind_retract!
      if time_in_uncommanded_grind > grind_max_wait_ms / 1000.0:
        global halt_grind = True
      end
    else:
      time_in_uncommanded_grind = 0
    end
  end
end
global ioMonitorThread = run io_monitor_thread()
#
# END AUTOMATED DOOR MONITORING THREAD
# ####################################################################################

# ####################################################################################
# START NO_COMMAND HOUSEKEEPING
# This gets called when the PolyScope receives no command (about 1/second)
# We can fire off any command here safely since no others will be seen until we exit
#
global no_command_count = 0
global halt_grind = False
def no_command():
  global no_command_count = no_command_count + 1

  if grind_process_state and grind_ready and halt_grind:
    halt_grind = False
    stopl(20)

    set_tcp(robot_tcp_part)
    set_grind_process_state(False)
    set_tcp(robot_tcp)
  end
end
#
# END NO_COMMAND HOUSEKEEPING
# ####################################################################################

######################################################################################
# movel_int  Segmented (interruptable) movel
#
global grind_distance_m = 0
def movel_int(p, a = 1.2, v = 0.25, t = 0, r = 0, t_move = 1):
  local p0 = get_target_tcp_pose()
  # Chugging on CYL 80 lines and rects at 4Hz
  # Generate 10 points per second
  global grind_n_segments = 1#limiter(ceil(t_move * 10.0), 1, 1000)

  i = 1
  while i <= grind_n_segments and ok_to_proceed():
    local p1 = interpolate_pose(p0, p, i / grind_n_segments)
    movel(p1, a = a, v = v, r = r)
    i = i + 1
  end
  return None
end
#
# Movel_int  Segmented (interruptable) movel
######################################################################################

# ####################################################################################
# START TOUCHOFF HANDLER
#
def calculate_point_to_move_towards(feature, direction, position_distance):
  local posDir = [direction[0], direction[1], direction[2]]
  if (norm(posDir) < 1e-6):
    return get_target_waypoint()
  end
  local direction_vector_normalized = normalize(posDir)
  local displacement_pose = p[direction_vector_normalized[0] * position_distance, direction_vector_normalized[1] * position_distance, direction_vector_normalized[2] * position_distance, 0, 0, 0]
  local wanted_displacement_in_base_frame = pose_sub(pose_trans(feature, displacement_pose), feature)
  return pose_add(get_target_waypoint(), wanted_displacement_in_base_frame)
end
#$ 7 "Robot Program"
#$ 8 "MoveL"
#$ 9 "Direction: Tool Z+"
global move_thread_flag = 0
global move_thread_approach_speed_mps = 0.01
thread move_thread():
  enter_critical
  move_thread_flag = 1
  local towardsPos = calculate_point_to_move_towards(get_forward_kin(), [0.0, 0.0, 1.0], 0.025)
  movel(towardsPos, a = 0.5, v = move_thread_approach_speed_mps)
  move_thread_flag = 2
  exit_critical
end
# Currently using speed_mmps for both approach and 2X for departure
def touchoff(approach_speed_mmps, retract_mm):
  approach_speed_mps = approach_speed_mmps / 1000.0
  global move_thread_approach_speed_mps = approach_speed_mps

  retract_speed_mps = approach_speed_mps * 2.0

  retract_m = retract_mm / 1000.0

  move_thread_flag = 0
  move_thread_han = run move_thread()
  while (True):
    local targetTcpDirection = get_target_tcp_speed()
    local stepsToRetract = tool_contact(direction = targetTcpDirection)
    if (stepsToRetract > 0):
      kill move_thread_han
      stopl(20)
      local backTrackMovement = get_actual_joint_positions_history(stepsToRetract)
      local contactPose = get_forward_kin(backTrackMovement)
      local posDir = [targetTcpDirection[0], targetTcpDirection[1], targetTcpDirection[2]]
      local retractTo = contactPose
      if (norm(posDir) > 1e-6):
        local normalizedPosDir = normalize(posDir)
        local additionalRetraction = p[normalizedPosDir[0] * retract_m, normalizedPosDir[1] * retract_m, normalizedPosDir[2] * retract_m, 0, 0, 0]
        retractTo = pose_sub(contactPose, additionalRetraction)
      end
      movel(retractTo, a = 1.0, v = retract_speed_mps)
      #$ 10 "Until (tool_contact_detection)"
      return True
      break
    end
    sleep(1.0E-10)
    if (move_thread_flag > 1):
      join move_thread_han
      #$ 11 "Until (distance)"
      #$ 12 "Popup: No part encountered"
      #popup("No part encountered", "Message", False, False, blocking = True)
      return False
      break
    end
    sync()
  end
  return False
end
#
# END TOUCHOFF HANDLER
# ####################################################################################
