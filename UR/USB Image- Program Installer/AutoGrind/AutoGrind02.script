def AutoGrind02():
  global _hidden_verificationVariable=0
  set_standard_analog_input_domain(0, 1)
  set_standard_analog_input_domain(1, 1)
  set_tool_analog_input_domain(0, 1)
  set_tool_analog_input_domain(1, 1)
  set_analog_outputdomain(0, 1)
  set_analog_outputdomain(1, 1)
  set_input_actions_to_default()
  set_standard_digital_input_action(7, "freedrive")
  set_runstate_standard_digital_outputs([0,2,3,4,5,6])
  set_runstate_standard_digital_output_to_value(0, 4)
  set_runstate_standard_digital_output_to_value(1, 5)
  set_runstate_standard_digital_output_to_value(2, 4)
  set_runstate_standard_digital_output_to_value(3, 4)
  set_runstate_standard_digital_output_to_value(4, 4)
  set_runstate_standard_digital_output_to_value(5, 4)
  set_runstate_standard_digital_output_to_value(6, 4)
  set_tcp(p[0.0,0.0,0.175,0.0,0.0,0.0])
  set_safety_mode_transition_hardness(1)
  set_gravity([0.0, 0.0, 9.82])
  set_tool_communication(True, 115200, 0, 1, 1.5, 3.5)
  set_tool_output_mode(0)
  set_tool_digital_output_mode(0, 1)
  set_tool_digital_output_mode(1, 1)
  set_tool_voltage(24)
  set_target_payload(0.980000, [0.000000, 0.002000, 0.048000], [0.001488, 0.001488, 0.001488, 0.000000, 0.000000, 0.000000])
  step_count_7504798e_ae26_4d2b_9a9f_36c0432be193 = 0.0
  thread Step_Counter_Thread_e3e4ee0a_b5ec_4210_9378_0838cdee929b():
    while (True):
      step_count_7504798e_ae26_4d2b_9a9f_36c0432be193 = step_count_7504798e_ae26_4d2b_9a9f_36c0432be193 + 1.0
      sync()
    end
  end
  run Step_Counter_Thread_e3e4ee0a_b5ec_4210_9378_0838cdee929b()
  # begin: URCap Installation Node
  #   Source: Robotiq_Grippers, 1.8.10.17249, Robotiq Inc.
  #   Type: Vacuum
  #################################################
  # Vacuum Grip Check
  #################################################
  
  vacuumGripCheckThread1 = 0
  vacuumGripCheckThread2 = 0
  vacuumGripCheckThread3 = 0
  vacuumGripCheckThread4 = 0
  vacuumGripCheckThread1Running = False
  vacuumGripCheckThread2Running = False
  vacuumGripCheckThread3Running = False
  vacuumGripCheckThread4Running = False
  vacuumGripCheckSocketId = "1"
  vacuumGripCheckThreadStarted = False
  
  thread vacuumGripCheck():
    gripper_socket = vacuumGripCheckSocketId
    vacuumGripCheckThreadStarted = True
  
    while (True):
      objectDetectedDebounceCtr = 0
  
      while (objectDetectedDebounceCtr < 3):
        if(rq_is_vacuum_obj_detected(gripper_socket="1")):
          objectDetectedDebounceCtr = objectDetectedDebounceCtr + 1
        else:
          objectDetectedDebounceCtr = 0
        end
        sleep(0.1)
      end
  
      objectNotDetectedDebounceCtr = 0
  
      while objectNotDetectedDebounceCtr < 3:
        if (not rq_is_vacuum_obj_detected(gripper_socket="1")):
          objectNotDetectedDebounceCtr = objectNotDetectedDebounceCtr + 1
        else:
          objectNotDetectedDebounceCtr = 0
        end
        sleep(0.1)
      end
  
      socket_open("127.0.0.1",29999,"dashboardServerSocket")
      socket_send_line("pause","dashboardServerSocket")
      socket_send_string("popup Vacuum grip check has detected an object drop.", "dashboardServerSocket")
      socket_send_byte(10, "dashboardServerSocket")
      socket_close("dashboardServerSocket")
  
      sleep(0.008)
    end
  end
  
  def startVacuumGripCheckThread(gripperId="1"):
    vacuumGripCheckSocketId = gripperId
    threadHandle = run vacuumGripCheck()
    waitForVacuumGripCheckThreadStarted()
    return threadHandle
  end
  
  def stopVacuumGripCheckThread(threadHandle):
    kill threadHandle
  end
  
  def waitForVacuumGripCheckThreadStarted():
    while (not(vacuumGripCheckThreadStarted)):
      sleep(0.008)
    end
    vacuumGripCheckThreadStarted = False
  end
  #################################################
  # End - Vacuum Grip Check
  #################################################
  
  #################################################
  # Stops the pump on a distance travelled
  #################################################
  global stopPumpDistance = 100
  global stopPumpSocketId = "0"
  global stopPumpThreadStarted = [False, False, False, False]
  global stopPumpThreadHandles = [0, 0, 0, 0]
  
  thread stopPumpOnDistanceTravelled():
    distance = stopPumpDistance
    socketId = stopPumpSocketId
    stopPumpThreadStarted[rq_socket_to_index(socketId)] = True
  
    measuredDistance = waitForDistanceTravelled(distance)
  
    rq_stop(socketId)
  
    stopPumpThreadStarted[rq_socket_to_index(socketId)] = False
  end
  
  def waitForDistanceTravelled(distance):
    startingPose = get_actual_tcp_pose()
    measuredDistance = 0
    while (measuredDistance < distance):
      sleep(0.1)
      measuredDistance = point_dist(get_actual_tcp_pose(), startingPose)
    end
  
    return measuredDistance
  end
  
  def startStopPumpOnDistanceTravelledThread(distance, gripper_socket="1"):
    if (stopPumpThreadStarted[rq_socket_to_index(gripper_socket)]):
      return 0
    end
  
    global stopPumpDistance = distance
    global stopPumpSocketId = gripper_socket
    stopPumpThreadHandles[rq_socket_to_index(gripper_socket)] = run stopPumpOnDistanceTravelled()
    waitForStopPumpOnDistanceTravelledThreadStarted(gripper_socket)
    return stopPumpThreadHandles[rq_socket_to_index(gripper_socket)]
  end
  
  def waitForStopPumpOnDistanceTravelledThreadStarted(gripper_socket="1"):
    while (not(stopPumpThreadStarted[rq_socket_to_index(gripper_socket)])):
      sleep(0.008)
    end
  end
  
  def stopStopPumpOnDistanceTravelledThread(gripper_socket="1"):
    handle = stopPumpThreadHandles[rq_socket_to_index(gripper_socket)]
    threadIsRunning = stopPumpThreadStarted[rq_socket_to_index(gripper_socket)]
    if (threadIsRunning):
      kill handle
      clear_socket_buffer(gripper_socket, 0.01)
      stopPumpThreadHandles[rq_socket_to_index(gripper_socket)] = 0
    end
  end
  #################################################
  # End - Stops the pump on a distance travelled
  #################################################
  
  #################################################
  # Vacuum general functions
  #################################################
  def rq_wait_for_vacuum_object_detected(gripper_socket="1"):
      while (not rq_is_vacuum_obj_detected(gripper_socket)):
          if (rq_is_vacuum_timeout(gripper_socket)):
              return False
          end
          sleep(0.008)
      end
      return True
  end
  
  def rq_wait_for_vacuum_object_secured(gripper_socket="1"):
      while (not rq_is_vacuum_obj_secured(gripper_socket)):
          if (rq_is_vacuum_timeout(gripper_socket)):
              return False
          end
          sleep(0.008)
      end
      return True
  end
  
  def rq_wait_for_vacuum_object_suction_complete(gripper_socket="1"):
      remaining_retries = 50
  
       # Wait for suction started
      while (not rq_is_vacuum_obj_in_suction(gripper_socket) and
             not rq_is_vacuum_obj_detected(gripper_socket) and
             remaining_retries > 0):
          sleep(0.01)
          remaining_retries = remaining_retries - 1
      end
  
      # Wait for suction completed
      while (rq_is_vacuum_obj_in_suction(gripper_socket)):
          if (rq_is_vacuum_timeout(gripper_socket)):
              return False
          end
          sleep(0.01)
      end
  
      return True
  end
  
  def rq_wait_for_vacuum_object_not_detected(gripper_socket="1"):
      while (rq_is_vacuum_obj_detected(gripper_socket)):
          sleep(0.01)
      end
  end
  
  def rq_is_vacuum_obj_detected(gripper_socket="1"):
      gOBJ = rq_get_var("OBJ", 1, gripper_socket)
      sleep(0.008)
      return is_vacuum_OBJ_object_detected(gOBJ)
  end
  
  def rq_is_vacuum_obj_secured(gripper_socket="1"):
      gOBJ = rq_get_var("OBJ", 1, gripper_socket)
      sleep(0.008)
      return is_vacuum_OBJ_object_secured(gOBJ)
  end
  
  def rq_is_vacuum_obj_in_suction(gripper_socket="1"):
      gOBJ = rq_get_var("OBJ", 1, gripper_socket)
      sleep(0.008)
  
      if(is_vacuum_OBJ_object_in_motion(gOBJ)):
          return True
      else:
          return False
      end
  end
  
  def rq_is_vacuum_timeout(gripper_socket="1"):
      gFLT = rq_get_var("FLT", 2, gripper_socket)
      sleep(0.008)
  
      if(gFLT ==6):
          return True
      end
  
      return False
  end
  
  def is_vacuum_OBJ_object_in_motion(gOBJ):
      if (gOBJ == 0):
          return True
      end
  
      return False
  end
  
  def is_vacuum_OBJ_object_detected(gOBJ):
      if (gOBJ == 1 or gOBJ == 2):
          return True
      end
  
      return False
  end
  
  def is_vacuum_OBJ_object_secured(gOBJ):
      if (gOBJ == 2):
          return True
      end
  
      return False
  end
  
  def rq_set_pressure_timeout_minimum_vacuum(pressure, timeout, minimum, gripper_socket="1"):
      rq_set_pos_spd_for(pressure, timeout, minimum, gripper_socket)
  end
  
  def rq_set_vacuum_and_wait(pressure, timeout, minimum, mode, gripper_socket="1"):
      rq_set_pressure_timeout_minimum_vacuum(pressure, timeout, minimum, gripper_socket)
      gPRE = rq_get_var("PRE", 3, gripper_socket)
      while (gPRE != pressure):
          rq_set_pressure_timeout_minimum_vacuum(pressure, timeout, minimum, gripper_socket)
          sleep(0.008)
          gPRE = rq_get_var("PRE", 3, gripper_socket)
      end
  
      rq_set_gripper_mode(mode, gripper_socket)
      gMOD = rq_get_var("MOD", 3, gripper_socket)
      while (gMOD != mode):
          rq_set_gripper_mode(mode, gripper_socket)
          sleep(0.008)
          gMOD = rq_get_var("MOD", 3, gripper_socket)
     end
  end
  
  def is_FLT_vacuum_timeout(gFLT):
    if (gFLT == 6):
        return True
    end
  
    return False
  end
  
  def is_continuous_grip(maximum_vacuum):
    return maximum_vacuum == 0
  end
  
  def rq_vacuum_release(advanced_mode=False, shutoff_distance_cm=5, wait_for_object_released=True, gripper_socket="1"):
    local shutoff_distance = scale(shutoff_distance_cm, [0, 99], [0.00, 0.99])
    local pressure = 255
    local minimum = 0
    local timeout = 255
    rq_vacuum_release_raw(advanced_mode, pressure, minimum, timeout, shutoff_distance, wait_for_object_released, gripper_socket)
  end
  
  def rq_vacuum_release_raw(advanced_mode, pressure, minimum, timeout, shutoff_distance, wait_for_object_released, gripper_socket):
    rq_reset_fault_and_activate(gripper_socket)
  
    if advanced_mode:
      rq_set_vacuum_and_wait(pressure, timeout, minimum, 1, gripper_socket)
    else:
      rq_set_vacuum_and_wait(pressure, timeout, minimum, 0, gripper_socket)
    end
  
    # The following patch is for Robotiq's Camera issue when communication is lost, but not the activation
    # the communication driver reset the GTO bit
    rq_set_GTO_and_wait(1, gripper_socket)
  
    if wait_for_object_released:
      while (rq_is_vacuum_obj_detected(gripper_socket)):
  
        if advanced_mode:
          rq_set_vacuum_and_wait(pressure, timeout, minimum, 1, gripper_socket)
        else:
          rq_set_vacuum_and_wait(pressure, timeout, minimum, 0, gripper_socket)
        end
  
        # The following patch is for Robotiq's Camera issue when communication is lost, but not the activation
        # the communication driver reset the GTO bit
        rq_set_GTO_and_wait(1, gripper_socket)
        sleep(0.01)
      end
    end
  
    if advanced_mode:
      startStopPumpOnDistanceTravelledThread(shutoff_distance, gripper_socket)
    end
  end
  
  def rq_vacuum_grip(advanced_mode=False, maximum_vacuum=60, minimum_vacuum=40, timeout_ms=3000, wait_for_object_detected=True, gripper_socket="1"):
    local pressure = scale(maximum_vacuum, [0, 100], [100, 0])
    local minimum = scale(minimum_vacuum, [0, 100], [100, 0])
    local timeout = scale(timeout_ms, [0, 25500], [0, 255])
    rq_vacuum_grip_raw(advanced_mode, pressure, minimum, timeout, gripper_socket)
    if wait_for_object_detected:
          suction_completed = rq_wait_for_vacuum_object_suction_complete(gripper_socket)
          if(not suction_completed):
              rq_set_var("GTO", 0, gripper_socket)
          end
    end
  end
  
  def rq_vacuum_grip_raw(advanced_mode, pressure, minimum, timeout, gripper_socket):
    stopStopPumpOnDistanceTravelledThread(gripper_socket)
    rq_reset_fault_and_activate(gripper_socket)
  
    if advanced_mode:
      rq_set_vacuum_and_wait(pressure, timeout, minimum, 1, gripper_socket)
    else:
      rq_set_vacuum_and_wait(pressure, timeout, minimum, 0, gripper_socket)
    end
  
    rq_set_GTO_and_wait(1, gripper_socket)
  end
  
  def rq_reset_fault_and_activate(gripper_socket):
      gFLT = rq_get_var("FLT", 2, gripper_socket)
  
      if(not is_FLT_no_fault(gFLT)):
          if(is_FLT_vacuum_timeout(gFLT)):
              rq_set_GTO_and_wait(0, gripper_socket)
          elif(is_FLT_faulted(gFLT)):
              rq_set_GTO_and_wait(0, gripper_socket)
              rq_set_var("ACT", 1, gripper_socket)
          end
      elif(not rq_is_gripper_activated(gripper_socket)):
          rq_set_GTO_and_wait(0, gripper_socket)
          rq_set_var("ACT", 1, gripper_socket)
      end
  end
  #################################################
  # End - Vacuum general functions
  #################################################
  vacuumGripCheckWarningTitle = "Vacuum grip check"
  vacuumGripCheckWarningMessage = "Vacuum gripper object lost"
  vacuumGripTimeoutTitle = "Vacuum gripper fault"
  vacuumGripTimeoutMessage = "Grip has timed out"
  # end: URCap Installation Node
  # begin: URCap Installation Node
  #   Source: Robotiq_Grippers, 1.8.10.17249, Robotiq Inc.
  #   Type: Gripper
  rq_gripper_socket_ip_address = "127.0.0.1"
  rq_gripper_socket_port = 63352
  
  rq_comm_check_fail_counter = [0, 0, 0, 0]
  
  rq_read_act = [-1, -1, -1, -1]
  rq_read_gto = [-1, -1, -1, -1]
  rq_read_for = [-1, -1, -1, -1]
  rq_read_spe = [-1, -1, -1, -1]
  rq_read_obj = [-1, -1, -1, -1]
  rq_read_sta = [-1, -1, -1, -1]
  rq_read_flt = [-1, -1, -1, -1]
  rq_read_pos = [-1, -1, -1, -1]
  rq_read_pre = [-1, -1, -1, -1]
  rq_read_lbp = [-1, -1, -1, -1]
  rq_read_lrd = [-1, -1, -1, -1]
  rq_read_lbl = [-1, -1, -1, -1]
  rq_read_lgn = [-1, -1, -1, -1]
  rq_read_msc = [-1, -1, -1, -1]
  rq_read_mod = [-1, -1, -1, -1]
  rq_read_cou = [-1, -1, -1, -1]
  rq_read_ncy = [-1, -1, -1, -1]
  rq_read_dst = [-1, -1, -1, -1]
  rq_read_pco = [-1, -1, -1, -1]
  
  rq_string_initial_value = "N/A"
  
  rq_read_snu_1 = rq_string_initial_value
  rq_read_snu_2 = rq_string_initial_value
  rq_read_snu_3 = rq_string_initial_value
  rq_read_snu_4 = rq_string_initial_value
  
  rq_read_fwv_1 = rq_string_initial_value
  rq_read_fwv_2 = rq_string_initial_value
  rq_read_fwv_3 = rq_string_initial_value
  rq_read_fwv_4 = rq_string_initial_value
  
  rq_read_ver_1 = rq_string_initial_value
  rq_read_ver_2 = rq_string_initial_value
  rq_read_ver_3 = rq_string_initial_value
  rq_read_ver_4 = rq_string_initial_value
  
  rq_read_act_req = [True, True, True, True]
  rq_read_gto_req = [True, True, True, True]
  rq_read_for_req = [True, True, True, True]
  rq_read_spe_req = [True, True, True, True]
  rq_read_obj_req = [True, True, True, True]
  rq_read_sta_req = [True, True, True, True]
  rq_read_flt_req = [True, True, True, True]
  rq_read_pos_req = [True, True, True, True]
  rq_read_pre_req = [True, True, True, True]
  rq_read_lbp_req = [True, True, True, True]
  rq_read_lrd_req = [True, True, True, True]
  rq_read_lbl_req = [True, True, True, True]
  rq_read_lgn_req = [True, True, True, True]
  rq_read_msc_req = [True, True, True, True]
  rq_read_mod_req = [True, True, True, True]
  rq_read_cou_req = [True, True, True, True]
  rq_read_ncy_req = [True, True, True, True]
  rq_read_dst_req = [True, True, True, True]
  rq_read_pco_req = [True, True, True, True]
  
  rq_read_snu_1_req = False
  rq_read_snu_2_req = False
  rq_read_snu_3_req = False
  rq_read_snu_4_req = False
  
  rq_read_fwv_1_req = False
  rq_read_fwv_2_req = False
  rq_read_fwv_3_req = False
  rq_read_fwv_4_req = False
  
  rq_read_ver_1_req = False
  rq_read_ver_2_req = False
  rq_read_ver_3_req = False
  rq_read_ver_4_req = False
  
  rq_write_act_request = [False, False, False, False]
  rq_write_gto_request = [False, False, False, False]
  rq_write_atr_request = [False, False, False, False]
  rq_write_ard_request = [False, False, False, False]
  rq_write_pos_request = [False, False, False, False]
  rq_write_lbp_request = [False, False, False, False]
  rq_write_lrd_request = [False, False, False, False]
  rq_write_lbl_request = [False, False, False, False]
  rq_write_lgn_request = [False, False, False, False]
  rq_write_msc_request = [False, False, False, False]
  rq_write_mod_request = [False, False, False, False]
  
  rq_write_act = [-1, -1, -1, -1]
  rq_write_gto = [-1, -1, -1, -1]
  rq_write_atr = [-1, -1, -1, -1]
  rq_write_ard = [-1, -1, -1, -1]
  rq_write_for = [-1, -1, -1, -1]
  rq_write_spe = [-1, -1, -1, -1]
  rq_write_pos = [-1, -1, -1, -1]
  rq_write_lbp = [-1, -1, -1, -1]
  rq_write_lrd = [-1, -1, -1, -1]
  rq_write_lbl = [-1, -1, -1, -1]
  rq_write_lgn = [-1, -1, -1, -1]
  rq_write_msc = [-1, -1, -1, -1]
  rq_write_mod = [-1, -1, -1, -1]
  
  rq_write_act_previous = rq_write_act
  rq_write_gto_previous = rq_write_gto
  rq_write_atr_previous = rq_write_atr
  rq_write_ard_previous = rq_write_ard
  rq_write_for_previous = rq_write_for
  rq_write_spe_previous = rq_write_spe
  rq_write_pos_previous = rq_write_pos
  rq_write_lbp_previous = rq_write_lbp
  rq_write_lrd_previous = rq_write_lrd
  rq_write_lbl_previous = rq_write_lbl
  rq_write_lgn_previous = rq_write_lgn
  rq_write_msc_previous = rq_write_msc
  rq_write_mod_previous = rq_write_mod
  
  gripper_connected = [False, False, False, False]
  gripper_socket_open = [False, False, False, False]
  rq_comm_clear_socket_buffer_enabled = [True, True, True, True]
  rq_comm_check_counter = 0
  rq_gripper_communication_thread_started = False
  
  thread rq_gripper_communication():
      rq_comm_read_constants()
      rq_comm_read_variables()
      rq_comm_initialize_write_values()
  
      while(True):
          rq_comm_clear_socket_buffer()
          rq_comm_check()
          rq_comm_read_variables()
          rq_comm_write_variables()
  
          rq_gripper_communication_thread_started = True
          sleep(0.008)
      end
  end
  
  def rq_socket_to_index(gripper_socket="1"):
      # Patch in case gripper_socket is an integer
      gripper_socket_string = str_cat("", gripper_socket)
  
      if(gripper_socket_string == "1"):
          return 0
      elif(gripper_socket_string == "2"):
          return 1
      elif(gripper_socket_string == "3"):
          return 2
      elif(gripper_socket_string == "4"):
          return 3
      end
      return 0
  end
  
  def rq_index_to_socket(index=0):
      if(index == 0):
          return "1"
      elif(index == 1):
          return "2"
      elif(index == 2):
          return "3"
      elif(index == 3):
          return "4"
      end
      return "1"
  end
  
  def rq_comm_check():
      index = 0
      rq_comm_check_fail_counter_max = 99999
  
      if(rq_comm_check_counter < 50):
          rq_comm_check_counter = rq_comm_check_counter + 1
      else:
          rq_comm_check_counter = 0
  
          while(index <= 3):
              socket = rq_index_to_socket(index)
  
              if(gripper_connected[index]):
                  # Patch in case gripper_socket is an integer
                  gripper_socket_string = str_cat("", socket)
  
                  sid_list = rq_get_sid(socket)
                  is_gripper_in_sid_list = rq_is_gripper_in_sid_list(gripper_socket_string, sid_list)
  
                  if(is_gripper_in_sid_list):
                      rq_comm_check_fail_counter[index] = 0
                  else:
                      rq_comm_check_fail_counter[index] = rq_comm_check_fail_counter[index] + 1
                  end
  
                  if(rq_comm_check_fail_counter[index] > rq_comm_check_fail_counter_max):
                      message = str_cat("Communication lost with Robotiq's Gripper Slave ID ", gripper_socket_string)
                      popup(message, "Communication Error", False, True, True)
                  end
              end
              index = index + 1
          end
      end
  end
  
  def rq_init_comm_if_connected(gripper_sid=9, gripper_socket="1"):
      if(not is_gripper_socket_open(gripper_socket)):
        open_gripper_socket(gripper_socket)
      end
  
      socket_sid_set = rq_set_sid(gripper_sid, gripper_socket)
  
      if(socket_sid_set):
          # Patch in case gripper_socket is an integer
          gripper_socket_string = str_cat("", gripper_socket)
  
          sid_list = rq_get_sid(gripper_socket)
          is_gripper_in_sid_list = rq_is_gripper_in_sid_list(gripper_socket_string, sid_list)
  
          if(is_gripper_in_sid_list):
              rq_set_gripper_connected(gripper_socket_string)
              return True
          end
      end
  
      return False
  end
  
  def open_gripper_socket(gripper_socket="1"):
      is_open = socket_open(rq_gripper_socket_ip_address, rq_gripper_socket_port, gripper_socket)
      set_gripper_socket_open(gripper_socket, is_open)
  end
  
  def rq_close_gripper_socket(gripper_socket="1"):
      socket_close(gripper_socket)
      set_gripper_socket_open(gripper_socket, False)
      rq_set_gripper_connected(gripper_socket, False)
  end
  
  
  def is_gripper_socket_open(gripper_socket="1"):
      return gripper_socket_open[rq_socket_to_index(gripper_socket)]
  end
  
  def set_gripper_socket_open(gripper_socket, is_open):
      gripper_socket_open[rq_socket_to_index(gripper_socket)] = is_open
  end
  
  def rq_set_gripper_connected(gripper_socket="1", connected = True):
      gripper_connected[rq_socket_to_index(gripper_socket)] = connected
  end
  
  def rq_is_gripper_connected(gripper_id="1"):
      return gripper_connected[rq_socket_to_index(gripper_id)]
  end
  
  def rq_set_sid(gripper_sid=9, gripper_socket="1"):
      socket_set_var("SID", gripper_sid,  gripper_socket)
      ack = socket_read_byte_list(3, gripper_socket)
      return is_ack(ack)
  end
  
  def rq_get_sid(gripper_socket="1"):
      socket_send_string("GET SID", gripper_socket)
      sid_list = socket_read_byte_list(17, gripper_socket)
      return sid_list
  end
  
  def rq_wait_for_gripper_connected():
      gripper_socket = "gripper_conn_socket"
      socket_open(rq_gripper_socket_ip_address, rq_gripper_socket_port, gripper_socket)
  
      remainingRetries = 2000
      sid_list = rq_get_sid(gripper_socket)
      gripper_is_connected = rq_is_any_gripper_connected(sid_list)
  
      while(not gripper_is_connected and remainingRetries > 0):
          remainingRetries = remainingRetries - 1
          sid_list = rq_get_sid(gripper_socket)
          gripper_is_connected = rq_is_any_gripper_connected(sid_list)
      end
  
      socket_close(gripper_socket)
  end
  
  def rq_is_any_gripper_connected(sid_list):
      is_gripper_1_connected = rq_is_gripper1_in_sid_list(sid_list)
      is_gripper_2_connected = rq_is_gripper2_in_sid_list(sid_list)
      is_gripper_3_connected = rq_is_gripper3_in_sid_list(sid_list)
      is_gripper_4_connected = rq_is_gripper4_in_sid_list(sid_list)
  
      return is_gripper_1_connected or is_gripper_2_connected or is_gripper_3_connected or is_gripper_4_connected
  end
  
  def rq_is_gripper_ascii_in_sid_list(gripper_ascii_sid, sid_list):
      sid_list_length = sid_list[0]
      sid_list_empty_length = 2
  
      if (sid_list_length <= sid_list_empty_length):
          return False
      end
  
      sid1 = sid_list[2]
      sid2 = sid_list[5]
      sid3 = sid_list[8]
      sid4 = sid_list[11]
  
      return sid1 == gripper_ascii_sid or sid2 == gripper_ascii_sid or sid3 == gripper_ascii_sid or sid4 == gripper_ascii_sid
  end
  
  def rq_is_gripper_in_sid_list(gripper_socket_string, sid_list):
      if(gripper_socket_string == "1"):
          return rq_is_gripper1_in_sid_list(sid_list)
      elif(gripper_socket_string == "2"):
          return rq_is_gripper2_in_sid_list(sid_list)
      elif(gripper_socket_string == "3"):
          return rq_is_gripper3_in_sid_list(sid_list)
      elif(gripper_socket_string == "4"):
          return rq_is_gripper4_in_sid_list(sid_list)
      end
      return False
  end
  
  def rq_is_gripper1_in_sid_list(sid_list):
      gripper_1_sid_ascii = 57
      return rq_is_gripper_ascii_in_sid_list(gripper_1_sid_ascii, sid_list)
  end
  
  def rq_is_gripper2_in_sid_list(sid_list):
      gripper_2_sid_ascii = 50
      return rq_is_gripper_ascii_in_sid_list(gripper_2_sid_ascii, sid_list)
  end
  
  def rq_is_gripper3_in_sid_list(sid_list):
      gripper_3_sid_ascii = 51
      return rq_is_gripper_ascii_in_sid_list(gripper_3_sid_ascii, sid_list)
  end
  
  def rq_is_gripper4_in_sid_list(sid_list):
      gripper_4_sid_ascii = 52
      return rq_is_gripper_ascii_in_sid_list(gripper_4_sid_ascii, sid_list)
  end
  
  def rq_comm_clear_socket_buffer():
      index = 0
  
      while(index <= 3):
          socket = rq_index_to_socket(index)
  
          if(gripper_connected[index] and rq_comm_clear_socket_buffer_enabled[index]):
              byte_in_buffer = socket_read_byte_list(1, socket, 0.002)
              while(byte_in_buffer[0] >= 1):
                  byte_in_buffer = socket_read_byte_list(1, socket, 0.002)
              end
              rq_comm_clear_socket_buffer_enabled[index] = False
          end
          index = index + 1
      end
  end
  
  def rq_comm_initialize_write_values():
      index = 0
  
      while(index <= 3):
          socket = rq_index_to_socket(index)
  
          if(gripper_connected[index]):
  
              if(rq_write_act[index] == -1 and rq_read_act[index] != -1):
                  rq_write_act[index] = rq_read_act[index]
                  rq_write_act_previous[index] = rq_read_act[index]
              elif(rq_write_act_previous[index] == -1 and rq_read_act[index] != -1):
                  rq_write_act_previous[index] = rq_read_act[index]
              end
  
              if(rq_write_gto[index] == -1 and rq_read_gto[index] != -1):
                  rq_write_gto[index] = rq_read_gto[index]
                  rq_write_gto_previous[index] = rq_read_gto[index]
              elif(rq_write_gto_previous[index] == -1 and rq_read_gto[index] != -1):
                  rq_write_gto_previous[index] = rq_read_gto[index]
              end
  
              if(rq_write_for[index] == -1 and rq_read_for[index] != -1):
                  rq_write_for[index] = rq_read_for[index]
                  rq_write_for_previous[index] = rq_read_for[index]
              elif(rq_write_for_previous[index] == -1 and rq_read_for[index] != -1):
                  rq_write_for_previous[index] = rq_read_for[index]
              end
  
              if(rq_write_spe[index] == -1 and rq_read_spe[index] != -1):
                  rq_write_spe[index] = rq_read_spe[index]
                  rq_write_spe_previous[index] = rq_read_spe[index]
              elif(rq_write_spe_previous[index] == -1 and rq_read_spe[index] != -1):
                  rq_write_spe_previous[index] = rq_read_spe[index]
              end
  
              if(rq_write_pos[index] == -1 and rq_read_pos[index] != -1):
                  rq_write_pos[index] = rq_read_pos[index]
                  rq_write_pos_previous[index] = rq_read_pos[index]
              elif(rq_write_pos_previous[index] == -1 and rq_read_pos[index] != -1):
                  rq_write_pos_previous[index] = rq_read_pos[index]
              end
  
              if(rq_write_lbp[index] == -1 and rq_read_lbp[index] != -1):
                  rq_write_lbp[index] = rq_read_lbp[index]
                  rq_write_lbp_previous[index] = rq_read_lbp[index]
              elif(rq_write_lbp_previous[index] == -1 and rq_read_lbp[index] != -1):
                  rq_write_lbp_previous[index] = rq_read_lbp[index]
              end
  
              if(rq_write_lrd[index] == -1 and rq_read_lrd[index] != -1):
                  rq_write_lrd[index] = rq_read_lrd[index]
                  rq_write_lrd_previous[index] = rq_read_lrd[index]
              elif(rq_write_lrd_previous[index] == -1 and rq_read_lrd[index] != -1):
                  rq_write_lrd_previous[index] = rq_read_lrd[index]
              end
  
              if(rq_write_lbl[index] == -1 and rq_read_lbl[index] != -1):
                  rq_write_lbl[index] = rq_read_lbl[index]
                  rq_write_lbl_previous[index] = rq_read_lbl[index]
              elif(rq_write_lbl_previous[index] == -1 and rq_read_lbl[index] != -1):
                  rq_write_lbl_previous[index] = rq_read_lbl[index]
              end
  
              if(rq_write_lgn[index] == -1 and rq_read_lgn[index] != -1):
                  rq_write_lgn[index] = rq_read_lgn[index]
                  rq_write_lgn_previous[index] = rq_read_lgn[index]
              elif(rq_write_lgn_previous[index] == -1 and rq_read_lgn[index] != -1):
                  rq_write_lgn_previous[index] = rq_read_lgn[index]
              end
  
              if(rq_write_msc[index] == -1 and rq_read_msc[index] != -1):
                  rq_write_msc[index] = rq_read_msc[index]
                  rq_write_msc_previous[index] = rq_read_msc[index]
              elif(rq_write_msc_previous[index] == -1 and rq_read_msc[index] != -1):
                  rq_write_msc_previous[index] = rq_read_msc[index]
              end
  
              if(rq_write_mod[index] == -1 and rq_read_mod[index] != -1):
                  rq_write_mod[index] = rq_read_mod[index]
                  rq_write_mod_previous[index] = rq_read_mod[index]
              elif(rq_write_mod_previous[index] == -1 and rq_read_mod[index] != -1):
                  rq_write_mod_previous[index] = rq_read_mod[index]
              end
  
          end
          index = index + 1
      end
  end
  
  def rq_comm_set_var(var, value=0, gripper_socket="1"):
      socket_set_var(var, value, gripper_socket)
      return socket_read_byte_list(3, gripper_socket)
  end
  
  def rq_comm_set_pos_spe_for(pos=0, speed=0, force=0, gripper_socket="1"):
      socket_send_string("SET POS", gripper_socket)
      socket_send_byte(32, gripper_socket)
      socket_send_string(pos, gripper_socket)
      socket_send_byte(32, gripper_socket)
      socket_send_string("SPE", gripper_socket)
      socket_send_byte(32, gripper_socket)
      socket_send_string(speed, gripper_socket)
      socket_send_byte(32, gripper_socket)
      socket_send_string("FOR", gripper_socket)
      socket_send_byte(32, gripper_socket)
      socket_send_string(force, gripper_socket)
      socket_send_byte(10, gripper_socket)
      return socket_read_byte_list(3, gripper_socket)
  end
  
  def rq_comm_read_variables():
      index = 0
  
      while(index <= 3):
          socket = rq_index_to_socket(index)
  
          if(gripper_connected[index]):
  
              if(rq_read_act_req[index]):
                  rq_read_act[index] = socket_get_var("ACT", socket)
                  rq_read_act_req[index] = False
              end
  
              if(rq_read_gto_req[index]):
                  rq_read_gto[index] = socket_get_var("GTO", socket)
                  rq_read_gto_req[index] = False
              end
  
              if(rq_read_pre_req[index]):
                  rq_read_pre[index] = socket_get_var("PRE", socket)
                  rq_read_pre_req[index] = False
              end
  
              if(rq_read_pos_req[index]):
                  rq_read_pos[index] = socket_get_var("POS", socket)
                  rq_read_pos_req[index] = False
              end
  
              if(rq_read_spe_req[index]):
                  rq_read_spe[index] = socket_get_var("SPE", socket)
                  rq_read_spe_req[index] = False
              end
  
              if(rq_read_for_req[index]):
                  rq_read_for[index] = socket_get_var("FOR", socket)
                  rq_read_for_req[index] = False
              end
  
              if(rq_read_obj_req[index]):
                  rq_read_obj[index] = socket_get_var("OBJ", socket)
                  rq_read_obj_req[index] = False
              end
  
              if(rq_read_sta_req[index]):
                  rq_read_sta[index] = socket_get_var("STA", socket)
                  rq_read_sta_req[index] = False
              end
  
              if(rq_read_mod_req[index]):
                  rq_read_mod[index] = socket_get_var("MOD", socket)
                  rq_read_mod_req[index] = False
              end
  
              if(rq_read_flt_req[index]):
                  rq_read_flt[index] = socket_get_var("FLT",socket)
                  rq_read_flt_req[index] = False
              end
  
              if(rq_read_lbp_req[index]):
                  rq_read_lbp[index] = socket_get_var("LBP", socket)
                  rq_read_lbp_req[index] = False
              end
  
              if(rq_read_lrd_req[index]):
                  rq_read_lrd[index] = socket_get_var("LRD", socket)
                  rq_read_lrd_req[index] = False
              end
  
              if(rq_read_lbl_req[index]):
                  rq_read_lbl[index] = socket_get_var("LBL",socket)
                  rq_read_lbl_req[index] = False
              end
  
              if(rq_read_lgn_req[index]):
                  rq_read_lgn[index] = socket_get_var("LGN", socket)
                  rq_read_lgn_req[index] = False
              end
  
              if(rq_read_msc_req[index]):
                  rq_read_msc[index] = socket_get_var("MSC", socket)
                  rq_read_msc_req[index] = False
              end
  
              if(rq_read_cou_req[index]):
                  rq_read_cou[index] = socket_get_var("COU", socket)
                  rq_read_cou_req[index] = False
              end
  
              if(rq_read_ncy_req[index]):
                  rq_read_ncy[index] = socket_get_var("NCY", socket)
                  rq_read_ncy_req[index] = False
              end
  
              if(rq_read_dst_req[index]):
                  rq_read_dst[index] = socket_get_var("DST", socket)
                  rq_read_dst_req[index] = False
              end
  
              if(rq_read_pco_req[index]):
                  rq_read_pco[index] = socket_get_var("PCO", socket)
                  rq_read_pco_req[index] = False
              end
          end
          index = index + 1
      end
  end
  
  def rq_comm_read_constants():
  
      if(gripper_connected[0]):
          while(rq_read_snu_1 == rq_string_initial_value):
              socket_send_string("GET SNU", "1")
              rq_read_snu_1 = socket_read_string("1")
          end
  
          while(rq_read_fwv_1 == rq_string_initial_value):
              socket_send_string("GET FWV", "1")
              rq_read_fwv_1 = socket_read_string("1")
          end
  
          while(rq_read_ver_1 == rq_string_initial_value):
              socket_send_string("GET VER", "1")
              rq_read_ver_1 = socket_read_string("1")
          end
      end
  
      if(gripper_connected[1]):
          while(rq_read_snu_2 == rq_string_initial_value):
              socket_send_string("GET SNU", "2")
              rq_read_snu_2 = socket_read_string("2")
          end
  
          while(rq_read_fwv_2 == rq_string_initial_value):
              socket_send_string("GET FWV", "2")
              rq_read_fwv_2 = socket_read_string("2")
          end
  
          while(rq_read_ver_2 == rq_string_initial_value):
              socket_send_string("GET VER", "2")
              rq_read_ver_2 = socket_read_string("2")
          end
      end
  
      if(gripper_connected[2]):
          while(rq_read_snu_3 == rq_string_initial_value):
              socket_send_string("GET SNU", "3")
              rq_read_snu_3 = socket_read_string("3")
          end
  
          while(rq_read_fwv_3 == rq_string_initial_value):
              socket_send_string("GET FWV", "3")
              rq_read_fwv_3 = socket_read_string("3")
          end
  
          while(rq_read_ver_3 == rq_string_initial_value):
              socket_send_string("GET VER", "3")
              rq_read_ver_3 = socket_read_string("3")
          end
      end
  
      if(gripper_connected[3]):
          while(rq_read_snu_4 == rq_string_initial_value):
              socket_send_string("GET SNU", "4")
              rq_read_snu_4 = socket_read_string("4")
          end
  
          while(rq_read_fwv_4 == rq_string_initial_value):
              socket_send_string("GET FWV", "4")
              rq_read_fwv_4 = socket_read_string("4")
          end
  
          while(rq_read_ver_4 == rq_string_initial_value):
              socket_send_string("GET VER", "4")
              rq_read_ver_4 = socket_read_string("4")
          end
      end
  end
  
  def rq_comm_write_variables():
      index = 0
  
      while(index <= 3):
          socket = rq_index_to_socket(index)
  
          if(gripper_connected[index]):
  
              if(rq_write_act_request[index]):
                  if(is_ack(rq_comm_set_var("ACT", rq_write_act[index], socket))):
                      rq_write_act_previous[index] = rq_write_act[index]
                      rq_write_act_request[index] = False
                  end
              end
  
              if(rq_write_gto_request[index]):
                  if(is_ack(rq_comm_set_var("GTO", rq_write_gto[index], socket))):
                      rq_write_gto_previous[index] = rq_write_gto[index]
                      rq_write_gto_request[index] = False
                  end
              end
  
              if(rq_write_atr_request[index]):
                  if(is_ack(rq_comm_set_var("ATR", rq_write_atr[index], socket))):
                      rq_write_atr_previous[index] = rq_write_atr[index]
                      rq_write_atr_request[index] = False
                  end
              end
  
              if(rq_write_ard_request[index]):
                  if(is_ack(rq_comm_set_var("ARD", rq_write_ard[index], socket))):
                      rq_write_ard_previous[index] = rq_write_ard[index]
                      rq_write_ard_request[index] = False
                  end
              end
  
              if(rq_write_pos_request[index]):
                  if(is_ack(rq_comm_set_pos_spe_for(rq_write_pos[index], rq_write_spe[index], rq_write_for[index], socket))):
                      rq_write_pos_previous[index] = rq_write_pos[index]
                      rq_write_spe_previous[index] = rq_write_spe[index]
                      rq_write_for_previous[index] = rq_write_for[index]
                      rq_write_pos_request[index] = False
                  end
              end
  
              if(rq_write_lbp_request[index]):
                  if(is_ack(rq_comm_set_var("LBP", rq_write_lbp[index], socket))):
                      rq_write_lbp_previous[index] = rq_write_lbp[index]
                      rq_write_lbp_request[index] = False
                  end
              end
  
              if(rq_write_lrd_request[index]):
                  if(is_ack(rq_comm_set_var("LRD", rq_write_lrd[index], socket))):
                      rq_write_lrd_previous[index] = rq_write_lrd[index]
                      rq_write_lrd_request[index] = False
                  end
              end
  
              if(rq_write_lbl_request[index]):
                  if(is_ack(rq_comm_set_var("LBL", rq_write_lbl[index], socket))):
                      rq_write_lbl_previous[index] = rq_write_lbl[index]
                      rq_write_lbl_request[index] = False
                  end
              end
  
              if(rq_write_lgn_request[index]):
                  if(is_ack(rq_comm_set_var("LGN", rq_write_lgn[index], socket))):
                      rq_write_lgn_previous[index] = rq_write_lgn[index]
                      rq_write_lgn_request[index] = False
                  end
              end
  
              if(rq_write_msc_request[index]):
                  if(is_ack(rq_comm_set_var("MSC", rq_write_msc[index], socket))):
                      rq_write_msc_previous[index] = rq_write_msc[index]
                      rq_write_msc_request[index] = False
                  end
              end
  
              if(rq_write_mod_request[index]):
                  if(is_ack(rq_comm_set_var("MOD", rq_write_mod[index], socket))):
                      rq_write_mod_previous[index] = rq_write_mod[index]
                      rq_write_mod_request[index] = False
                  end
              end
          end
          index = index + 1
      end
  end
  
  def rq_activate(gripper_socket="1"):
      if (not rq_is_gripper_activated(gripper_socket)):
          rq_reset(gripper_socket)
  
          while(not rq_get_var("ACT", 1, gripper_socket) == 0 or not rq_get_var("STA", 1, gripper_socket) == 0):
              rq_reset(gripper_socket)
              sleep(0.008)
          end
  
          rq_set_var("ACT",1, gripper_socket)
      end
  end
  
  def rq_activate_and_wait(gripper_socket="1"):
      if (not rq_is_gripper_activated(gripper_socket)):
          rq_activate(gripper_socket)
          sleep(1.0)
  
          while(not rq_get_var("ACT", 1, gripper_socket) == 1 or not rq_get_var("STA", 1, gripper_socket) == 3):
              sleep(0.1)
          end
  
          sleep(0.5)
      end
  end
  
  def rq_activate_all_grippers(reset=False):
      if(gripper_connected[0]):
          rq_reset_and_activate("1", reset)
      end
  
      if(gripper_connected[1]):
          rq_reset_and_activate("2", reset)
      end
  
      if(gripper_connected[2]):
          rq_reset_and_activate("3", reset)
      end
  
      if(gripper_connected[3]):
          rq_reset_and_activate("4", reset)
      end
  end
  
  def rq_reset_and_activate(gripper_socket="1", reset=False):
      if(reset):
          rq_reset(gripper_socket)
          rq_activate_and_wait(gripper_socket)
      elif(not rq_is_gripper_activated(gripper_socket)):
          rq_activate_and_wait(gripper_socket)
      end
  end
  
  def rq_reset(gripper_socket="1"):
      rq_set_var("ACT", 0, gripper_socket)
      rq_set_var("ATR", 0, gripper_socket)
  
      while(not rq_get_var("ACT", 1, gripper_socket) == 0 or not rq_get_var("STA", 1, gripper_socket) == 0):
          rq_set_var("ACT", 0, gripper_socket)
          rq_set_var("ATR", 0, gripper_socket)
          sleep(0.008)
      end
  
      sleep(0.5)
  end
  
  def rq_auto_release_open_and_wait(gripper_socket="1"):
      rq_set_var("ATR",0, gripper_socket)
      rq_set_var("ARD",0, gripper_socket)
      rq_set_var("ACT",1, gripper_socket)
      sleep(0.1)
      rq_set_var("ATR",1, gripper_socket)
  
      rq_wait_autorelease_completed(gripper_socket)
  end
  
  def rq_auto_release_close_and_wait(gripper_socket="1"):
      rq_set_var("ATR",0, gripper_socket)
      rq_set_var("ARD",1, gripper_socket)
      rq_set_var("ACT",1, gripper_socket)
      sleep(0.1)
      rq_set_var("ATR",1, gripper_socket)
  
      rq_wait_autorelease_completed(gripper_socket)
  end
  
  def rq_wait_autorelease_completed(gripper_socket="1"):
      remainingRetries = 20
      gFLT = rq_get_var("FLT", 2, gripper_socket)
  
      while(not is_FLT_autorelease_in_progress(gFLT) and remainingRetries > 0):
          remainingRetries = remainingRetries - 1
          gFLT = rq_get_var("FLT", 2, gripper_socket)
          sleep(0.1)
      end
  
      remainingRetries = 100
      gFLT = rq_get_var("FLT", 2, gripper_socket)
  
      while(not is_FLT_autorelease_completed(gFLT) and remainingRetries > 0):
          remainingRetries = remainingRetries - 1
          gFLT = rq_get_var("FLT", 2, gripper_socket)
          sleep(0.1)
      end
  end
  
  def rq_set_force(force, gripper_socket="1"):
      force = floor(scale(force, [0, 255], [0.0, 255.0]))
      rq_set_var("FOR", force, gripper_socket)
  end
  
  def rq_set_speed(speed, gripper_socket="1"):
      speed = floor(scale(speed, [0, 255], [0.0, 255.0]))
      rq_set_var("SPE", speed, gripper_socket)
  end
  
  def rq_open(gripper_socket="1"):
      rq_move(0, gripper_socket)
  end
  
  def rq_close(gripper_socket="1"):
      rq_move(255, gripper_socket)
  end
  
  def rq_open_and_wait(gripper_socket="1"):
      rq_move_and_wait(0, gripper_socket)
  end
  
  def rq_close_and_wait(gripper_socket="1"):
      rq_move_and_wait(255, gripper_socket)
  end
  
  def rq_move(pos, gripper_socket="1"):
      rq_set_pos(pos, gripper_socket)
      rq_go_to(gripper_socket)
  end
  
  def rq_move_and_wait(pos, gripper_socket="1"):
      rq_move(pos, gripper_socket)
  
      while (not rq_is_motion_complete(gripper_socket)):
          # wait for motion completed
          sleep(0.008)
      end
  end
  
  def rq_wait_for_pos_request(pos, gripper_socket="1"):
      gPRE = rq_get_var("PRE", 3, gripper_socket)
  
      while (gPRE != pos):
          rq_set_var("POS", pos, gripper_socket)
          sleep(0.008)
          gPRE = rq_get_var("PRE", 3, gripper_socket)
      end
  end
  
  def rq_wait_pos_spe_for_request(pos, speed, force, gripper_socket="1"):
      gPRE = rq_get_var("PRE", 3, gripper_socket)
  
      while (gPRE != pos):
          rq_set_pos_spe_for_var(pos, speed, force, gripper_socket)
          sleep(0.008)
          gPRE = rq_get_var("PRE", 3, gripper_socket)
      end
  end
  
  def rq_wait_for_pos(pos, gripper_socket="1"):
      rq_wait_for_pos_request(pos, gripper_socket)
  
      # Wait for the gripper motion to complete
      while (not rq_is_motion_complete(gripper_socket)):
          # wait for motion completed
          sleep(0.008)
          rq_set_var("GTO", 1, gripper_socket)
      end
  end
  
  def rq_wait(gripper_socket="1"):
      # Wait for the gripper motion to complete
      while (not rq_is_motion_complete(gripper_socket)):
          sleep(0.008)
          # The following patch is for Robotiq's Camera issue when communication is lost, but not the activation
          # the communication driver reset the GTO bit
          rq_set_var("GTO", 1, gripper_socket)
      end
  end
  
  def rq_wait_for_object_detected(gripper_socket="1"):
      # Wait the object detection
      while (not rq_is_object_detected(gripper_socket)):
          sleep(0.008)
      end
  end
  
  # set the position
  def rq_set_pos(pos, gripper_socket="1"):
      pos = floor(scale(pos, [0, 255], [0.0, 255.0]))
      rq_set_var("POS", pos, gripper_socket)
      rq_wait_for_pos_request(pos, gripper_socket)
  end
  
  def rq_set_pos_spd_for(pos, speed, force, gripper_socket="1"):
      pos = floor(scale(pos, [0, 255], [0.0, 255.0]))
      speed = floor(scale(speed, [0, 255], [0.0, 255.0]))
      force = floor(scale(force, [0, 255], [0.0, 255.0]))
  
      rq_set_pos_spe_for_var(pos, speed, force, gripper_socket)
  end
  
  def rq_set_gripper_max_current_mA(current_mA, gripper_socket="1"):
      current = floor(current_mA / 10)
  
      rq_set_var("MSC", current, gripper_socket)
      current_read = rq_get_var("MSC", 1, gripper_socket)
  
      while(current_read != current):
          rq_set_var("MSC", current, gripper_socket)
          current_read = rq_get_var("MSC", 1, gripper_socket)
      end
  end
  
  def rq_set_gripper_mode(mode, gripper_socket="1"):
      rq_set_var("MOD", mode, gripper_socket)
  end
  
  def rq_set_gripper_max_cur(current_mA, gripper_socket="1"):
      rq_set_gripper_max_current_mA(current_mA, gripper_socket)
  end
  
  def rq_get_gripper_max_current_mA(gripper_socket="1"):
      current = rq_get_var("MSC", 1, gripper_socket)
  
      if(current == -1):
          current_mA = current
      else:
          current_mA = current * 10
      end
  
      return current_mA
  end
  
  def rq_get_gripper_max_cur(gripper_socket="1"):
      return rq_get_gripper_max_current_mA(gripper_socket)
  end
  
  def rq_set_max_current_for_all_grippers():
      current_mA = rq_get_max_current_mA()
  
      if(gripper_connected[0]):
          rq_set_gripper_max_current_mA(current_mA, "1")
      end
  
      if(gripper_connected[1]):
          rq_set_gripper_max_current_mA(current_mA, "2")
      end
  
      if(gripper_connected[2]):
          rq_set_gripper_max_current_mA(current_mA, "3")
      end
  
      if(gripper_connected[3]):
          rq_set_gripper_max_current_mA(current_mA, "4")
      end
  end
  
  def rq_get_max_current_mA():
      max_current_mA = 0
  
      if(rq_current_limit_enabled):
          nb_connected_grippers = rq_get_nb_connected_grippers()
  
          if(nb_connected_grippers == 1):
              max_current_mA = 600
          elif(nb_connected_grippers > 1):
              max_current_mA = 450
          end
      else:
  
      end
  
      return max_current_mA
  end
  
  def rq_get_nb_connected_grippers():
      nb_connected_grippers = 0
  
      if(gripper_connected[0]):
          nb_connected_grippers = nb_connected_grippers + 1
      end
  
      if(gripper_connected[1]):
          nb_connected_grippers = nb_connected_grippers + 1
      end
  
      if(gripper_connected[2]):
          nb_connected_grippers = nb_connected_grippers + 1
      end
  
      if(gripper_connected[3]):
          nb_connected_grippers = nb_connected_grippers + 1
      end
  
      return nb_connected_grippers
  end
  
  def rq_list_of_bytes_to_value(list_of_bytes):
      value = -1
  
      # response list length
      if (list_of_bytes[0] == 1):
          value = list_of_bytes[1] - 48
      elif (list_of_bytes[0] == 2):
          value = (list_of_bytes[1] - 48) * 10 + (list_of_bytes[2] - 48)
      elif (list_of_bytes[0] == 3):
          value = (list_of_bytes[1] - 48) * 100 + (list_of_bytes[2] - 48) * 10 + (list_of_bytes[3] - 48)
      end
  
      return value
  end
  
  def rq_is_motion_complete(gripper_socket="1"):
      gOBJ = rq_get_var("OBJ", 1, gripper_socket)
      sleep(0.008)
      return is_OBJ_gripper_at_position(gOBJ) or is_OBJ_object_detected(gOBJ)
  end
  
  def rq_is_gripper_activated(gripper_socket="1"):
      gSTA = rq_get_var("STA", 1, gripper_socket)
      sleep(0.008)
      return is_STA_gripper_activated(gSTA)
  end
  
  def rq_is_object_detected(gripper_socket="1"):
      gOBJ = rq_get_var("OBJ", 1, gripper_socket)
      sleep(0.008)
      return is_OBJ_object_detected(gOBJ)
  end
  
  def rq_current_pos(gripper_socket="1"):
      gPOS = rq_get_var("POS", 1, gripper_socket)
      sleep(0.008)
      return gPOS
  end
  
  def rq_motor_current(gripper_socket="1"):
      rq_current = rq_get_var("COU", 1, gripper_socket)
      sleep(0.008)
      return rq_current * 10
  end
  
  def rq_print_connected_grippers():
      if(gripper_connected[0]):
          textmsg("Gripper 1 : ", "connected and socket open.")
      end
  
      if (gripper_connected[1]):
          textmsg("Gripper 2 : ", "connected and socket open.")
      end
  
      if (gripper_connected[2]):
          textmsg("Gripper 3 : ", "connected and socket open.")
      end
  
      if (gripper_connected[3]):
          textmsg("Gripper 4 : ", "connected and socket open.")
      end
  end
  
  def rq_print_gripper_fault_code(gripper_socket="1"):
      gFLT = rq_get_var("FLT", 2, gripper_socket)
  
      if(is_FLT_no_fault(gFLT)):
          textmsg("Gripper Fault : ", "No Fault (0x00)")
      elif (is_FLT_action_delayed(gFLT)):
          textmsg("Gripper Fault : ", "Priority Fault: Action delayed, initialization must be completed prior to performing the action (0x05)")
      elif (is_FLT_not_activated(gFLT)):
          textmsg("Gripper Fault : ", "Priority Fault: The activation bit must be set prior to performing the action (0x07)")
      elif (is_FLT_over_temperature(gFLT)):
          textmsg("Gripper Fault : ", "Minor Fault: Maximum operating temperature exceeded (≥ 85°C internally), let cool down (below 80°C) (0x08)")
      elif (is_FLT_no_communication(gFLT)):
          textmsg("Gripper Fault : ", "Minor Fault: No communication during at least 1 second (0x09)")
      elif (is_FLT_under_voltage(gFLT)):
          textmsg("Gripper Fault : ", "Major Fault: Under minimum operating voltage (0x0A)")
      elif (is_FLT_autorelease_in_progress(gFLT)):
          textmsg("Gripper Fault : ", "Major Fault: Automatic release in progress (0x0B)")
      elif (is_FLT_internal_fault(gFLT)):
          textmsg("Gripper Fault : ", "Major Fault: Internal fault; contact support@robotiq.com (0x0C)")
      elif (is_FLT_activation_error(gFLT)):
          textmsg("Gripper Fault : ", "Major Fault: Activation fault; verify that no interference or other error occurred (0x0D)")
      elif (is_FLT_overcurrent(gFLT)):
          textmsg("Gripper Fault : ", "Major Fault: Overcurrent triggered (0x0E)")
      elif (is_FLT_autorelease_completed(gFLT)):
          textmsg("Gripper Fault : ", "Major Fault: Automatic release completed (0x0F)")
      else:
          textmsg("Gripper Fault : ", "Unknown Fault")
      end
  end
  
  def rq_print_gripper_num_cycles(gripper_socket="1"):
      num_cycles = rq_get_var("NCY", 1, gripper_socket)
  
      if(num_cycles == -1):
          textmsg("Gripper Cycle Number : ", "Number of cycles is unreachable.")
      else:
          textmsg("Gripper Cycle Number : ", num_cycles)
      end
  end
  
  def rq_print_gripper_driver_state(gripper_socket="1"):
      driver_state = rq_get_var("DST", 1, gripper_socket)
  
      if(driver_state == 0):
          textmsg("Gripper Driver State : ", "RQ_STATE_INIT")
      elif(driver_state == 1):
          textmsg("Gripper Driver State : ", "RQ_STATE_LISTEN")
      elif(driver_state == 2):
          textmsg("Gripper Driver State : ", "RQ_STATE_READ_INFO")
      elif(driver_state == 3):
          textmsg("Gripper Driver State : ", "RQ_STATE_ACTIVATION")
      else:
          textmsg("Gripper Driver State : ", "RQ_STATE_RUN")
      end
  end
  
  def rq_print_gripper_serial_number(gripper_socket="1"):
      serial_number = rq_get_var_string("SNU", 1, gripper_socket)
      textmsg("Gripper Serial Number : ", serial_number)
  end
  
  def rq_print_gripper_firmware_version(gripper_socket="1"):
      firmware_version = rq_get_var_string("FWV", 1, gripper_socket)
      textmsg("Gripper Firmware Version : ", firmware_version)
  end
  
  def rq_print_gripper_driver_version(gripper_socket="1"):
      driver_version = rq_get_var_string("VER", 1, gripper_socket)
      textmsg("Gripper Driver Version : ", driver_version)
  end
  
  def rq_print_gripper_connection_state(gripper_socket="1"):
      connection_state = rq_get_var("PCO", 1, gripper_socket)
  
      if (connection_state == 0):
          textmsg("Gripper Connection State : ", "No connection problem detected")
      else:
          textmsg("Gripper Connection State : ", "Connection problem detected")
      end
  end
  
  # Returns True if list_of_bytes is [3, 'a', 'c', 'k']
  def is_ack(list_of_bytes):
  
      # list length is not 3
      if (list_of_bytes[0] != 3):
          return False
      end
  
      # first byte not is 'a'?
      if (list_of_bytes[1] != 97):
          return False
      end
  
      # first byte not is 'c'?
      if (list_of_bytes[2] != 99):
          return False
      end
  
      # first byte not is 'k'?
      if (list_of_bytes[3] != 107):
          return False
      end
  
      return True
  end
  
  # Returns True if list_of_bytes is not [3, 'a', 'c', 'k']
  def is_not_ack(list_of_bytes):
      if (is_ack(list_of_bytes)):
          return False
      else:
          return True
      end
  end
  
  def is_STA_gripper_activated (gSTA):
      if (gSTA == 3):
          return True
      end
  
      return False
  end
  
  def is_OBJ_object_detected (gOBJ):
      if (gOBJ == 1 or gOBJ == 2):
          return True
      end
  
      return False
  end
  
  def is_OBJ_gripper_at_position (gOBJ):
      if (gOBJ == 3):
          return True
      end
  
      return False
  end
  
  def is_not_OBJ_gripper_at_position (gOBJ):
      if (is_OBJ_gripper_at_position(gOBJ)):
          return False
      else:
          return True
      end
  end
  
  #### GTO Section ####
  def rq_stop(gripper_socket="1"):
      rq_set_var("GTO", 0, gripper_socket)
  end
  
  def rq_set_GTO_and_wait(value, gripper_socket="1"):
      rq_set_var("GTO" ,value, gripper_socket)
      while(not is_GTO(value, rq_get_var("GTO", 1, gripper_socket))):
        sleep(0.008)
      end
  end
  
  def rq_go_to(gripper_socket="1"):
      rq_set_var("GTO", 1, gripper_socket)
  end
  
  
  def is_GTO(goto_value, rGTO):
      return rGTO == goto_value
  end
  #### GTO Section ####
  
  def is_FLT_no_fault(gFLT):
      return gFLT == 0
  end
  
  def is_FLT_warning(gFLT):
      return gFLT >= 1 and gFLT <= 7
  end
  
  def is_FLT_faulted(gFLT):
      return gFLT >= 8
  end
  
  def is_FLT_action_delayed(gFLT):
      return gFLT == 5
  end
  
  def is_FLT_not_activated(gFLT):
      return gFLT == 7
  end
  
  def is_FLT_over_temperature(gFLT):
      return gFLT == 8
  end
  
  def is_FLT_no_communication(gFLT):
      return gFLT == 9
  end
  
  def is_FLT_under_voltage(gFLT):
      return gFLT == 10
  end
  
  def is_FLT_autorelease_in_progress(gFLT):
      return gFLT == 11
  end
  
  def is_FLT_internal_fault(gFLT):
      return gFLT == 12
  end
  
  def is_FLT_activation_error(gFLT):
      return gFLT == 13
  end
  
  def is_FLT_overcurrent(gFLT):
      return gFLT == 14
  end
  
  def is_FLT_autorelease_completed(gFLT):
      return gFLT == 15
  end
  
  def rq_set_var(var_name, var_value, gripper_socket="1"):
      index = rq_socket_to_index(gripper_socket)
  
      enter_critical
  
      if (var_name == "ACT"):
          rq_write_act[index] = var_value
          rq_write_act_request[index] = True
      elif (var_name == "GTO"):
          rq_write_gto[index] = var_value
          rq_write_gto_request[index] = True
      elif (var_name == "ATR"):
          rq_write_atr[index] = var_value
          rq_write_atr_request[index] = True
      elif (var_name == "ARD"):
          rq_write_ard[index] = var_value
          rq_write_ard_request[index] = True
      elif (var_name == "FOR"):
          rq_write_for[index] = var_value
          rq_write_pos_request[index] = True
      elif (var_name == "SPE"):
          rq_write_spe[index] = var_value
          rq_write_pos_request[index] = True
      elif (var_name == "POS"):
          rq_write_pos[index] = var_value
          rq_write_pos_request[index] = True
      elif (var_name == "LBP"):
          rq_write_lbp[index] = var_value
          rq_write_lbp_request[index] = True
      elif (var_name == "LRD"):
          rq_write_lrd[index] = var_value
          rq_write_lrd_request[index] = True
      elif (var_name == "LBL"):
          rq_write_lbl[index] = var_value
          rq_write_lbl_request[index] = True
      elif (var_name == "LGN"):
          rq_write_lgn[index] = var_value
          rq_write_lgn_request[index] = True
      elif (var_name == "MSC"):
          rq_write_msc[index] = var_value
          rq_write_msc_request[index] = True
      elif (var_name == "MOD"):
          rq_write_mod[index] = var_value
          rq_write_mod_request[index] = True
      end
  
      exit_critical
  
      if (var_name == "ACT"):
          while(rq_write_act_request[index]):
              sleep(0.008)
          end
      elif (var_name == "GTO"):
          while(rq_write_gto_request[index]):
              sleep(0.008)
          end
      elif (var_name == "ATR"):
          while(rq_write_atr_request[index]):
              sleep(0.008)
          end
      elif (var_name == "ARD"):
          while(rq_write_ard_request[index]):
              sleep(0.008)
          end
      elif (var_name == "FOR"):
          while(rq_write_pos_request[index]):
              sleep(0.008)
          end
      elif (var_name == "SPE"):
          while(rq_write_pos_request[index]):
              sleep(0.008)
          end
      elif (var_name == "POS"):
          while(rq_write_pos_request[index]):
              sleep(0.008)
          end
      elif (var_name == "LBP"):
          while(rq_write_lbp_request[index]):
              sleep(0.008)
          end
      elif (var_name == "LRD"):
          while(rq_write_lrd_request[index]):
              sleep(0.008)
          end
      elif (var_name == "LBL"):
          while(rq_write_lbl_request[index]):
              sleep(0.008)
          end
      elif (var_name == "LGN"):
          while(rq_write_lgn_request[index]):
              sleep(0.008)
          end
      elif (var_name == "MSC"):
          while(rq_write_msc_request[index]):
              sleep(0.008)
          end
      elif (var_name == "MOD"):
          while(rq_write_mod_request[index]):
              sleep(0.008)
          end
      end
  end
  
  def rq_set_pos_spe_for_var(pos, speed, force, gripper_socket="1"):
      index = rq_socket_to_index(gripper_socket)
  
      enter_critical
  
      rq_write_for[index] = force
      rq_write_spe[index] = speed
      rq_write_pos[index] = pos
      rq_write_pos_request[index] = True
  
      exit_critical
  end
  
  def rq_get_var(var_name, nbr_bytes, gripper_socket="1"):
      index = rq_socket_to_index(gripper_socket)
      var_value = -1
  
      if (var_name == "ACT"):
          enter_critical
          rq_read_act_req[index] = True
          exit_critical
          while(rq_read_act_req[index]):
              sleep(0.008)
          end
          var_value = rq_read_act[index]
  
      elif (var_name == "GTO"):
          enter_critical
          rq_read_gto_req[index] = True
          exit_critical
          while(rq_read_gto_req[index]):
              sleep(0.008)
          end
          var_value = rq_read_gto[index]
  
      elif (var_name == "FOR"):
          enter_critical
          rq_read_for_req[index] = True
          exit_critical
          while(rq_read_for_req[index]):
              sleep(0.008)
          end
          var_value = rq_read_for[index]
  
      elif (var_name == "SPE"):
          enter_critical
          rq_read_spe_req[index] = True
          exit_critical
          while(rq_read_spe_req[index]):
              sleep(0.008)
          end
          var_value = rq_read_spe[index]
  
      elif (var_name == "OBJ"):
          enter_critical
          rq_read_obj_req[index] = True
          exit_critical
          while(rq_read_obj_req[index]):
              sleep(0.008)
          end
          var_value = rq_read_obj[index]
  
      elif (var_name == "STA"):
          enter_critical
          rq_read_sta_req[index] = True
          exit_critical
          while(rq_read_sta_req[index]):
              sleep(0.008)
          end
          var_value = rq_read_sta[index]
  
      elif (var_name == "FLT"):
          enter_critical
          rq_read_flt_req[index] = True
          exit_critical
          while(rq_read_flt_req[index]):
              sleep(0.008)
          end
          var_value = rq_read_flt[index]
  
      elif (var_name == "POS"):
          enter_critical
          rq_read_pos_req[index] = True
          exit_critical
          while(rq_read_pos_req[index]):
              sleep(0.008)
          end
          var_value = rq_read_pos[index]
  
      elif (var_name == "PRE"):
          enter_critical
          rq_read_pre_req[index] = True
          exit_critical
          while(rq_read_pre_req[index]):
              sleep(0.008)
          end
          var_value = rq_read_pre[index]
  
      elif (var_name == "LBP"):
          enter_critical
          rq_read_lbp_req[index] = True
          exit_critical
          while(rq_read_lbp_req[index]):
              sleep(0.008)
          end
          var_value = rq_read_lbp[index]
  
      elif (var_name == "LRD"):
          enter_critical
          rq_read_lrd_req[index] = True
          exit_critical
          while(rq_read_lrd_req[index]):
              sleep(0.008)
          end
          var_value = rq_read_lrd[index]
  
      elif (var_name == "LBL"):
          enter_critical
          rq_read_lbl_req[index] = True
          exit_critical
          while(rq_read_lbl_req[index]):
              sleep(0.008)
          end
          var_value = rq_read_lbl[index]
  
      elif (var_name == "LGN"):
          enter_critical
          rq_read_lgn_req[index] = True
          exit_critical
          while(rq_read_lgn_req[index]):
              sleep(0.008)
          end
          var_value = rq_read_lgn[index]
  
      elif (var_name == "MSC"):
          enter_critical
          rq_read_msc_req[index] = True
          exit_critical
          while(rq_read_msc_req[index]):
              sleep(0.008)
          end
          var_value = rq_read_msc[index]
  
      elif (var_name == "MOD"):
          enter_critical
          rq_read_mod_req[index] = True
          exit_critical
          while(rq_read_mod_req[index]):
              sleep(0.008)
          end
          var_value = rq_read_mod[index]
  
      elif (var_name == "NCY"):
          enter_critical
          rq_read_ncy_req[index] = True
          exit_critical
          while(rq_read_ncy_req[index]):
              sleep(0.008)
          end
          var_value = rq_read_ncy[index]
  
      elif (var_name == "PCO"):
          enter_critical
          rq_read_pco_req[index] = True
          exit_critical
          while(rq_read_pco_req[index]):
              sleep(0.008)
          end
          var_value = rq_read_pco[index]
  
      elif (var_name == "DST"):
          enter_critical
          rq_read_dst_req[index] = True
          exit_critical
          while(rq_read_dst_req[index]):
              sleep(0.008)
          end
          var_value = rq_read_dst[index]
  
      end
  
      return var_value
  end
  
  def rq_get_var_string(var_name, nbr_bytes, gripper_socket="1"):
      index = rq_socket_to_index(gripper_socket)
      var_value = ""
  
      enter_critical
  
      if (var_name == "SNU"):
          if(gripper_socket == "1"):
              var_value = rq_read_snu_1
          elif(gripper_socket == "2"):
              var_value = rq_read_snu_2
          elif(gripper_socket == "3"):
              var_value = rq_read_snu_3
          elif(gripper_socket == "4"):
              var_value = rq_read_snu_4
          end
      elif (var_name == "FWV"):
          if(gripper_socket == "1"):
              var_value = rq_read_fwv_1
          elif(gripper_socket == "2"):
              var_value = rq_read_fwv_2
          elif(gripper_socket == "3"):
              var_value = rq_read_fwv_3
          elif(gripper_socket == "4"):
              var_value = rq_read_fwv_4
          end
      elif (var_name == "VER"):
          if(gripper_socket == "1"):
              var_value = rq_read_ver_1
          elif(gripper_socket == "2"):
              var_value = rq_read_ver_2
          elif(gripper_socket == "3"):
              var_value = rq_read_ver_3
          elif(gripper_socket == "4"):
              var_value = rq_read_ver_4
          end
      end
  
      exit_critical
  
      return var_value
  end
  
  def rq_is_object_validated(gripper_selected, gripper_socket="1"):
      if(gripper_selected):
          if(rq_is_object_detected(gripper_socket)):
              return True
          else:
              return False
          end
      else:
          return True
      end
  end
  
  ############################################
  # normalized functions (maps 0-100 to 0-255)
  ############################################
  def rq_set_force_norm(force_norm, gripper_socket="1"):
      force_gripper = norm_to_gripper(force_norm)
      rq_set_force(force_gripper, gripper_socket)
  end
  
  def rq_set_speed_norm(speed_norm, gripper_socket="1"):
      speed_gripper = norm_to_gripper(speed_norm)
      rq_set_speed(speed_gripper, gripper_socket)
  end
  
  def rq_move_norm(pos_norm, gripper_socket="1"):
      pos_gripper = norm_to_gripper(pos_norm)
      rq_move(pos_gripper, gripper_socket)
  end
  
  def rq_move_and_wait_norm(pos_norm, gripper_socket="1"):
      pos_gripper = norm_to_gripper(pos_norm)
      rq_move_and_wait(pos_gripper, gripper_socket)
  end
  
  def rq_set_pos_norm(pos_norm, gripper_socket="1"):
      pos_gripper = norm_to_gripper(pos_norm)
      rq_set_pos(pos_gripper, gripper_socket)
  end
  
  def rq_current_pos_norm(gripper_socket="1"):
      pos_gripper = rq_current_pos(gripper_socket)
      pos_norm = gripper_to_norm(pos_gripper)
      return pos_norm
  end
  
  def gripper_to_norm(value_gripper):
      value_norm = (value_gripper / 255) * 100
      return floor(value_norm)
  end
  
  def norm_to_gripper(value_norm):
      value_gripper = (value_norm / 100) * 255
      return ceil(value_gripper)
  end
  
  def rq_get_position():
      return rq_current_pos_norm()
  end
  
  def rq_gripper_led_on(gripper_socket="1"):
      rq_set_var("LBP",0, gripper_socket)
  end
  
  def rq_gripper_led_off(gripper_socket="1"):
      rq_set_var("LBP",1, gripper_socket)
      rq_set_var("LRD",0, gripper_socket)
      rq_set_var("LBL",0, gripper_socket)
      rq_set_var("LGN",0, gripper_socket)
  end
  
  def rq_gripper_led_force_red(gripper_socket="1"):
      rq_set_var("LBP",1, gripper_socket)
      rq_set_var("LRD",1, gripper_socket)
      rq_set_var("LBL",0, gripper_socket)
      rq_set_var("LGN",0, gripper_socket)
  end
  
  def rq_gripper_led_force_blue(gripper_socket="1"):
      rq_set_var("LBP",1, gripper_socket)
      rq_set_var("LRD",0, gripper_socket)
      rq_set_var("LBL",1, gripper_socket)
      rq_set_var("LGN",0, gripper_socket)
  end
  
  def rq_gripper_led_force_green(gripper_socket="1"):
      rq_set_var("LBP",1, gripper_socket)
      rq_set_var("LRD",0, gripper_socket)
      rq_set_var("LBL",0, gripper_socket)
      rq_set_var("LGN",1, gripper_socket)
  end
  
  def rq_gripper_led_force_purple(gripper_socket="1"):
      rq_set_var("LBP",1, gripper_socket)
      rq_set_var("LRD",1, gripper_socket)
      rq_set_var("LBL",1, gripper_socket)
      rq_set_var("LGN",0, gripper_socket)
  end
  
  ############################################
  # mm/inches functions
  ############################################
  gripper_closed_norm = [100, 100, 100, 100]
  gripper_open_norm = [0, 0, 0, 0]
  gripper_closed_mm = [0, 0, 0, 0]
  gripper_open_mm = [50, 50, 50, 50]
  
  def rq_current_pos_mm(gripper_socket=1):
      pos_gripper = rq_current_pos(gripper_socket)
      pos_mm = gripper_to_mm(pos_gripper, gripper_socket)
      return round_value_2_dec(pos_mm)
  end
  
  def rq_current_pos_inches(gripper_socket=1):
      pos_gripper = rq_current_pos(gripper_socket)
      pos_mm = gripper_to_mm(pos_gripper, gripper_socket)
      pos_in = pos_mm / 25.4
      return round_value_2_dec(pos_in)
  end
  
  def rq_move_mm(pos_mm, gripper_socket=1):
      pos_gripper = mm_to_gripper(pos_mm, gripper_socket)
      rq_move(pos_gripper, gripper_socket)
  end
  
  def rq_move_and_wait_mm(pos_mm, gripper_socket=1):
      pos_gripper = mm_to_gripper(pos_mm, gripper_socket)
      rq_move_and_wait(pos_gripper, gripper_socket)
  end
  
  def rq_move_inches(pos_in, gripper_socket=1):
      pos_mm = pos_in * 25.4
      rq_move_mm(pos_mm, gripper_socket)
  end
  
  def rq_move_and_wait_inches(pos_in, gripper_socket=1):
      pos_mm = pos_in * 25.4
      rq_move_and_wait_mm(pos_mm, gripper_socket)
  end
  
  def get_closed_norm(gripper_socket):
      return gripper_closed_norm[gripper_socket - 1]
  end
  
  def get_open_norm(gripper_socket):
      return gripper_open_norm[gripper_socket - 1]
  end
  
  def get_closed_mm(gripper_socket):
      return gripper_closed_mm[gripper_socket - 1]
  end
  
  def get_open_mm(gripper_socket):
      return gripper_open_mm[gripper_socket - 1]
  end
  
  def set_closed_norm(closed_norm, gripper_socket):
      gripper_closed_norm[gripper_socket - 1] = closed_norm
  end
  
  def set_open_norm(open_norm, gripper_socket):
      gripper_open_norm[gripper_socket - 1] = open_norm
  end
  
  def set_closed_mm(closed_mm, gripper_socket):
      gripper_closed_mm[gripper_socket - 1] = closed_mm
  end
  
  def set_open_mm(open_mm, gripper_socket):
      gripper_open_mm[gripper_socket - 1] = open_mm
  end
  
  def gripper_to_mm(value_gripper, gripper_socket):
      closed_norm = get_closed_norm(gripper_socket)
      open_norm = get_open_norm(gripper_socket)
      closed_mm = get_closed_mm(gripper_socket)
      open_mm = get_open_mm(gripper_socket)
  
      value_norm = (value_gripper / 255) * 100
  
      slope = (closed_mm - open_mm) / (closed_norm - open_norm)
      value_mm = slope * (value_norm - closed_norm) + closed_mm
  
      if (value_mm > open_mm):
          value_mm_limited = open_mm
      elif (value_mm < closed_mm):
          value_mm_limited = closed_mm
      else:
          value_mm_limited = value_mm
      end
  
      return value_mm_limited
  end
  
  def mm_to_gripper(value_mm, gripper_socket):
      closed_norm = get_closed_norm(gripper_socket)
      open_norm = get_open_norm(gripper_socket)
      closed_mm = get_closed_mm(gripper_socket)
      open_mm = get_open_mm(gripper_socket)
  
      slope = (closed_norm - open_norm) / (closed_mm - open_mm)
      value_norm = (value_mm - closed_mm) * slope + closed_norm
  
      value_gripper = value_norm * 255 / 100
  
      if (value_gripper > 255):
          value_gripper_limited = 255
      elif (value_gripper < 0):
          value_gripper_limited = 0
      else:
          value_gripper_limited = round_value(value_gripper)
      end
  
      return value_gripper_limited
  end
  
  def round_value(value):
      value_mod = value % 1
  
      if(value_mod < 0.5):
          return floor(value)
      else:
          return ceil(value)
      end
  end
  
  def round_value_2_dec(value):
      value_x_100 = value * 100
      value_x_100_rounded = round_value(value_x_100)
      return value_x_100_rounded / 100
  end
  
  def clear_socket_buffer(gripper_socket="1", read_timeout = 0.1):
      rq_comm_clear_socket_buffer_enabled[rq_socket_to_index(gripper_socket)] = True
  end
  
  def rq_gripper_id_to_ascii(gripper_id):
      if(gripper_id == "1"):
          return 57
      elif(gripper_id == "2"):
          return 50
      elif(gripper_id == "3"):
          return 51
      elif(gripper_id == "4"):
          return 52
      end
  end
  
  def scale(value, rawRange, scaledRange):
      def computeSlope(inputRange, outputRange):
          outputRangeDelta = outputRange[1] - outputRange[0]
          inputRangeDelta = inputRange[1] - inputRange[0]
  
          if (inputRangeDelta == 0):
              return 0
          else:
              return outputRangeDelta / inputRangeDelta
          end
      end
  
      def computeIntercept(slope, inputRange, outputRange):
          return outputRange[0] - (slope * inputRange[0])
      end
  
      def clipScaledValue(outputScaledValue, outputRange):
          if (outputRange[0] < outputRange[1]):
              return clipWhenLowerLimitIsLessThanHigher(outputScaledValue, outputRange)
          else:
              return clipWhenLowerLimitIsGreaterThanHigherLimit(outputScaledValue, outputRange)
          end
      end
  
      def clipWhenLowerLimitIsGreaterThanHigherLimit(outputScaledValue, outputRange):
          if (outputScaledValue < outputRange[1]):
              return outputRange[1]
          elif (outputScaledValue > outputRange[0]):
              return outputRange[0]
          else:
              return outputScaledValue
          end
      end
  
      def clipWhenLowerLimitIsLessThanHigher(outputScaledValue, outputRange):
          if (outputScaledValue < outputRange[0]):
              return outputRange[0]
          elif (outputScaledValue > outputRange[1]):
              return outputRange[1]
          else:
              return outputScaledValue
          end
      end
  
      slope = computeSlope(rawRange, scaledRange)
      intercept = computeIntercept(slope, rawRange, scaledRange)
      scaledValue = slope * value + intercept
      return clipScaledValue(scaledValue, scaledRange)
  end
  
  def limit(value, range):
      return scale(value, range, range)
  end
  
  
  rq_init_comm_if_connected(9, "1")
  rq_init_comm_if_connected(2, "2")
  rq_init_comm_if_connected(3, "3")
  rq_init_comm_if_connected(4, "4")
  rq_print_connected_grippers()
  rq_gripper_communication_thread = run rq_gripper_communication()
  set_closed_norm(100.0, 1)
  set_open_norm(0.0, 1)
  set_closed_mm(0.0, 1)
  set_open_mm(50.0, 1)
  set_closed_norm(100.0, 2)
  set_open_norm(0.0, 2)
  set_closed_mm(0.0, 2)
  set_open_mm(50.0, 2)
  set_closed_norm(100.0, 3)
  set_open_norm(0.0, 3)
  set_closed_mm(0.0, 3)
  set_open_mm(50.0, 3)
  set_closed_norm(100.0, 4)
  set_open_norm(0.0, 4)
  set_closed_mm(0.0, 4)
  set_open_mm(50.0, 4)
  rq_current_limit_enabled = False
  while(not rq_gripper_communication_thread_started):
      sleep(0.008)
  end
  # end: URCap Installation Node
  $ 1 "BeforeStart"
  $ 2 "Script: agscript_util.script"
  # File: agscript_util.script
  # Project: AutoGrind
  # Author: Ned Lecky, Lecky Engineering LLC
  # Purpose: General utility functions used in AutoGrind
  
  global robot_util_version = "2022-06-13"
  
  # Return max of 2 numeric values
  def max(n1, n2):
    if n1 > n2:
      return n1
    else:
      return n2
    end
  end
  
  # Return min of 2 numeric values
  def min(n1, n2):
    if n1 < n2:
      return n1
    else:
      return n2
    end
  end
  
  # Return absolute value of a numeric value
  def abs(n):
    if n < 0:
      return -n
    else:
      return n
    end
  end
  
  # Return v1 --> v2 based on x 0 --> 1
  def linear_slider(v1, v2, x):
    local m = v2 - v1
    return v1 + m * x
  end
  
  # Adjust the value x by pct
  def adjust_pct(x, pct):
    return x * (1.0 + pct / 100.0)
  end
  
  # Return param limited to lowLim <= param <= hiLim
  def limiter(param, loLim, hiLim):
    if param < loLim:
      return loLim
    elif param > hiLim:
      return hiLim
    else:
      return param
    end
  end
  
  # Send LF out the socket
  def socket_send_lf():
    socket_send_byte(10)
  end
  
  # Send "SET name ivalue" out the socket. Assumes ints
  # Built-in function does this!
  def socket_send_integer(name, ivalue):
    socket_set_var(name, ivalue)
  end
  
  # Send "name=value" out the socket. Works on ints or floats
  def socket_send_num(name, value):
    enter_critical
    socket_send_string(name + "=")
    socket_send_line(value)
    exit_critical
  end
  
  # Send "name=True" or "name=False" out the socket based on f
  def socket_send_bool(name, f):
    enter_critical
    socket_send_string(name + "=")
    if (f):
      socket_send_line("True")
    else:
      socket_send_line("False")
    end
    exit_critical
  end
  
  # Send name=[   ] out the secket for vector with length
  def socket_send_vector(name, vector, length, is_pose = False):
    enter_critical
    socket_send_string(name + "=")
    if is_pose:
      socket_send_string("p")
    end
    socket_send_vector_only(vector, length)
    socket_send_lf()
    exit_critical
  end
  
  
  # Send n-vectors back to socket as [n,n,n,n,n,n]
  def socket_send_vector_only(p, n = 6):
    socket_send_string("[")
    i = 0
    while i < n:
      if i > 0:
        socket_send_string(",")
      end
      socket_send_string(p[i])
      i = i + 1
    end
    socket_send_string("]")
  end
  
  # Return a 6-element vector to socket as a pose name=p[.....]
  def socket_send_pose(name, p):
    socket_send_vector(name, p, 6, True)
  end
  
  # Return a 6-element vector to socket as joint angles name=[.....]
  def socket_send_joints(name, p):
    socket_send_vector(name, p, 6, False)
  end
  
  # Special support to receive 1-4 port,value pairs and always pad with -1s to make 4 pairs
  # Essentially returns command[3:end] padded out with -1s to always be 8 elements
  # Assumes length of command is specified in command[0]
  def command_3_padded_8(command):
    ret8 = [-1, -1, -1, -1, -1, -1, -1, -1]
    i = 0
    while i < command[0]-2:
      ret8[i] = command[i + 3]
      i = i + 1
    end
    return ret8
  end
  $ 3 "Script: agscript_robot-2.script"
  # File: agscript_robot-2.script
  # Project: AutoGrind
  # Author: Ned Lecky, Lecky Engineering LLC
  # Purpose: Robot control commands supporting the AutoGrind application
  
  global robot_version = "Rev 2 2022-06-13"
  
  global response = "unknown"
  global robot_index = 0
  global robot_checkvalue = 0
  
  global robot_linear_speed_mps = 0.2
  global robot_linear_accel_mpss = 0.4
  global robot_blend_radius_m = 0.003
  global robot_joint_speed_rps = 1.0
  global robot_joint_accel_rpss = 4.0
  global robot_tcp = p[0, 0, 0.175, 0, 0, 0]
  global robot_tcp_part = robot_tcp
  global robot_payload_mass_kg = 1.0
  global robot_payload_cog_m = [0, 0, 0.50]
  # Geometry [1=FLAT 2=CYL 3=SPHERE, diameter_mm)
  global robot_part_geometry = [0, 0]
  global robot_door_closed_input = [-1, -1]
  global robot_footswitch_pressed_input = [-1, -1]
  global robot_tool_on_outputs = [-1, -1, -1, -1, -1, -1, -1, -1]
  global robot_tool_off_outputs = [-1, -1, -1, -1, -1, -1, -1, -1]
  global robot_coolant_on_outputs = [-1, -1, -1, -1, -1, -1, -1, -1]
  global robot_coolant_off_outputs = [-1, -1, -1, -1, -1, -1, -1, -1]
  global robot_freedrive_mode = 0
  
  def init_autogrind():
    init_cycline_coeffs()
  end
  
  # command should be[nElements,index,checkval,param[0],param[1],...]
  # put index into robot_index
  # validate checkval
  # Remove both from command so we get command = [nElements-2, param[0], param[1],...]
  #global command = [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]
  def command_validate():
    # must be at least index, check, and 1 param
    if command[0] < 3:
      command[0] = 0
      return False
    end
  
    # Now make sure checksum matches what we expect
    global test_index = command[1]
    global test_checksum = command[2]
    if test_checksum != 1000 - test_index:
      command[0] = 0
      return False
    end
  
    # Now if we are still in the grind state and we are not getting a grind command (40) make sure we're are off the part!
    if grind_process_state and command[3] != 40:
      # Using set_grind_process_state which assumes robot_tcp_part!
      iset_tcp(robot_tcp_part)
      set_grind_process_state(False)
      iset_tcp(robot_tcp)
    end
  
    # Slide the robot commands and parameters back in command[] to remove the index and checksum
    local i = 3
    while (i < command[0] + 1):
      command[i-2] = command[i]
      i = i + 1
    end
    command[i-1] = 0
    command[i-2] = 0
    command[0] = command[0] - 2    # 2 fewer elements in the array now!
  
    global robot_index = test_index
    return True
  end
  
  # Call this when starting command execution
  def command_start():
    global last_comand = command
  
    # This one signifies we're starting a new command!
    global robot_starting = robot_index
    socket_send_integer("robot_starting", robot_starting)
    socket_send_bool("robot_ready", False)
  end
  
  # Call this when a command is complete
  def command_finish():
    local retval = "robot_response=" + response + "#robot_ready=True"
    socket_send_line(retval)
  
    global robot_completed = robot_index
    socket_send_integer("robot_completed", robot_completed)
  end
  
  # Set variable interface. Interprets command[2] to select what to set and returns result to socket
  # Can also be used for validation and enforcing limits
  def set_variable():
    if command[2] == 1:
      # Set speed to s if s>0. Always returns current value
      s = command[3]
      if s > 0:
        robot_linear_speed_mps = ceil(s) / 1000.0
      end
      socket_send_integer("robot_linear_speed_mmps", robot_linear_speed_mps * 1000.0)
      global response = "set_linear_speed()"
    elif command[2] == 2:
      # Set accel to a if a>0. Always returns current value
      a = command[3]
      if a > 0:
        robot_linear_accel_mpss = ceil(a) / 1000.0
      end
      socket_send_integer("robot_linear_accel_mmpss", robot_linear_accel_mpss * 1000.0)
      global response = "set_linear_accel()"
    elif command[2] == 3:
      # Set blend to b if b>=0. Always returns current value
      b = command[3]
      if b >= 0:
        robot_blend_radius_m = b / 1000.0
      end
      # No socket_send_integer since we allow to 0.1mm!
      socket_send_num("robot_blend_radius_mm", robot_blend_radius_m * 1000.0)
      global response = "set_blend_radius()"
    elif command[2] == 4:
      # Set joint speed to s if s>0. Always returns current value
      s = command[3]
      if s > 0:
        robot_joint_speed_rps = d2r(ceil(s))
      end
      socket_send_integer("robot_joint_speed_dps", r2d(robot_joint_speed_rps))
      global response = "set_joint_speed()"
    elif command[2] == 5:
      # Set joint accel to a if a>0. Always returns current value
      a = command[3]
      if a > 0:
        robot_joint_accel_rpss = d2r(ceil(a))
      end
      socket_send_integer("robot_joint_accel_dpss", r2d(robot_joint_accel_rpss))
      global response = "set_joint_accel()"
    elif command[2] == 6:
      # Set part_geometry to [shape, diameter_mm] if shape==1,2,3. Always returns "robot_part_geometry=[current geometry]"
      # Also updates robot_part_tcp using update_robot_tcp_part
      shape = command[3]
      if shape == 1:
        robot_part_geometry = [1, 0]
      elif shape == 2 or shape == 3:
        diameter_mm = limiter(command[4], 50, 3000)
        robot_part_geometry = [shape, diameter_mm]
        # Put in the cyline corrections if this is a cylinder
        if shape == 2:
          default_cyline_cal(diameter_mm)
        end
      end
      update_robot_tcp_part()
      socket_send_vector("robot_part_geometry", robot_part_geometry, 2)
      global response = "set_part_geometry()"
    elif command[2] == 10:
      # Set door closed input
      if command[3] >= 0:
        robot_door_closed_input[0] = command[3]
        robot_door_closed_input[1] = command[4]
      end
      socket_send_vector("robot_door_closed_input", robot_door_closed_input, 2)
      socket_send_bool("robot_door_closed", is_door_closed())
      global response = "set_door_closed_input()"
    elif command[2] == 11:
      # Set tool on output
      robot_tool_on_outputs = command_3_padded_8(command)
      socket_send_vector("robot_tool_on_outputs", robot_tool_on_outputs, 8)
      global response = "set_tool_on_outputs()"
    elif command[2] == 12:
      # Set tool off output
      robot_tool_off_outputs = command_3_padded_8(command)
      socket_send_vector("robot_tool_off_outputs", robot_tool_off_outputs, 8)
      global response = "set_tool_off_outputs()"
    elif command[2] == 13:
      # Set coolant on output
      robot_coolant_on_outputs = command_3_padded_8(command)
      socket_send_vector("robot_coolant_on_outputs", robot_coolant_on_outputs, 8)
      global response = "set_coolant_on_outputs()"
    elif command[2] == 14:
      # Set coolant off output
      robot_coolant_off_outputs = command_3_padded_8(command)
      socket_send_vector("robot_coolant_off_outputs", robot_coolant_off_outputs, 8)
      global response = "set_coolant_off_outputs()"
    elif command[2] == 15:
      # tool_on
      tool_power(True, 2)
      global response = "tool_on()"
    elif command[2] == 16:
      # tool_off
      tool_power(False, 2)
      global response = "tool_off()"
    elif command[2] == 17:
      # coolant_on
      coolant_flow(True, 2)
      global response = "coolant_on()"
    elif command[2] == 18:
      # coolant_off
      coolant_flow(False, 2)
      global response = "coolant_off()"
    elif command[2] == 19:
      # freedrive 1=on/0=off, 0=base|1=tcp|2=tcp_part, 6 axisEnables
      if command[3] == 0:
        end_freedrive_mode()
        iset_tcp(robot_tcp)
        robot_freedrive_mode = 0
        socket_send_integer("robot_freedrive_mode", robot_freedrive_mode)
      else:
        local coordSys = command[4]
        local freeAxes = [command[5], command[6], command[7], command[8], command[9], command[10]]
        if coordSys == 1:
          iset_tcp(robot_tcp)
          freedrive_mode(freeAxes = freeAxes, feature = "tool")
        elif coordSys == 2:
          iset_tcp(robot_tcp_part)
          freedrive_mode(freeAxes = freeAxes, feature = "tool")
        else:
          # Base
          freedrive_mode(freeAxes = freeAxes)
        end
        robot_freedrive_mode = 1
        socket_send_integer("robot_freedrive_mode", robot_freedrive_mode)
      end
      global response = "freedrive_mode()"
    elif command[2] == 20:
      # set_tcp if command[3] > -10. Always returns robot_tcp=p[...]
      if command[3] > -10:
        robot_tcp = p[command[3], command[4], command[5], command[6], command[7], command[8]]
        iset_tcp(robot_tcp)
      end
      socket_send_pose("robot_tcp", get_tcp_offset())
      # Recompute robot_tcp_part based on current geometry
      update_robot_tcp_part()
      global response = "set_tcp()"
    elif command[2] == 21:
      # set_payload if command[3] > 0. Always return robot_m and robot_cog
      if command[3] > 0:
        robot_payload_mass_kg = command[3]
        robot_payload_cog_m = [command[4], command[5], command[6]]
        iset_payload(robot_payload_mass_kg, robot_payload_cog_m)
      end
      socket_send_num("robot_payload_mass_kg", robot_payload_mass_kg)
      socket_send_vector("robot_payload_cog_m", robot_payload_cog_m, 3)
      global response = "set_payload()"
    elif command[2] == 22:
      # Set footswitch pressed input
      if command[3] >= 0:
        robot_footswitch_pressed_input[0] = command[3]
        robot_footswitch_pressed_input[1] = command[4]
      end
      socket_send_vector("robot_footswitch_pressed_input", robot_footswitch_pressed_input, 2)
      socket_send_bool("robot_footswitch_pressed", is_footswitch_pressed())
      global response = "set footswitch_pressed_input()"
    elif command[2] == 30:
      # set_output
      local out = command[3]
      local state = command[4] > 0
      set_digital_out(out, state)
      global response = "set_output()"
    elif command[2] == 40:
      # zero_cal_timers
      zero_cal_timers()
      global response = "zero_cal_timers()"
    elif command[2] == 41:
      # default_cyline_cal
      local diam = limiter(command[3], 100, 3000)
      default_cyline_cal(diam)
      global response = "default_cyline_cal()"
    elif command[2] == 42:
      # unity_cyline_cal
      unity_cyline_cal()
      global response = "unity_cyline_cal()"
    elif command[2] == 43:
      # return_cyline_cal
      return_cyline_cal()
      global response = "return_cyline_cal()"
    elif command[2] == 44:
      # enable_cyline_cal
      local f = command[3] > 0
      enable_cyline_cal(f)
      socket_send_bool("cyline_cal_enabled", cyline_cal_enabled)
      global response = "enable_cyline_cal()"
    elif command[2] == 45:
      # set_cyline_training_weight
      local weight = limiter(command[3], 1, 100)
      set_cyline_training_weight(weight)
      socket_send_num("cyline_training_weight", cyline_training_weight)
      global response = "set_cyline_training_weight()"
    elif command[2] == 46:
      # set_cyline_expected_time
      local t = limiter(command[3], 1, 1000)
      set_cyline_expected_time(t)
      socket_send_num("cyline_expected_time", cyline_expected_time)
      global response = "cyline_expected_time()"
    elif command[2] == 47:
      # set_cyline_deadband_time
      local t = limiter(command[3], 0, 100)
      set_cyline_deadband_time(t)
      socket_send_num("cyline_deadband_time", cyline_deadband_time)
      global response = "set_cyline_deadband_time()"
    elif command[2] == 48:
      # new_cyline_cycle
      new_cyline_cycle()
      global response = "new_cyline_cycle()"
    elif command[2] == 50:
      # enable_user_timers
      local f = command[3] > 0
      enable_user_timers(f)
      global response = "enable_user_timers()"
    elif command[2] == 51:
      # zero_user_timers
      zero_user_timers()
      return_user_timers()
      global response = "zero_user_timers()"
    elif command[2] == 52:
      # return_user_timers
      return_user_timers()
      global response = "return_user_timers()"
    else:
      global response = "set_variable ERROR"
    end
  end
  
  # Compute appropriate robot_tcp for the part based on robot_tcp and robot_part_geometry
  # They're the same for flat parts, but the TCP is adjusted to the center of the cylinder or sphere
  def update_robot_tcp_part():
    shape = robot_part_geometry[0]
    if shape == 1:  # Flat
      robot_tcp_part = robot_tcp
    else:  # Cylinder or Sphere
      robot_tcp_part = pose_trans(robot_tcp, p[0, 0, robot_part_geometry[1] / 2000.0, 0, 0, 0])
    end
    socket_send_pose("robot_tcp_part", robot_tcp_part)
  end
  
  # Send get_tcp_offset() result to socket
  def return_tcp_offset():
    p = get_tcp_offset()
    socket_send_pose("tcp_offset", p)
    global response = "return_tcp_offset()"
  end
  
  # Send get_actual_tcp_pose() to socket
  def return_actual_tcp_pose():
    p = iget_actual_tcp_pose()
    socket_send_pose("actual_tcp_pose", p)
    global response = "return_actual_tcp_pose()"
  end
  
  # Send get_actual_joint_positions() to socket
  def return_get_actual_joint_positions():
    p = iget_actual_joint_positions()
    socket_send_joints("actual_joint_positions", p)
    global response = "return_get_actual_joint_positions()"
  end
  
  # Send both joints and pose to socket labeled position_p and position_q
  def return_both_positions():
    socket_send_joints("position_q", iget_actual_joint_positions())
    socket_send_pose("position_p", iget_actual_tcp_pose())
    global response = "return_both_positions()"
  end
  
  # Movel relatively in base coordinates
  def movel_relative_base(p1):
    local p0 = iget_target_tcp_pose()
    local p2 = pose_add(p0, p1)
    if p1[0] == 0 and p1[1] == 0 and p1[2] == 0:  # Rotational move
      imovel(p2, robot_joint_accel_rpss, robot_joint_speed_rps)
    else:
      imovel(p2, robot_linear_accel_mpss, robot_linear_speed_mps)
    end
    global response = "movel_relative_base()"
  end
  
  # Movel relatively in TCP coordinates
  def movel_relative_tcp(p1):
    forced_speed_setter(robot_linear_speed_mps * 1000.0)
    draw_origin(iget_target_tcp_pose())
    draw_to(p1)
    global response = "movel_relative_tcp()"
  end
  
  # Movel relatively in TCP_part coordinates
  def movel_relative_tcp_part(p1):
    iset_tcp(robot_tcp_part)
    forced_speed_setter(robot_linear_speed_mps * 1000.0)
    draw_origin(iget_target_tcp_pose())
    draw_to(p1)
    iset_tcp(robot_tcp)
    global response = "movel_relative_tcp_part()"
  end
  
  # Change one element of current pose and movel there
  def movel_one_only(index = 0, val = 0):
    local p = iget_target_tcp_pose()
    p[index] = val
    if index < 3:  # Translational
      imovel(p, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
    else:
      imovel(p, a = robot_joint_accel_rpss, v = robot_joint_speed_rps)
    end
    global response = "movel_one_only()"
  end
  
  # Change only rotation elements of current pose and movel there
  def movel_rot_only(r1 = 0, r2 = 0, r3 = 0):
    local p = iget_target_tcp_pose()
    p[3] = r1
    p[4] = r2
    p[5] = r3
    imovel(p, a = robot_joint_accel_rpss, v = robot_joint_speed_rps)
    global response = "movel_rot_only()"
  end
  
  # Movej to position (works with joints or poses)
  def movej_ag(p):
    imovej(p, a = robot_joint_accel_rpss, v = robot_joint_speed_rps)
    global response = "movej_ag()"
  end
  
  # Movel to position (works with joints or poses)
  def movel_ag(p):
    imovel(p, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
    global response = "movel_ag()"
  end
  
  # ####################################################################################
  # Interrupting Motion
  # Motion and force_mode and part contact muct all end if any of 3 things happen
  #  1) Door is opened
  #  2) We're in contact with the part and grinding, but no grind command comes within some time (default 1.5s)
  #  3) We receive an abort message from the host
  #
  # How is it implemented?
  #
  # 1) io_monitor_thread (below) is ALWAYS running. Fires every time_door_check_rate_s (0.25s)
  #    - Whenever it sees the state of the door change, it sends SET robot_door_closed state to host
  #    - Whenever it sees the state of the footswitch (DIN7) change, it sends SET robot_footswitch state to host
  #    - It monitors if we're still in contact wth the part butr not grinding (grind_process_state and grind_ready)
  #      - If that goes beyond grind_max_wait_ms it sets halt_grind=True
  # 2) no_command function (below). Called by PolScript everyu time it's waiting for a command and doesn't get one with a second
  #    - If halt_grind is set (by door monitor thread above)
  #      - stopl and simulate receiving a grind_retract
  #      - THIS FORCES THE force_off and motion commands to come from the primary thread, as they must
  # 3) listener_thread started by grind()
  #    - This runs only while a grind is in progress
  #    - It listens for commands from the host since PolyScope is blocked
  #    - Any command received increments halt_count which makes ok_to_proceed() false
  #    - That is checked in all the grinding programs and forces them to finish up and get off the part in an orderly fashion
  
  # ####################################################################################
  # START AUTOMATED DOOR MONITORING THREAD
  #
  # Return True if door in closed state (or if door input is undefined)
  def is_door_closed():
    if robot_door_closed_input[0] < 0:
      return True
    end
    if get_standard_digital_in(robot_door_closed_input[0]):
      f = 1
    else:
      f = 0
    end
    return f == robot_door_closed_input[1]
  end
  
  # Return True if footswitch pressed (or False if footswitch input is undefined)
  def is_footswitch_pressed():
    if robot_footswitch_pressed_input[0] < 0:
      return False
    end
    if get_standard_digital_in(robot_footswitch_pressed_input[0]):
      f = 1
    else:
      f = 0
    end
    return f == robot_footswitch_pressed_input[1]
  end
  
  global robot_door_closed = is_door_closed()
  global robot_footswitch_pressed = is_footswitch_pressed()
  global time_in_uncommanded_grind = 0
  global time_door_check_rate_s = 0.250
  global grind_max_wait_ms = 1500
  # Also monitors footswitch!
  thread io_monitor_thread():
    # Send current state on start... in future will only be sent on change
    socket_send_bool("robot_door_closed", robot_door_closed)
    socket_send_bool("robot_footswitch_pressed", robot_footswitch_pressed)
  
    while True:
      sleep(time_door_check_rate_s)
      local new_door_closed = is_door_closed()
      local new_footswitch_pressed = is_footswitch_pressed()
  
      # Notify host if door state has changed
      if robot_door_closed != new_door_closed:
        robot_door_closed = new_door_closed
        socket_send_bool("robot_door_closed", robot_door_closed)
      end
  
      # Notify host if footswitch state has changed
      if robot_footswitch_pressed != new_footswitch_pressed:
        robot_footswitch_pressed = new_footswitch_pressed
        socket_send_bool("robot_footswitch_pressed", robot_footswitch_pressed)
      end
  
      # Check for still in grind process but not executing a grind command
      # This is what happens after a grind_...(....,1) executes while waiting for next command
      if grind_process_state and grind_ready:
        time_in_uncommanded_grind = time_in_uncommanded_grind + time_door_check_rate_s
        # No new grind commands for grind_max_wait_ms... schedule a grind_retract!
        if time_in_uncommanded_grind > grind_max_wait_ms / 1000.0:
          global halt_grind = True
        end
      else:
        time_in_uncommanded_grind = 0
      end
      sync()
    end
  end
  global ioMonitorThread = run io_monitor_thread()
  #
  # END AUTOMATED DOOR MONITORING THREAD
  # ####################################################################################
  
  # ####################################################################################
  # START NO_COMMAND HOUSEKEEPING
  # This gets called when the PolyScope receives no command (about 1/second)
  # We can fire off any command here safely since no others will be seen until we exit
  #
  global no_command_count = 0
  global halt_grind = False
  def no_command():
    global no_command_count = no_command_count + 1
  
    if grind_process_state and grind_ready and halt_grind:
      halt_grind = False
      istopl(20)
  
      iset_tcp(robot_tcp_part)
      set_grind_process_state(False)
      iset_tcp(robot_tcp)
    end
  end
  #
  # END NO_COMMAND HOUSEKEEPING
  # ####################################################################################
  
  # ####################################################################################
  # START OLD TOUCHOFF HANDLER
  #
  def calculate_point_to_move_towards_old(feature, direction, position_distance):
    local posDir = [direction[0], direction[1], direction[2]]
    if (norm(posDir) < 1e-6):
      return get_target_waypoint()
    end
    local direction_vector_normalized = normalize(posDir)
    local displacement_pose = p[direction_vector_normalized[0] * position_distance, direction_vector_normalized[1] * position_distance, direction_vector_normalized[2] * position_distance, 0, 0, 0]
    local wanted_displacement_in_base_frame = pose_sub(pose_trans(feature, displacement_pose), feature)
    return pose_add(get_target_waypoint(), wanted_displacement_in_base_frame)
  end
  #$ 7 "Robot Program"
  #$ 8 "MoveL"
  #$ 9 "Direction: Tool Z+"
  global move_thread_flag = 0
  global move_thread_approach_speed_mps = 0.01
  thread move_thread_old():
    enter_critical
    move_thread_flag = 1
    local towardsPos = calculate_point_to_move_towards_old(get_forward_kin(), [0.0, 0.0, 1.0], 0.025)
    imovel(towardsPos, a = 0.5, v = move_thread_approach_speed_mps)
    move_thread_flag = 2
    exit_critical
  end
  
  # Currently using speed_mmps for both approach and 2X for departure
  def touchoff_old(approach_speed_mmps, retract_mm):
    approach_speed_mps = approach_speed_mmps / 1000.0
    global move_thread_approach_speed_mps = approach_speed_mps
  
    retract_speed_mps = approach_speed_mps * 2.0
  
    retract_m = retract_mm / 1000.0
  
    move_thread_flag = 0
    move_thread_han = run move_thread_old()
    while (True):
      local targetTcpDirection = get_target_tcp_speed()
      local stepsToRetract = tool_contact(direction = targetTcpDirection)
      if (stepsToRetract > 0):
        kill move_thread_han
        #imover_restart()
        #istopl(20)
        local backTrackMovement = get_actual_joint_positions_history(stepsToRetract)
        local contactPose = get_forward_kin(backTrackMovement)
        local posDir = [targetTcpDirection[0], targetTcpDirection[1], targetTcpDirection[2]]
        local retractTo = contactPose
        if (norm(posDir) > 1e-6):
          local normalizedPosDir = normalize(posDir)
          local additionalRetraction = p[normalizedPosDir[0] * retract_m, normalizedPosDir[1] * retract_m, normalizedPosDir[2] * retract_m, 0, 0, 0]
          retractTo = pose_sub(contactPose, additionalRetraction)
        end
        imovel(retractTo, a = 1.0, v = retract_speed_mps)
        #$ 10 "Until (tool_contact_detection)"
        return True
        break
      end
      sleep(1.0E-10)
      if (move_thread_flag > 1):
        join move_thread_han
        #$ 11 "Until (distance)"
        #$ 12 "Popup: No part encountered"
        #popup("No part encountered", "Message", False, False, blocking = True)
        return False
        break
      end
      sync()
    end
    return False
  end
  #
  # END OLD TOUCHOFF HANDLER
  # ####################################################################################
  
  # ####################################################################################
  # START NEW TOUCHOFF HANDLER
  #
  def calculate_point_to_move_towards(feature, direction, position_distance):
    local posDir = [direction[0], direction[1], direction[2]]
    if (norm(posDir) < 1e-6):
      return get_target_waypoint()
    end
    local direction_vector_normalized = normalize(posDir)
    local displacement_pose = p[direction_vector_normalized[0] * position_distance, direction_vector_normalized[1] * position_distance, direction_vector_normalized[2] * position_distance, 0, 0, 0]
    local wanted_displacement_in_base_frame = pose_sub(pose_trans(feature, displacement_pose), feature)
    return pose_add(get_target_waypoint(), wanted_displacement_in_base_frame)
  end
  #$ 7 "Robot Program"
  #$ 8 "MoveL"
  #$ 9 "Direction: Tool Z+"
  global move_thread_flag = 0
  global move_thread_approach_speed_mps = 0.01
  def move_nowait():
    move_thread_flag = 1
    local towardsPos = calculate_point_to_move_towards(get_forward_kin(), [0.0, 0.0, 1.0], 0.025)
    imovel_int(towardsPos, a = 0.5, v = move_thread_approach_speed_mps, wait = False)
    move_thread_flag = 2
  end
  
  # Currently using speed_mmps for both approach and 2X for departure
  def touchoff(approach_speed_mmps, retract_mm):
    approach_speed_mps = approach_speed_mmps / 1000.0
    global move_thread_approach_speed_mps = approach_speed_mps
  
    retract_speed_mps = approach_speed_mps * 2.0
  
    retract_m = retract_mm / 1000.0
  
    # Start non-blocking move: only works with imover_realtime!
    imover_realtime(True)
    move_nowait()
  
    while (True):
      local targetTcpDirection = get_target_tcp_speed()
      local stepsToRetract = tool_contact(direction = targetTcpDirection)
      if (stepsToRetract > 0):
        # Contact!
        imover_restart()
        local backTrackMovement = get_actual_joint_positions_history(stepsToRetract)
        local contactPose = get_forward_kin(backTrackMovement)
        local posDir = [targetTcpDirection[0], targetTcpDirection[1], targetTcpDirection[2]]
        local retractTo = contactPose
        if (norm(posDir) > 1e-6):
          local normalizedPosDir = normalize(posDir)
          local additionalRetraction = p[normalizedPosDir[0] * retract_m, normalizedPosDir[1] * retract_m, normalizedPosDir[2] * retract_m, 0, 0, 0]
          retractTo = pose_sub(contactPose, additionalRetraction)
        end
        imovel(retractTo, a = 1.0, v = retract_speed_mps)
        #$ 10 "Until (tool_contact_detection)"
        return True
        break
      end
      sleep(1.0E-10)
      if (imover_cmd == 0): # Done moving?
        # No part encountered
        return False
        break
      end
      sync()
    end
    return False
  end
  #
  # END NEW TOUCHOFF HANDLER
  # ####################################################################################
  
  # ####################################################################################
  # START IMOVER SYSTEM
  #
  global imover_realtime_enabled = True
  global imover_restart_count = 0
  global imover_kill_count = 0
  global imover_stopl_count = 0
  global imover_stopj_count = 0
  global imover_p = p[0, 0, 0, 0, 0, 0]
  global imover_q = [0, 0, 0, 0, 0, 0]
  global imover_a = 1.2
  global imover_v = 0.25
  global imover_t = 0
  global imover_r = 0
  global imover_ret_f = False
  global imover_force_on = False
  global imover_force_N = 5
  global imover_force_speed_mmps = 10
  global imover_tcp = p[0, 0, 0, 0, 0, 0]
  global imover_mass = 1.0
  global imover_cog = [0, 0, 0]
  global imover_thread_handle = 0
  global imover_cmd = 0
  global imover_cmd_hist = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  global imover_param1 = 0
  global imover_param2 = 0
  imover_PING = 1
  imover_MOVEL = 2
  imover_MOVEJ = 3
  imover_STOPL = 4
  imover_ZEROFORCE = 5
  imover_STARTFORCE = 6
  imover_UPDATEFORCE = 7
  imover_ENDFORCE = 8
  imover_GETACTUALTCPPOSE = 9
  imover_GETACTUALJOINTPOSITIONS = 10
  imover_GETTARGETTCPPOSE = 11
  imover_GETTARGETJOINTPOSITIONS = 12
  imover_SETTCP = 13
  imover_SETPAYLOAD = 14
  imover_TOUCHOFF = 15
  
  def imover_realtime(f = False):
    if f and (not imover_realtime_enabled):
      # Turning on separate imover thread
      imover_realtime_enabled = True
      imover_restart()
      #imover_state_alignment()    # Called by imover_restart()
    elif (not f) and imover_realtime_enabled:
      # Turning off separate imover thread
      imover_kill()
      imover_realtime_enabled = False
      imover_state_alignment()
    end
  end
  
  def imover_is_realtime():
    return imover_realtime_enabled
  end
  
  def imover_state_alignment():
    # Reestablish state of motion control in current thread
    iset_tcp(imover_tcp)
    iset_payload(imover_mass, imover_cog)
    if imover_force_on:
      iforce_mode(imover_force_N, imover_force_speed_mmps)
    else:
      iend_force_mode()
    end
  end
  
  # Kill the imover htread and insure motion is stopped
  def imover_kill():
    if imover_thread_handle > 0:
      kill imover_thread_handle
      imover_thread_handle = 0
      global imover_kill_count = imover_kill_count + 1
      sleep(0.05)
      stopl(20)
    end
  end
  
  def imover_restart():
    imover_kill()
  
    global imover_cmd = 0
    global imover_thread_handle = run imover_thread()
    sleep(0.2)
    # Reload state (tcp, payload, force mode...)
    imover_state_alignment()
    global imover_restart_count = imover_restart_count + 1
  end
  
  def imover_wait(terminate_not_ok = False):
    while imover_cmd > 0:
      if terminate_not_ok and not ok_to_proceed():
        return None
      end
      sync()
    end
  end
  
  def imover_cmd_exec(cmd, param1 = 0, param2 = 0, terminate_not_ok = False, wait_complete = True):
    imover_wait()
    global imover_param1 = param1
    global imover_param2 = param2
  
    local i = 9
    while i > 0:
      imover_cmd_hist[i] = imover_cmd_hist[i - 1]
      i = i - 1
    end
    imover_cmd_hist[0] = cmd
    # This gets the thread doing something!
    global imover_cmd = cmd
  
    if wait_complete:
      imover_wait(terminate_not_ok)
    end
  end
  
  def istopl(a, aRot = 999):
    if imover_realtime_enabled:
      imover_cmd_exec(imover_STOPL, a, aRot)
    else:
      if aRot == 999:
        stopl(a)
      else:
        stopl(a, aRot)
      end
    end
  end
  
  def izero_ftsensor():
    if imover_realtime_enabled:
      imover_cmd_exec(imover_ZEROFORCE)
    else:
      sleep(0.25)
      zero_ftsensor()
      zero_ftsensor()
    end
  end
  
  def iforce_mode(force_N, approach_speed_mmps):
    if imover_realtime_enabled:
      imover_cmd_exec(imover_STARTFORCE, force_N, approach_speed_mmps)
    else:
      # Don't forget to call izero_ftsensor before this at some point when appropriate!
  
      # Using the defaults here
      #force_mode_set_damping(0)
      #force_mode_set_gain_scaling(1)
  
      # Force is in tool frame
      # Compliant in Tool Z
      # Applying grind_force_N in Z+
      # 2: Force frame not transformed
      # Speed limits
      force_mode(tool_pose(), [0, 0, 1, 0, 0, 0], [0.0, 0.0, force_N, 0.0, 0.0, 0.0], 2, [0.1, 0.1, approach_speed_mmps / 1000.0, 0.3490658503988659, 0.3490658503988659, 0.3490658503988659])
    end
    global imover_force_N = force_N
    global imover_force_speed_mmps = approach_speed_mmps
    global imover_force_on = True
  end
  
  def iforce_update(force_N = 5, approach_speed_mmps = 10):
    if not imover_force_on:
      return None
    end
  
    if imover_realtime_enabled:
      imover_cmd_exec(imover_UPDATEFORCE, force_N - imover_force_N, approach_speed_mmps)
    else:
      # Force is in tool frame
      # Compliant in Tool Z
      # Applying grind_force_N in Z+
      # 2: Force frame not transformed
      # Speed limits
      force_mode(tool_pose(), [0, 0, 1, 0, 0, 0], [0.0, 0.0, force_N - imover_force_N, 0.0, 0.0, 0.0], 2, [0.1, 0.1, approach_speed_mmps / 1000.0, 0.3490658503988659, 0.3490658503988659, 0.3490658503988659])
    end
    global imover_force_N = force_N
    global imover_force_speed_mmps = approach_speed_mmps
  end
  
  def iend_force_mode():
    if imover_realtime_enabled:
      imover_cmd_exec(imover_ENDFORCE)
    else:
      end_force_mode()
    end
    global imover_force_on = False
  end
  
  def iget_actual_tcp_pose():
    if imover_realtime_enabled:
      imover_cmd_exec(imover_GETACTUALTCPPOSE)
      return imover_p
    else:
      return get_actual_tcp_pose()
    end
  end
  
  def iget_actual_joint_positions():
    if imover_realtime_enabled:
      imover_cmd_exec(imover_GETACTUALJOINTPOSITIONS)
      return imover_q
    else:
      return get_actual_joint_positions()
    end
  end
  
  def iget_target_tcp_pose():
    if imover_realtime_enabled:
      imover_cmd_exec(imover_GETTARGETTCPPOSE)
      return imover_p
    else:
      return get_target_tcp_pose()
    end
  end
  
  def iget_target_joint_positions():
    if imover_realtime_enabled:
      imover_cmd_exec(imover_GETTARGETJOINTPOSITIONS)
      return imover_q
    else:
      return get_target_joint_positions()
    end
  end
  
  def iset_tcp(tcp):
    imover_tcp = tcp
    if imover_realtime_enabled:
      imover_cmd_exec(imover_SETTCP)
    else:
      set_tcp(tcp)
    end
  end
  
  def iset_payload(mass, cog):
    imover_mass = mass
    imover_cog = cog
    if imover_realtime_enabled:
      imover_cmd_exec(imover_SETPAYLOAD)
    else:
      set_payload(mass, cog)
    end
  end
  
  def itouchoff(speed_mmps, retract_mm):
    if False: #imover_realtime_enabled:
      imover_param1 = speed_mmps
      imover_param2 = retract_mm
      imover_cmd_exec(imover_TOUCHOFF)
      return imover_ret_f
    else:
      return touchoff(speed_mmps, retract_mm)
    end
  end
  
  def imovel(p, a = 1.2, v = 0.25, t = 0, r = 0):
    if imover_realtime_enabled:
      imover_wait()
      global imover_p = p
      global imover_a = a
      global imover_v = v
      global imover_t = t
      global imover_r = r
      imover_cmd_exec(imover_MOVEL)
    else:
      movel(p, a = a, v = v, t = t, r = r)
    end
  end
  
  def imovel_int(p, a = 1.2, v = 0.25, t = 0, r = 0, wait = True):
    if not ok_to_proceed():
      return None
    end
  
    if imover_realtime_enabled:
      imover_wait()
      global imover_p = p
      global imover_a = a
      global imover_v = v
      global imover_t = t
      global imover_r = r
      imover_cmd_exec(imover_MOVEL, terminate_not_ok = True, wait_complete = wait)
      if not ok_to_proceed():  # We got interrupted
        # Halt any motion in progress... this is really the whole reason for imover
        imover_kill()
  
        # Had occasional move continuation.. added these as belt-and-suspenders!
        sleep(0.1)
        stopl(10)
        global imover_stopl_count = imover_stopl_count + 1
  
        sleep(0.1)
        stopj(10)
        global imover_stopj_count = imover_stopj_count + 1
  
        # Restart the thread
        imover_restart()
      end
    else:
      movel(p, a = a, v = v, t = t, r = r)
    end
  end
  
  def imovej(q, a = 1.2, v = 0.25, t = 0, r = 0):
    if imover_realtime_enabled:
      imover_wait()
      global imover_q = q
      global imover_a = a
      global imover_v = v
      global imover_t = t
      global imover_r = r
      imover_cmd_exec(imover_MOVEJ, 0, 0, True)
    else:
      movej(q, a = a, v = v, t = t, r = r)
    end
  end
  
  thread imover_thread():
    global imover_cmd = 0
    while True:
      if imover_cmd == imover_MOVEL:
        #socket_send_num("imover_a-thread", imover_a)
        #socket_send_num("imover_v-thread", imover_v)
        #socket_send_num("imover_r-thread", imover_r)
        movel(imover_p, a = imover_a, v = imover_v, t = imover_t, r = imover_r)
        global imover_cmd = 0
      elif imover_cmd == imover_MOVEJ:
        movej(imover_q, imover_a, imover_v, imover_t, imover_r)
        global imover_cmd = 0
      elif imover_cmd == imover_STOPL:
        stopl(grind_linear_vel_mps, grind_angular_vel_rps)
        global imover_cmd = 0
      elif imover_cmd == imover_ZEROFORCE:
        sleep(0.25)
        zero_ftsensor()
        zero_ftsensor()
        global imover_cmd = 0
      elif imover_cmd == imover_STARTFORCE:
        # Using the defaults here
        force_mode_set_damping(0)
        force_mode_set_gain_scaling(1)
  
        # Force is in tool frame
        # Compliant in Tool Z
        # Applying grind_force_N in Z+
        # 2: Force frame not transformed
        # Speed limits
        force_mode(tool_pose(), [0, 0, 1, 0, 0, 0], [0.0, 0.0, imover_param1, 0.0, 0.0, 0.0], 2, [0.1, 0.1, imover_param2 / 1000.0, 0.3490658503988659, 0.3490658503988659, 0.3490658503988659])
        global imover_cmd = 0
      elif imover_cmd == imover_UPDATEFORCE:
        # Update force
        # Force is in tool frame
        # Compliant in Tool Z
        # Applying grind_force_N in Z+
        # 2: Force frame not transformed
        # Speed limits
        force_mode(tool_pose(), [0, 0, 1, 0, 0, 0], [0.0, 0.0, imover_param1, 0.0, 0.0, 0.0], 2, [0.1, 0.1, imover_param2 / 1000.0, 0.3490658503988659, 0.3490658503988659, 0.3490658503988659])
        global imover_cmd = 0
      elif imover_cmd == imover_ENDFORCE:
        end_force_mode()
        global imover_cmd = 0
      elif imover_cmd == imover_GETACTUALTCPPOSE:
        global imover_p = get_actual_tcp_pose()
        global imover_cmd = 0
      elif imover_cmd == imover_GETACTUALJOINTPOSITIONS:
        global imover_q = get_actual_joint_positions()
        global imover_cmd = 0
      elif imover_cmd == imover_GETTARGETTCPPOSE:
        global imover_p = get_target_tcp_pose()
        global imover_cmd = 0
      elif imover_cmd == imover_GETTARGETJOINTPOSITIONS:
        global imover_q = get_target_joint_positions()
        global imover_cmd = 0
      elif imover_cmd == imover_SETTCP:
        set_tcp(imover_tcp)
        global imover_cmd = 0
      elif imover_cmd == imover_SETPAYLOAD:
        set_payload(imover_mass, imover_cog)
        global imover_cmd = 0
      elif imover_cmd == imover_TOUCHOFF:
        global imover_ret_f = touchoff(imover_param1, imover_param2)
        global imover_cmd = 0
      elif imover_cmd == imover_PING:
        global imover_cmd = 0
      end
      sync()
    end
  end
  global imover_thread_handle = run imover_thread()
  #
  # END IMOVER SYSTEM
  # ####################################################################################
  
  # ####################################################################################
  # START USER TIMER SUPPORT
  #
  global user_timers_enabled = False
  global user_timer_size = 36
  global user_timers = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  global user_timer_count = 0
  global user_timer_index = 0
  global user_timer_handle = 0
  global user_time_latest = 0.0
  
  thread user_timer_thread():
    user_timer_count = 0
    while (True):
      user_timer_count = user_timer_count + 1
      sync()
    end
  end
  
  def enable_user_timers(f = False):
    if f and not user_timers_enabled:
      # Turning on
      zero_user_timers()
    elif not f and user_timers_enabled:
      # Turning off
    end
  
    global user_timers_enabled = f
    socket_send_bool("user_timers_enabled", user_timers_enabled)
    return_user_timers()
  end
  
  def zero_user_timers():
    global user_timer_index = 0
    local i = 0
    while i < user_timer_size:
      user_timers[i] = 0
      i = i + 1
    end
  
    global user_time_latest = 0.0
  end
  
  def return_user_timers():
    socket_send_num("user_time_latest", user_time_latest)
    socket_send_vector("user_timers", user_timers, user_timer_size)
  end
  
  def start_user_timer():
    if user_timers_enabled:
      user_timer_handle = run user_timer_thread()
    end
  end
  
  def stop_user_timer():
    if not user_timers_enabled:
      return None
    end
  
    kill user_timer_handle
    global user_timer_handle = 0
  
    # 2 ms per tick!
    global user_time_latest = user_timer_count * 0.002
    user_timers[user_timer_index] = user_time_latest
  
    global user_timer_index = user_timer_index + 1
    if user_timer_index >= user_timer_size:
      global user_timer_index = 0
    end
  
    return_user_timers()
    return user_time_latest
  end
  #
  # END USER TIMER SUPPORT
  # ####################################################################################
  
  # ####################################################################################
  # START CALIBRATION TIMER SUPPORT
  #
  global cal_timer_size = 36
  global cal_timers = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  global cal_timer_count = 0
  global cal_timer_index = 0
  global cal_timer_handle = 0
  
  thread cal_timer_thread():
    cal_timer_count = 0
    while (True):
      cal_timer_count = cal_timer_count + 1
      sync()
    end
  end
  
  def zero_cal_timers():
    global cal_timer_index = 0
    local i = 0
    while i < cal_timer_size:
      cal_timers[i] = 0
      i = i + 1
    end
    socket_send_vector("cal_timers", cal_timers, cal_timer_size)
  end
  
  def start_cal_timer():
    cal_timer_handle = run cal_timer_thread()
  end
  
  def stop_cal_timer():
    kill cal_timer_handle
    global cal_timer_handle = 0
  
    # 2 ms per tick!
    local t = cal_timer_count * 0.002
    cal_timers[cal_timer_index] = t
  
    global cal_timer_index = cal_timer_index + 1
    if cal_timer_index >= cal_timer_size:
      global cal_timer_index = 0
    end
    return t
  end
  #
  # END CALIBRATION SUPPORT
  # ####################################################################################
  
  
  # ####################################################################################
  # START CYLINE CAL SYSTEM
  #
  global cyline_cal_enabled = False
  global cyline_training_weight = 5.0
  global cyline_deadband_time = 0.02
  global cyline_expected_time = 5.2
  global cyline_max_e = -100
  global cyline_max_e_angle = 0.0
  global cyline_min_e = 100
  global cyline_min_e_angle = 0.0
  
  # Empirical correction to the rfactor... 0-2.5, 2.5-5.0, ..., 97.5-90
  global cyline_correction_size = 36
  global cyline_degree_slice = 90.0 / cyline_correction_size
  global cyline_calibration_counts = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  global cyline_latest_e = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  
  global cyline_coeff_table_size = 31
  global cyline_coeff_table_index = -1
  
  # Corrections to be used in cylinder lines... these get loaded and overwritten
  global cyline_correction = [0.994231, 0.981154, 0.966923, 0.951154, 0.933846, 0.911864, 0.891596, 0.86957, 0.846735, 0.822852, 0.797641, 0.7716, 0.744658, 0.716958, 0.72103, 0.755499, 0.787812, 0.817955, 0.846025, 0.872201, 0.895809, 0.920769, 0.939615, 0.956154, 0.971154, 0.983846, 0.994615, 1, 1.01, 1.01462, 1.01769, 1.01846, 1.01769, 1.015, 1.01038, 1]
  
  def enable_cyline_cal(f = False):
    if f:
      global cyline_cal_enabled = True
      new_cyline_cycle()
      zero_cyline_calbration_counts()
      return_cyline_cal()
    else:
      global cyline_cal_enabled = False
      socket_send_num("cyline_cal_enabled", cyline_cal_enabled)
    end
  end
  
  def set_cyline_training_weight(weight):
    global cyline_training_weight = weight
  end
  
  def set_cyline_expected_time(t):
    global cyline_expected_time = t
  end
  
  def set_cyline_deadband_time(t):
    global cyline_deadband_time = t
  end
  
  def zero_cyline_latest_e():
    local i = 0
    while i < cyline_correction_size:
      cyline_latest_e[i] = 0
      i = i + 1
    end
  end
  
  def zero_cyline_calbration_counts():
    local i = 0
    while i < cyline_correction_size:
      cyline_calibration_counts[i] = 0
      i = i + 1
    end
  end
  
  def new_cyline_cycle():
    global cyline_max_e = -999.0
    global cyline_min_e = 999.0
    global cyline_max_e_angle = 0.0
    global cyline_min_e_angle = 0.0
    zero_cal_timers()
    zero_cyline_latest_e()
    return_cyline_cal()
  end
  
  def unity_cyline_cal():
    enable_cyline_cal(False)
    local i = 0
    while i < cyline_correction_size:
      cyline_correction[i] = 1.0
      i = i + 1
    end
    global cyline_coeff_table_index = 99
  end
  
  def default_cyline_cal(diam_mm):
    enable_cyline_cal(False)
    global cyline_coeff_table_index = limiter(floor(diam_mm / 100 + 0.5), 0, cyline_coeff_table_size-1)
    local i = 0
    while i < cyline_correction_size:
      cyline_correction[i] = cyline_coeff_tables[cyline_coeff_table_index, i]
      i = i + 1
    end
  end
  
  def return_cyline_cal():
    socket_send_num("cyline_cal_enabled", cyline_cal_enabled)
    socket_send_num("cyline_coeff_table_size", cyline_coeff_table_size)
    socket_send_num("cyline_coeff_table_index", cyline_coeff_table_index)
    socket_send_num("cyline_correction_size", cyline_correction_size)
    socket_send_num("cyline_expected_time", cyline_expected_time)
    socket_send_num("cyline_training_weight", cyline_training_weight)
    socket_send_num("cyline_max_e", cyline_max_e)
    socket_send_num("cyline_max_e_angle", cyline_max_e_angle)
    socket_send_num("cyline_min_e", cyline_min_e)
    socket_send_num("cyline_min_e_angle", cyline_min_e_angle)
    socket_send_num("cyline_deadband_time", cyline_deadband_time)
    socket_send_num("cyline_degree_slice", cyline_degree_slice)
  
    socket_send_vector("cal_timers", cal_timers, cal_timer_size)
    socket_send_vector("cyline_correction", cyline_correction, cyline_correction_size)
    socket_send_vector("cyline_latest_e", cyline_latest_e, cyline_correction_size)
    socket_send_vector("cyline_calibration_counts", cyline_calibration_counts, cyline_correction_size)
  end
  
  def adjust_cyline_coefficient(t):
    local e = t - cyline_expected_time
    cyline_latest_e[process_correction_index] = e
  
    local abs_e = abs(e)
    if e > cyline_max_e:
      global cyline_max_e = e
      global cyline_max_e_angle = process_correction_index * cyline_degree_slice
    end
    if e < cyline_min_e:
      global cyline_min_e = e
      global cyline_min_e_angle = process_correction_index * cyline_degree_slice
    end
  
    if abs(e) > cyline_deadband_time:
      # Example 1. Expect 5s. Get 4s (too fast).   e = 4-5 = -1  scale_factor *= (1 + e/expected)  scale_factor *= (1 + -1/5)  scale_factor *= 0.8
      # Example 2. Expect 5s. Get 7s (too slow).   e = 7-5 = +2  scale_factor *= (1 + e/expected)  scale_factor *= (1 + 2/5)  scale_factor *= 1.4
      local adjustment_speed = cyline_training_weight / 100.0
      local adjustment_multiplier = 1 + adjustment_speed * e / cyline_expected_time
      cyline_correction[process_correction_index] = cyline_correction[process_correction_index] * adjustment_multiplier
    end
    cyline_calibration_counts[process_correction_index] = cyline_calibration_counts[process_correction_index] + 1
    return_cyline_cal()
  end
  #
  # END CYLINE CAL SYSTEM
  # ####################################################################################
  
  # ####################################################################################
  # START DRAWING SYSTEM
  #
  global draw_current_dp = p[0, 0, 0, 0, 0, 0]
  global draw_accel_factor = 1.0
  global draw_speed_factor = 1.0
  global draw_p_origin = p[0, 0, 0, 0, 0, 0]
  global process_a = 1.0
  global process_v = 0.1
  global process_r = 0.002
  
  # Sets a 1-time speed for velocity
  def draw_speed_once(speed_desired_one_move_mmps):
    local scale = speed_desired_one_move_mmps / grind_linear_vel_mps
    draw_scale_once(scale)
  end
  
  # Sets a 1-time speedup factor on velocity
  def draw_scale_once(scale):
    global draw_accel_factor = 1.0
    global draw_speed_factor = scale
  end
  
  def draw_origin(p):
    global draw_p_origin = p
    global draw_current_dp = p[0, 0, 0, 0, 0, 0]
  end
  
  #def draw_start(current_dp, r = -1, wait = True):
  #  global draw_current_dp = p[0, 0, 0, 0, 0, 0]
  #  draw_to(current_dp, r = r, wait = wait)
  #end
  
  def draw_relative(dp, r = -1, wait = True):
    local dpdest = pose_add(draw_current_dp, dp)
    draw_to(dpdest, r, wait)
  end
  
  def draw_to(dp, r = -1, wait = True):
    global draw_current_ddp0 = abs(dp[0] - draw_current_dp[0])
    global draw_current_ddp1 = abs(dp[1] - draw_current_dp[1])
    global draw_current_ddp3 = abs(dp[3] - draw_current_dp[3])
    global draw_current_ddp4 = abs(dp[4] - draw_current_dp[4])
  
    # Flat:     X, Y
    # Cylinder: X, RX
    # Sphere:   RX, RX
    local shape = robot_part_geometry[0]
    if shape == 3: # Sphere
      global process_a = grind_angular_accel_rpss
      global process_v = grind_angular_vel_rps
      global process_r = grind_angular_blend_radius_rad
    elif shape == 2: # Cylinder
      # Cylinder: Linear speed is good for X moves, rotational speed for theta
  
      # process_theta_deg is 0 degrees (pure X) to 90 degrees (pure RX)
      global process_dx_m = draw_current_ddp0
      global process_dy_m = draw_current_ddp3 * robot_part_geometry[1] / 2000.
      global process_theta_deg = abs(r2d(atan2(process_dy_m, process_dx_m)))
      if process_theta_deg > 90.0:
        global process_theta_deg = abs(180.0 - process_theta_deg)
      end
  
      # process_sliderfactor is 0 (pure X) to 1 (pure RX)
      global process_sliderfactor = process_theta_deg / 90.0
      global process_correction_index = limiter(floor(process_theta_deg / cyline_degree_slice), 0, cyline_correction_size-1)
  
      if process_theta_deg < 0.5 or process_theta_deg > 89.5:
        # Pure linear or rotational moves (within 1 degree) need no correction
        global process_correctionfactor = 1
      else:
        # Otherwise, we do the table lookup
        global process_correctionfactor = cyline_correction[process_correction_index]
      end
  
      # Choose speeds as a linear combination of the two values!
      global process_a = linear_slider(grind_linear_accel_mpss, grind_angular_accel_rpss, process_sliderfactor)
      global process_v = linear_slider(grind_linear_vel_mps, grind_angular_vel_rps, process_sliderfactor)
      global process_r = linear_slider(grind_linear_blend_radius_m, grind_angular_blend_radius_rad, process_sliderfactor)
  
      # Apply calibrated corrections
      global process_a = process_a * process_correctionfactor
      global process_v = process_v * process_correctionfactor
    else: # Flat
      global process_a = grind_linear_accel_mpss
      global process_v = grind_linear_vel_mps
      global process_r = grind_linear_blend_radius_m
    end
  
    # Apply one-time scaling factors
    global process_a = process_a * draw_accel_factor
    global process_v = process_v * draw_speed_factor
  
    # Apply optional blend radius override
    global process_r_in = r
    if r >= 0:
      global process_r = r
    end
  
    # Clear 1-time speed factors
    global draw_accel_factor = 1.0
    global draw_speed_factor = 1.0
  
    # Let's go!
    global draw_current_dp = dp
    local p = pose_trans(draw_p_origin, draw_current_dp)
    #socket_send_pose("imovel_p_center", p_contact_center)
    #socket_send_pose("imovel_p", p)
    #socket_send_pose("imovel_dp", dp)
    #socket_send_pose("imovel_get", get_actual_tcp_pose())
    imovel_int(p, a = process_a, v = process_v, r = process_r, wait = wait)
    return p
  end
  
  def draw_finish(p):
    draw_to(p, r = 0)
  end
  #
  # END DRAWING SYSTEM
  # ####################################################################################
  
  # The coeff tables
  
  # From unity_100-300mm.xlsx
  # 0mm (estimated), 100mm, 200mm, ... , 3000mm
  def init_cycline_coeffs():
    global cyline_coeff_tables =
    [
      [0.900000, 0.620000, 0.750000, 0.860000, 0.940000, 1.020000, 1.100000, 1.150000, 1.200000, 1.239652, 1.270302, 1.294257, 1.312201, 1.324502, 1.340405, 1.346328, 1.349003, 1.348860, 1.345110, 1.338750, 1.329420, 1.318790, 1.304780, 1.290500, 1.273380, 1.255610, 1.236670, 1.215670, 1.193510, 1.161530, 1.138460, 1.115000, 1.090770, 1.065390, 1.039610, 1.013460],
      [0.949231, 0.855854, 0.778371, 0.712231, 0.654475, 0.738294, 0.812746, 0.877131, 0.934615, 0.980769, 1.020000, 1.053850, 1.082690, 1.106920, 1.132510, 1.149510, 1.163540, 1.174430, 1.182170, 1.187260, 1.189520, 1.189970, 1.187580, 1.183710, 1.177460, 1.169730, 1.160450, 1.149180, 1.136370, 1.117690, 1.102690, 1.086540, 1.069230, 1.050770, 1.031150, 1.010770],
      [0.980385, 0.941538, 0.900753, 0.863069, 0.826287, 0.790784, 0.755879, 0.722168, 0.688801, 0.721886, 0.769698, 0.813443, 0.853179, 0.889338, 0.924615, 0.952692, 0.978077, 1.000000, 1.019230, 1.035770, 1.049620, 1.061150, 1.070380, 1.076920, 1.081540, 1.083850, 1.084230, 1.082690, 1.079230, 1.073850, 1.066920, 1.058080, 1.047690, 1.036150, 1.022690, 1.008080],
      [0.991154, 0.972308, 0.952308, 0.931154, 0.905734, 0.882064, 0.857383, 0.831953, 0.805572, 0.778751, 0.751406, 0.723306, 0.702589, 0.741240, 0.777307, 0.810840, 0.842206, 0.870717, 0.896958, 0.923846, 0.944615, 0.963077, 0.979231, 0.993462, 1.005000, 1.015000, 1.022690, 1.028460, 1.031920, 1.033460, 1.033460, 1.031540, 1.027310, 1.021920, 1.014230, 1.005380],
      [1.000000, 0.988077, 0.978077, 0.966538, 0.953077, 0.938462, 0.921923, 0.900405, 0.880575, 0.858912, 0.836476, 0.812299, 0.787050, 0.760735, 0.733074, 0.706927, 0.740101, 0.771220, 0.800618, 0.828195, 0.853613, 0.877513, 0.899256, 0.921923, 0.939231, 0.954615, 0.967692, 0.979231, 0.988846, 0.994423, 1.000000, 1.005770, 1.007690, 1.008080, 1.006150, 1.000000],
      [1.000000, 1.000000, 0.994615, 0.988846, 0.981538, 0.972692, 0.961923, 0.949231, 0.935000, 0.918846, 0.897341, 0.877131, 0.855141, 0.831953, 0.807028, 0.780274, 0.752459, 0.722927, 0.722927, 0.752459, 0.780274, 0.807028, 0.831953, 0.855141, 0.877131, 0.897341, 0.918846, 0.935000, 0.949231, 0.961923, 0.972692, 0.981538, 0.988846, 0.994615, 1.000000, 1.000000],
      [1.000000, 1.005000, 1.005770, 1.004620, 1.000000, 1.000000, 0.990385, 0.981923, 0.971538, 0.959231, 0.945000, 0.929231, 0.907649, 0.887081, 0.864981, 0.840678, 0.814587, 0.786669, 0.756933, 0.725202, 0.718573, 0.746847, 0.773883, 0.799856, 0.824441, 0.847881, 0.869906, 0.890447, 0.912692, 0.929615, 0.945000, 0.958846, 0.970769, 0.981538, 0.990385, 1.000000],
      [1.000000, 1.009620, 1.013850, 1.016150, 1.016540, 1.015380, 1.011920, 1.006920, 1.000000, 0.990385, 0.979615, 0.966154, 0.951154, 0.934231, 0.911481, 0.889721, 0.865363, 0.839207, 0.810840, 0.780654, 0.747987, 0.713646, 0.723685, 0.751318, 0.777990, 0.803597, 0.828195, 0.852032, 0.874496, 0.895809, 0.918846, 0.936923, 0.953462, 0.968462, 0.982308, 0.994615],
      [1.005000, 1.013460, 1.020000, 1.025000, 1.028080, 1.029230, 1.028850, 1.026150, 1.021920, 1.015380, 1.006920, 1.000000, 0.983846, 0.968846, 0.951923, 0.933077, 0.908033, 0.883637, 0.857001, 0.827814, 0.796426, 0.762553, 0.726340, 0.708063, 0.736396, 0.763777, 0.790784, 0.816811, 0.842206, 0.866510, 0.890104, 0.915769, 0.936538, 0.956154, 0.974615, 0.991923],
      [1.005770, 1.016150, 1.025000, 1.031920, 1.037310, 1.040770, 1.042310, 1.041920, 1.040000, 1.035770, 1.029620, 1.021150, 1.010770, 1.000000, 0.983077, 0.966154, 0.946538, 0.924615, 0.896575, 0.868805, 0.838443, 0.805503, 0.769779, 0.731462, 0.698804, 0.727762, 0.756259, 0.784385, 0.811984, 0.839207, 0.866080, 0.892018, 0.920385, 0.944231, 0.967308, 0.989231],
      [1.006540, 1.018460, 1.028850, 1.037690, 1.044620, 1.050000, 1.053460, 1.055000, 1.054620, 1.052690, 1.048080, 1.041920, 1.033460, 1.022690, 1.009620, 0.994231, 0.976538, 0.956154, 0.933462, 0.904584, 0.875600, 0.843351, 0.808553, 0.770539, 0.729659, 0.695018, 0.724823, 0.754359, 0.784080, 0.813824, 0.842970, 0.872201, 0.901136, 0.932308, 0.959615, 0.986923],
      [1.007310, 1.020380, 1.031920, 1.042310, 1.050770, 1.057690, 1.062690, 1.065770, 1.067310, 1.066920, 1.064230, 1.059620, 1.052690, 1.043850, 1.032310, 1.018850, 1.000000, 0.983846, 0.962692, 0.938462, 0.911538, 0.877513, 0.843351, 0.805953, 0.765595, 0.721409, 0.695775, 0.726720, 0.758074, 0.789641, 0.821389, 0.853231, 0.885509, 0.920769, 0.952308, 0.984231],
      [1.007690, 1.021920, 1.035000, 1.046150, 1.055770, 1.063850, 1.070380, 1.075000, 1.078080, 1.078850, 1.077690, 1.074620, 1.069620, 1.061920, 1.052310, 1.040000, 1.025380, 1.008080, 0.988077, 0.965385, 0.940000, 0.907649, 0.874835, 0.838061, 0.798021, 0.754359, 0.706272, 0.701075, 0.733739, 0.766736, 0.800618, 0.835007, 0.870288, 0.906117, 0.945385, 0.981538],
      [1.008080, 1.023460, 1.037310, 1.049620, 1.060380, 1.069620, 1.077310, 1.083080, 1.087310, 1.089230, 1.089620, 1.088080, 1.084230, 1.078080, 1.069620, 1.058850, 1.045770, 1.029620, 1.011150, 0.989615, 0.965000, 0.937692, 0.903086, 0.867611, 0.828134, 0.784461, 0.736776, 0.684641, 0.710715, 0.745417, 0.781035, 0.817638, 0.855854, 0.895043, 0.938077, 0.979231],
      [1.008460, 1.024620, 1.039230, 1.052310, 1.064230, 1.074230, 1.083080, 1.090000, 1.095000, 1.098460, 1.100000, 1.099620, 1.096920, 1.091920, 1.085000, 1.075380, 1.063460, 1.048850, 1.031540, 1.011150, 0.988077, 0.961538, 0.931538, 0.894277, 0.855472, 0.812365, 0.764917, 0.712610, 0.689180, 0.725202, 0.762256, 0.800999, 0.841442, 0.884019, 0.931154, 0.976538],
      [1.008850, 1.025380, 1.040770, 1.055000, 1.067310, 1.078460, 1.088080, 1.096150, 1.102310, 1.106540, 1.109230, 1.109620, 1.108460, 1.104620, 1.098850, 1.090380, 1.079620, 1.066150, 1.050000, 1.031150, 1.008850, 0.983462, 0.954615, 0.921923, 0.880958, 0.838443, 0.791238, 0.739054, 0.681348, 0.705893, 0.744658, 0.785146, 0.827814, 0.873349, 0.924231, 0.973846],
      [1.009230, 1.026540, 1.042310, 1.056920, 1.070380, 1.082310, 1.092690, 1.101540, 1.108460, 1.113850, 1.122030, 1.123580, 1.123190, 1.120490, 1.111150, 1.103850, 1.094230, 1.081920, 1.066920, 1.048850, 1.027690, 1.000000, 0.975385, 0.943462, 0.904201, 0.862353, 0.815731, 0.763777, 0.705893, 0.687667, 0.727478, 0.769779, 0.814587, 0.862686, 0.917692, 0.971538],
      [1.009620, 1.027310, 1.043850, 1.058850, 1.073080, 1.085380, 1.096540, 1.106150, 1.114230, 1.120380, 1.129370, 1.132120, 1.132460, 1.130970, 1.127060, 1.120490, 1.107310, 1.096150, 1.081920, 1.065000, 1.045000, 1.021540, 0.994615, 0.963846, 0.928846, 0.884785, 0.838768, 0.787050, 0.729280, 0.670351, 0.711372, 0.755119, 0.801761, 0.852466, 0.910769, 0.968846],
      [1.009620, 1.028080, 1.045000, 1.060770, 1.075380, 1.088460, 1.100380, 1.110380, 1.119230, 1.130920, 1.136370, 1.139850, 1.141010, 1.140240, 1.137100, 1.131690, 1.123970, 1.108850, 1.096150, 1.080000, 1.060770, 1.038460, 1.012310, 0.982308, 0.948077, 0.905734, 0.860392, 0.808934, 0.751026, 0.686154, 0.695775, 0.740861, 0.789335, 0.842588, 0.900753, 0.966538],
      [1.010000, 1.028460, 1.046150, 1.062310, 1.077310, 1.091150, 1.103460, 1.114230, 1.128210, 1.136370, 1.142610, 1.146420, 1.148740, 1.148740, 1.146860, 1.142170, 1.135170, 1.125510, 1.108850, 1.093850, 1.075770, 1.054230, 1.028850, 1.000000, 0.966154, 0.928077, 0.880575, 0.829662, 0.771980, 0.706927, 0.680970, 0.727099, 0.777307, 0.832716, 0.893932, 0.963846],
      [1.010000, 1.029230, 1.046920, 1.063850, 1.079230, 1.093460, 1.106540, 1.122420, 1.132460, 1.141010, 1.148020, 1.153040, 1.155750, 1.156910, 1.155360, 1.151880, 1.145650, 1.136710, 1.125120, 1.106540, 1.089230, 1.068460, 1.044230, 1.015770, 0.983462, 0.945769, 0.899604, 0.849028, 0.791619, 0.726720, 0.666691, 0.713746, 0.765595, 0.823234, 0.887424, 0.961538],
      [1.010380, 1.029620, 1.047690, 1.065000, 1.081150, 1.095770, 1.108850, 1.125510, 1.136330, 1.145650, 1.153040, 1.158900, 1.162320, 1.163870, 1.163540, 1.160390, 1.155360, 1.147190, 1.136330, 1.122810, 1.101920, 1.081920, 1.058460, 1.031150, 1.000000, 0.962692, 0.920385, 0.867611, 0.810459, 0.745417, 0.671107, 0.701075, 0.754359, 0.813824, 0.880958, 0.959231],
      [1.010380, 1.030000, 1.048850, 1.066150, 1.082690, 1.097690, 1.111540, 1.128600, 1.140240, 1.149950, 1.157680, 1.163870, 1.168570, 1.170500, 1.170890, 1.168570, 1.164310, 1.156910, 1.146810, 1.134060, 1.113460, 1.094620, 1.071920, 1.045000, 1.014230, 0.978077, 0.936923, 0.884785, 0.828195, 0.763396, 0.688801, 0.688801, 0.743229, 0.804741, 0.874496, 0.956538],
      [1.010380, 1.030380, 1.049230, 1.067310, 1.083850, 1.099620, 1.113850, 1.131300, 1.143330, 1.153430, 1.161930, 1.168950, 1.174040, 1.176690, 1.177460, 1.176360, 1.172490, 1.165860, 1.156520, 1.144490, 1.128990, 1.106150, 1.084230, 1.058460, 1.028080, 0.993077, 0.952308, 0.901519, 0.845261, 0.780654, 0.705893, 0.677037, 0.732695, 0.795736, 0.868040, 0.954231],
      [1.010770, 1.030770, 1.050000, 1.068080, 1.085380, 1.101150, 1.115770, 1.134060, 1.146470, 1.156910, 1.166250, 1.173660, 1.179070, 1.182550, 1.183710, 1.182940, 1.179840, 1.174430, 1.165860, 1.154200, 1.139850, 1.117310, 1.096150, 1.070770, 1.041540, 1.006920, 0.966923, 0.920385, 0.861539, 0.797188, 0.722266, 0.665559, 0.722266, 0.787050, 0.861922, 0.951923],
      [1.010770, 1.031150, 1.050770, 1.069230, 1.086540, 1.102690, 1.117690, 1.136370, 1.149180, 1.160450, 1.169730, 1.177460, 1.183710, 1.187580, 1.189970, 1.189520, 1.187260, 1.182170, 1.174430, 1.163540, 1.149510, 1.132510, 1.106920, 1.082690, 1.053850, 1.020000, 0.980769, 0.934615, 0.877131, 0.812746, 0.738294, 0.654475, 0.712231, 0.778371, 0.855854, 0.949231],
      [1.010770, 1.031540, 1.051150, 1.070000, 1.087690, 1.104230, 1.123970, 1.138690, 1.151440, 1.163090, 1.173210, 1.181390, 1.187970, 1.192680, 1.195390, 1.195780, 1.193840, 1.189130, 1.182170, 1.172050, 1.158840, 1.142170, 1.122030, 1.093850, 1.065770, 1.032690, 0.993846, 0.948462, 0.891635, 0.827814, 0.753305, 0.665936, 0.702485, 0.770078, 0.849792, 0.946923],
      [1.011150, 1.031920, 1.051920, 1.070770, 1.088850, 1.105380, 1.125900, 1.140620, 1.154200, 1.166250, 1.176300, 1.185260, 1.192290, 1.197320, 1.200420, 1.201190, 1.200100, 1.196160, 1.189520, 1.180230, 1.167790, 1.151880, 1.132080, 1.104230, 1.076920, 1.044230, 1.006150, 0.961538, 0.906117, 0.842588, 0.768176, 0.680325, 0.692855, 0.761876, 0.843733, 0.944615],
      [1.011150, 1.032310, 1.052310, 1.071540, 1.089620, 1.106540, 1.127440, 1.142560, 1.156140, 1.168570, 1.179460, 1.188360, 1.196160, 1.201580, 1.205140, 1.206680, 1.205910, 1.202350, 1.196550, 1.188040, 1.175910, 1.160830, 1.141780, 1.114230, 1.087310, 1.055770, 1.018080, 0.974231, 0.922308, 0.856287, 0.782177, 0.694368, 0.683617, 0.753979, 0.837680, 0.942308],
      [1.011150, 1.032310, 1.052690, 1.072310, 1.090380, 1.107690, 1.128600, 1.144100, 1.158510, 1.170890, 1.182170, 1.191910, 1.199640, 1.205450, 1.209780, 1.211720, 1.211330, 1.208620, 1.203130, 1.195000, 1.183710, 1.168950, 1.150670, 1.128210, 1.097690, 1.066540, 1.029620, 0.986154, 0.935000, 0.869906, 0.795736, 0.707787, 0.674392, 0.746088, 0.831953, 0.940000],
      [1.011150, 1.032690, 1.053080, 1.072690, 1.091540, 1.108850, 1.130150, 1.146090, 1.160450, 1.173210, 1.184870, 1.194610, 1.202740, 1.209390, 1.213650, 1.215980, 1.216360, 1.214040, 1.209390, 1.201580, 1.191130, 1.177140, 1.159230, 1.137480, 1.106920, 1.076540, 1.040380, 1.000000, 0.946923, 0.882830, 0.808934, 0.721030, 0.665819, 0.738294, 0.826287, 0.937692]
    ]
  end
  $ 4 "Script: agscript_grind-2.script"
  # File: agscript_grind-2.script
  # Project: AutoGrind Code Rev 2 IMOVER
  # Author: Ned Lecky, Lecky Engineering LLC
  # Purpose: All grinding functions used in AutoGrind
  
  global grind_version = "Rev 2 2022-06-13"
  
  global grind_abort_listener_thread_handle = 0
  global pattern_grind_thread_handle = 0
  
  global halt_count = 0
  global halt_command = [0, 0, 0, 0]
  
  global grind_ready = True
  # grind_contact_enable:  0=No Contact   1=Touch but no tool/coolant on or force  2=Touch, Tool, Coolant, and Force
  global grind_contact_enable = 0
  global grind_touch_retract_mm = 3       # How far to retract after touch  (we do 2X this for ghrind_contact_enable=1)
  global grind_touch_speed_mmps = 0.1     # How fast to go in for the touch
  global grind_force_dwell_ms = 500       # How long to dwell after turning force more on
  global grind_max_blend_radius_m = 0.010 # Max blend radius to use while grinding
  global grind_trial_speed_mmps = 20      # Grinding speed when not really grinding!
  global grind_point_frequency_hz = 4     # Points per second to generate in grind_movel
  
  global grind_linear_vel_mps = 0
  global grind_linear_accel_mpss = 0
  global grind_linear_blend_radius_m = 0
  global grind_angular_vel_rps = 0
  global grind_angular_accel_rpss = 0
  global grind_angular_blend_radius_rad = 0
  
  # Planning points
  global p_operator_init = p[0, 0, 0, 0, 0, 0]    # Where we were when operator issued first grind command
  global p_contact_init = p[0, 0, 0, 0, 0, 0]     # Where we first contacted the part
  global dp_from_contact_center = p[0, 0, 0, 0, 0, 0]   # How did we offset from p_operator_int prior to contact?
  global p_contact_center = p[0, 0, 0, 0, 0, 0]   # Computed where center of pattern would be in contact with part
  
  MATH_PI = 3.1415926535
  
  # Set grind variables chosen by command[2]
  # Value after set is always returned to socket
  def set_grind_variable():
    global grind_ready = False
    socket_send_bool("grind_ready", grind_ready)
  
    if command[2] == 1:
      global response = "set grind_contact_enable"
      if command[3] >= 0 and command[3] <= 2:
        global grind_contact_enable = ceil(command[3])
      end
      socket_send_integer("grind_contact_enable", grind_contact_enable)
    elif command[2] == 2:
      global response = "set grind_touch_retract_mm"
      if command[3] >= 0:
        global grind_touch_retract_mm = ceil(command[3])
      end
      socket_send_integer("grind_touch_retract_mm", grind_touch_retract_mm)
    elif command[2] == 3:
      global response = "set grind_touch_speed_mmps"
      if command[3] >= 0:
        global grind_touch_speed_mmps = ceil(command[3])
      end
      socket_send_integer("grind_touch_speed_mmps", grind_touch_speed_mmps)
    elif command[2] == 4:
      global response = "set grind_force_dwell_ms"
      if command[3] >= 0:
        global grind_force_dwell_ms = ceil(command[3])
      end
      socket_send_integer("grind_force_dwell_ms", grind_force_dwell_ms)
    elif command[2] == 5:
      global response = "set grind_max_wait_ms"
      if command[3] >= 0:
        global grind_max_wait_ms = ceil(command[3])
      end
      socket_send_integer("grind_max_wait_ms", grind_max_wait_ms)
    elif command[2] == 6:
      global response = "set grind_max_blend_radius_mm"
      if command[3] >= 0:
        global grind_max_blend_radius_m = command[3] / 1000.0
      end
      socket_send_num("grind_max_blend_radius_mm", grind_max_blend_radius_m * 1000.0)
    elif command[2] == 7:
      global response = "set grind_trial_speed_mmps"
      if command[3] > 0:
        global grind_trial_speed_mmps = ceil(command[3])
      end
      socket_send_integer("grind_trial_speed_mmps", grind_trial_speed_mmps)
    elif command[2] == 8:
      global response = "set grind_linear_accel_mmpss"
      if command[3] > 0:
        global grind_linear_accel_mpss = command[3] / 1000.0
      end
      socket_send_integer("grind_linear_accel_mmpss", grind_linear_accel_mpss * 1000.0)
    elif command[2] == 9:
      global response = "set grind_point_frequency_hz"
      if command[3] >= 0:
        global grind_point_frequency_hz = ceil(command[3])
      end
      socket_send_integer("grind_point_frequency_hz", grind_point_frequency_hz)
    else:
      global response = "Unknown grind set variable command"
    end
  
    global grind_ready = True
    socket_send_bool("grind_ready", grind_ready)
  end
  
  # Execute the desired grind operation as specified in command[2]...
  def grind():
    global grind_ready = False
    socket_send_bool("grind_ready", grind_ready)
  
    # Start listening for abort commands from host
    if grind_abort_listener_thread_handle > 0:
      kill grind_abort_listener_thread_handle
      grind_abort_listener_thread_handle = 0
    end
    grind_abort_listener_thread_handle = run grind_abort_listener_thread()
  
    global grind_cycle = 0
    socket_send_integer("grind_cycle", grind_cycle)
  
    # Install tcp that puts tcp at center of part (noop for flat parts!)
    iset_tcp(robot_tcp_part)
  
    if command[2] == 10:
      # LINEAR GRIND
      global response = "grind_line"
      global grind_dx_mm = limiter(command[3], -1000, 1000)
      global grind_dy_mm = limiter(command[4], -1000, 1000)
      n_cycle_setter(command[5])
      speed_setter(command[6], 0)
      global grind_force_N = limiter(command[7], 0, 100)
      global grind_continue = command[8] > 0
      imover_realtime(True)
      grind_line(grind_dx_mm, grind_dy_mm, grind_n_cycles, grind_continue)
  
    elif command[2] == 11:
      # LINEAR ANGLE GRIND
      global response = "grind_line_deg"
      global grind_len_mm = limiter(command[3], 0, 1000)
      global grind_angle_deg = limiter(command[4], 0, 360)
      n_cycle_setter(command[5])
      speed_setter(command[6], 0)
      global grind_force_N = limiter(command[7], 0, 100)
      global grind_continue = command[8] > 0
      imover_realtime(True)
      global grind_dx_mm = grind_len_mm * cos(d2r(grind_angle_deg))
      global grind_dy_mm = grind_len_mm * sin(d2r(grind_angle_deg))
      grind_line(grind_dx_mm, grind_dy_mm, grind_n_cycles, grind_continue)
  
    elif command[2] == 20:
      # RECTANGULAR GRIND
      global response = "grind_rect"
      global grind_dx_mm = limiter(command[3], 0, 1000)
      global grind_dy_mm = limiter(command[4], 0, 1000)
      n_cycle_setter(command[5])
      speed_setter(command[6], min(grind_dx_mm, grind_dy_mm))
      global grind_force_N = limiter(command[7], 0, 100)
      global grind_continue = command[8] > 0
      imover_realtime(True)
      grind_rect(grind_dx_mm, grind_dy_mm, grind_n_cycles, grind_continue)
  
    elif command[2] == 30:
      # SERPENTINE GRIND
      global response = "grind_serpentine"
      global grind_dx_mm = limiter(command[3], 1, 1000)
      global grind_dy_mm = limiter(command[4], 1, 1000)
      global grind_n_xsteps = limiter(command[5], 1, grind_dx_mm)
      global grind_n_ysteps = limiter(command[6], 1, grind_dy_mm)
      n_cycle_setter(command[7])
      local min_feature_mm = min(grind_dx_mm / grind_n_xsteps, grind_dy_mm / grind_n_ysteps)
      speed_setter(command[8], min_feature_mm)
      global grind_force_N = limiter(command[9], 0, 10)
      global grind_continue = command[10] > 0
      grind_serpentine(grind_dx_mm, grind_dy_mm, grind_n_xsteps, grind_n_ysteps, grind_n_cycles, grind_continue)
  
    elif command[2] == 40:
      # POLYGON GRIND
      global response = "grind_poly"
      global grind_circle1_diam_mm = limiter(command[3], 0, 1000)
      # Limit number of sides to 2 (line) to diam_mm/10 (100mm circle can have up to 10 sides)
      global grind_n_sides = limiter(command[4], 2, grind_circle1_diam_mm / 10.0)
      n_cycle_setter(command[5])
      local min_feature_mm = max(2, grind_circle1_diam_mm)
      speed_setter(command[6], min_feature_mm)
      global grind_force_N = limiter(command[7], 0, 100)
      global grind_continue = command[8] > 0
      grind_poly(grind_circle1_diam_mm, grind_n_sides, grind_n_cycles, grind_continue)
  
    elif command[2] == 45:
      # CIRCULAR GRIND
      global response = "grind_circle"
      global grind_circle1_diam_mm = limiter(command[3], 0, 1000)
      n_cycle_setter(command[4])
      local min_feature_mm = max(2, grind_circle1_diam_mm)
      speed_setter(command[5], min_feature_mm, is_circle = True)
      global grind_force_N = limiter(command[6], 0, 100)
      global grind_continue = command[7] > 0
      grind_circle(grind_circle1_diam_mm, grind_n_cycles, grind_continue)
  
    elif command[2] == 50:
      # SPIRAL GRIND
      global response = "grind_spiral"
      global grind_circle1_diam_mm = limiter(command[3], 0, 1000)
      global grind_circle2_diam_mm = limiter(command[4], 0, 1000)
      global grind_n_revolutions = limiter(command[5], 1, 100)
      n_cycle_setter(command[6])
      local min_diam_mm = min(grind_circle1_diam_mm, grind_circle2_diam_mm)
      local min_feature_mm = max(2, min_diam_mm)
      speed_setter(command[7], min_feature_mm, is_circle = True)
      global grind_force_N = limiter(command[8], 0, 100)
      global grind_continue = command[9] > 0
      grind_spiral(grind_circle1_diam_mm, grind_circle2_diam_mm, grind_n_revolutions, grind_n_cycles, grind_continue)
  
    elif command[2] == 99:
      # RETRACT COMMAND
      global response = "grind_retract"
      imover_realtime(True)
      set_grind_process_state(False)
    else:
      # Illegal grind command
      global response = "Unknown grind command"
    end
  
    # Restore tool-only tcp
    iset_tcp(robot_tcp)
  
    # Stop listening for abort commands from host
    if grind_abort_listener_thread_handle > 0:
      kill grind_abort_listener_thread_handle
      grind_abort_listener_thread_handle = 0
    end
  
    global grind_ready = True
    socket_send_bool("grind_ready", grind_ready)
  end
  
  # Set global grind_n_cycles based on whether we really going to grind
  def n_cycle_setter(n_cycles):
    if grind_contact_enable == 2:
      global grind_n_cycles = limiter(n_cycles, 0, 100)
    else:
      global grind_n_cycles = limiter(n_cycles, 0, 1)
    end
    socket_send_integer("grind_n_cycles", grind_n_cycles)
  end
  
  def forced_speed_setter(speed_mmps):
    # Set as if we're really going to grind but at a user-selected speed
    local old_grind_contact_enable = grind_contact_enable
    global grind_contact_enable = 2
    speed_setter(speed_mmps, 0)
    grind_contact_enable = old_grind_contact_enable
  end
  
  # Set all speed and acceleration globals based on part geometry and whether we really going to grind
  def speed_setter(speed_mmps, min_feature_mm, is_circle = False):
    speed_mmps = limiter(speed_mmps, 0.1, 200)
  
    # Figure out best blend radius to use
    global grind_min_feature_m = min_feature_mm / 1000.0
    global grind_linear_blend_radius_m = min(grind_max_blend_radius_m, grind_min_feature_m / 4)
    if is_circle:
      if grind_linear_blend_radius_m < 0.0015:
        grind_linear_blend_radius_m = 0
      end
    else:
      if grind_linear_blend_radius_m < 0.0015:
        grind_linear_blend_radius_m = 0
      end
    end
  
    if grind_contact_enable == 2:
      global grind_linear_vel_mps = speed_mmps / 1000.0
    else:
      global grind_linear_vel_mps = grind_trial_speed_mmps / 1000.0
    end
  
    # If part is cylinder or spherical, diameter will be >0
    local diam_m = robot_part_geometry[1] / 1000.0
    if diam_m > 0.0:
      # These are 1/4 the theoretical rotational speeds but we need to set them like this to get the correct speed- why??????
      # rot_vel (rad/s) = linear_vel (m/s) * 2pi (rad/s) / pi * diam (m/s)
      local coeff = 0.5 # Should be 2 and why 0.5 is inexplicable
      global grind_angular_vel_rps = grind_linear_vel_mps * coeff / diam_m
      global grind_angular_accel_rpss = grind_linear_accel_mpss * coeff / diam_m
      global grind_angular_blend_radius_rad = grind_linear_blend_radius_m * coeff / diam_m
    end
  
    socket_send_num("grind_linear_vel_mmps", grind_linear_vel_mps * 1000.0)
    socket_send_num("grind_linear_accel_mmpss", grind_linear_accel_mpss * 1000.0)
    socket_send_num("grind_linear_blend_radius_mm", grind_linear_blend_radius_m * 1000.0)
    socket_send_num("grind_angular_vel_rps", grind_angular_vel_rps)
    socket_send_num("grind_angular_accel_rpss", grind_angular_accel_rpss)
    socket_send_num("grind_angular_blend_radius_rad", grind_angular_blend_radius_rad)
  end
  
  global grind_part_speed_mmps = 20.0
  
  # Get into contact with part (or away from it)
  # enable:  0=No Contact   1=Touch but no tool/coolant on or force  2=Touch, Tool, Coolant, and Force
  def contact_part(on = False, enable = 0):
    draw_origin(iget_actual_tcp_pose())
    forced_speed_setter(grind_part_speed_mmps)
  
    if on:
      if enable == 0:
        # Just do a small forward motion in the direction of touchoff- this is a simulated p_contact_init
        p_contact_init = draw_to(p[0, 0, 0.005, 0, 0, 0])
      elif enable == 1:
        # Advance until contact but retract 2X grind distance and use this as a simulated p_contact_init
        local success = itouchoff(grind_touch_speed_mmps, grind_touch_retract_mm * 2.0)
        global p_contact_init = iget_actual_tcp_pose()
        return success
      elif enable == 2:
        # Advance until contact
        local success = itouchoff(grind_touch_speed_mmps, grind_touch_retract_mm)
        # Touchoff has backed off by grind_touch_retract_mm so we need to compute that actual p_contact_init
        global p_contact_init = pose_trans(iget_actual_tcp_pose(), p[0, 0, grind_touch_retract_mm / 1000.0, 0, 0, 0])
        return success
      end
    else:  # Back off
      draw_to(p[0, 0, -0.010, 0, 0, 0])
    end
  
    return True
  end
  
  # Sets digital outpus based 8-element list of 4 pairs DOUT#,State.  -1 indicates unused slot
  def set_digital_output_list(list):
    i = 0
    while i < 8:
      if list[i] >= 0:
        b = list[i + 1] == 1
        set_digital_out(list[i], b)
      end
      i = i + 2
    end
  end
  
  # Turn tool power on/off if enable=2
  def tool_power(on = False, enable = 0):
    if enable < 2:
      return None
    end
  
    if on:
      # ON IO
      set_digital_output_list(robot_tool_on_outputs)
    else:
      # OFF IO
      set_digital_output_list(robot_tool_off_outputs)
    end
  
    return None
  end
  
  # Turn coolant on/off if enable=2
  def coolant_flow(on = False, enable = 0):
    if enable < 2:
      return None
    end
  
    if on:
      # ON IO
      set_digital_output_list(robot_coolant_on_outputs)
    else:
      # OFF IO
      set_digital_output_list(robot_coolant_off_outputs)
    end
  
    return None
  end
  
  # Turn force mode on/off if enable=2
  def apply_force(on = False, enable = 0, force_n = 5, approach_speed_mmps = 10):
    if enable < 2:
      return None
    end
  
    if on:
      izero_ftsensor()
      iforce_mode(force_n, approach_speed_mmps)
      sleep(grind_force_dwell_ms / 1000.0)
    else:
      iend_force_mode()
      sleep(0.1)
    end
  
    return None
  end
  
  # Start/Stop Grinding
  global p_init_count = 1
  # Pose to center is the offset we should move to initial touch point [0]=FLAT [1]=CYLINDER [2]=SPHERE
  global grind_process_state = False
  def set_grind_process_state(on = False, pose_to_center = [p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0]]):
    if on and grind_process_state:
      # Continuing a grind...
  
      # Need to change force?
      # Lift, rezero, and then head toward start of next pattern
      if grind_contact_enable == 2 and imover_force_N != grind_force_N:
        # This would be great, but the sensor drifts and forces returned by get_tcp_force() are offset
        #iforce_update(grind_force_N, grind_touch_speed_mmps)
  
        # So we do a full reset!
        iend_force_mode()
        draw_speed_once(grind_part_speed_mmps)
        draw_to(p[0, 0, -0.004, 0, 0, 0])
        sleep(1)
        izero_ftsensor()
        iforce_mode(grind_force_N, grind_touch_speed_mmps)
      end
  
      # Move to initial grind position relative to initial p_contact_center
      shape = robot_part_geometry[0]
      if shape < 1 or shape > 3:
        return False
      end
  
      global dp_from_contact_center = pose_to_center[shape-1]
      draw_speed_once(grind_part_speed_mmps)
      draw_finish(dp_from_contact_center)
    elif on and not grind_process_state:
      # Need to start the grind
      global p_operator_init = iget_target_tcp_pose()
      local name = "aa_p_operator_init_" + to_str(p_init_count)
      socket_send_pose(name, p_operator_init)
  
      izero_ftsensor()
  
      # Move to start position for touchoff
      shape = robot_part_geometry[0]
      if shape < 1 or shape > 3:
        return False
      end
  
      # TODO This calc isn't exactly right... we will undermove slightly on curved surfaces
      # Think about it
      global dp_from_contact_center = pose_to_center[shape-1]
      draw_origin(p_operator_init)
      forced_speed_setter(grind_part_speed_mmps)
      draw_finish(dp_from_contact_center)
  
      # Touch part and refine p_contact_init
      if not contact_part(True, grind_contact_enable):
        # Failure to contact part should abort... don't set grind_process_state and return False
        draw_finish(p[0, 0, 0, 0, 0, 0])
        socket_send_line("grind_process_state=False")
        return False
      end
  
      # Compute p_contact_center... where we would have been if we had touched off from the operator teach position!
      local  reverse_pose_to_center = pose_to_center[shape-1]
      local i = 0
      while i < 6:
        reverse_pose_to_center[i] = -reverse_pose_to_center[i]
        i = i + 1
      end
      global p_contact_center = pose_trans(p_contact_init, reverse_pose_to_center)
  
      # All remaining grind moves will be relative to this computed center point
      draw_origin(p_contact_center)
  
      local name = "aa_p_contact_center_" + to_str(p_init_count)
      socket_send_pose(name, p_contact_center)
      p_init_count = p_init_count + 1
      if (p_init_count > 4):
        p_init_count = 1
      end
  
      # Should already be here?
      draw_to(dp_from_contact_center)
  
      # Now power everything on (although these will do nothing unless contact_enable==2)
      tool_power(True, grind_contact_enable)
      coolant_flow(True, grind_contact_enable)
      apply_force(True, grind_contact_enable, grind_force_N, grind_touch_speed_mmps)
      global grind_process_state = True
    elif not on and grind_process_state:
      set_ok_to_proceed(True)
  
      # Need to stop the grind
      # Shut everything down and return to original pose
      apply_force(False, grind_contact_enable, 0)
      contact_part(False, grind_contact_enable)
      coolant_flow(False, grind_contact_enable)
      tool_power(False, grind_contact_enable)
  
      # Always end with a move back to with the imover realtime back running
      imover_realtime(True)
      draw_origin(p_operator_init)
      forced_speed_setter(grind_part_speed_mmps)
      draw_finish(p[0, 0, 0, 0, 0, 0])
  
      global grind_process_state = False
    end
  
    # Always let the host know status
    if grind_process_state:
      socket_send_line("grind_process_state=True")
    else:
      socket_send_line("grind_process_state=False")
    end
    return True
  end
  
  ######################################################################################
  # Thread to listen for abort messages while grinding
  #
  global grind_force_report_counter = 0
  global grind_force_report = p[0, 0, 0, 0, 0, 0]
  global grind_force_report_z_n = 0
  thread grind_abort_listener_thread():
    global halt_command = [0, 0, 0, 0]
    global halt_count = 0
    global grind_force_report_counter = 0
    global grind_force_readings_n = 5
    global grind_force_readings = [0., 0., 0., 0., 0.]
  
    # Initialize force readings array
    local i = 0
    while i < grind_force_readings_n:
      local f = get_tcp_force()
      grind_force_readings[i] = f[2]
      i = i + 1
    end
    global grind_force_report_z_n = grind_force_readings[grind_force_readings_n-1]
    global grind_force_filtered_z_n = grind_force_report_z_n
  
  
    while (halt_count == 0):
      # Commands should never arrive, so this will block us for 0.2s
      global halt_command = socket_read_ascii_float(3, timeout = 0.2)
  
      # If door is open, that adds a halt count (anything >0 will stop us!)
      if not is_door_closed():
        global halt_count = halt_count + 1
      end
  
      # If we've received anything we should halt!
      if halt_command[0] > 0:
        global halt_count = halt_count + 1
        socket_send_integer("halt_count", halt_count)
      end
  
      # Increment reading counter (10000 is high enough... don't need to worry about wraparound effects)
      grind_force_report_counter = grind_force_report_counter + 1
      if grind_force_report_counter > 10000:
        grind_force_report_counter = 0
      end
  
      # Store force in circular buffer
      local force = get_tcp_force()
      grind_force_readings[grind_force_report_counter % grind_force_readings_n] = force[2]
  
      # Report force periodically (This executes at 5Hz because of timeout=0.2 in socket_read_ascii_float(...)
      if grind_force_report_counter % 5 == 0:
        # Compute average of the stored readings
        local i = 0
        local sum = 0.0
        while i < grind_force_readings_n:
          sum = sum + grind_force_readings[i]
          i = i + 1
        end
        global grind_force_average_z_n = sum / grind_force_readings_n
  
        # Any other filtering could be done here...
        # Round to 2 DP
        global grind_force_report_z_n = ceil(grind_force_average_z_n * 100) / 100
  
        socket_send_num("grind_force_report_z_n", grind_force_report_z_n)
      end
    end
    return None
  end
  
  # Should we proceed? halt_count==0 means no door-opens and no abort commands from host
  def ok_to_proceed():
    return halt_count == 0
  end
  
  def set_ok_to_proceed(ok):
    if ok:
      global halt_count = 0
    else:
      global halt_count = 99
    end
  end
  #
  # Thread to listen for abort messages while grinding
  ######################################################################################
  
  
  ######################################################################################
  # TOP LEVEL GRIND FUNCTIONS
  #
  # Grind along a line dx_mm x dy_mm centered on current tool position. Repeat n_cycles times. If stay_in_contact, stay_in_contact at end.
  def grind_line(dx_mm, dy_mm, n_cycles, stay_in_contact):
    if n_cycles < 1:
      return True
    end
  
    # Unit conversion
    dx_m = dx_mm / 1000.0
    dy_m = dy_mm / 1000.0
    radius_m = robot_part_geometry[1] / 2000.0
    drx_rad = dx_m / radius_m
    dry_rad = dy_m / radius_m
  
    # Grind time estimate
    time_ms = sqrt(dx_mm * dx_mm + dy_mm * dy_mm) * n_cycles / grind_linear_vel_mps + 1500
    socket_send_integer("robot_step_time_estimate_ms", time_ms)
  
    # Swapping sphere axes here since RY is aligned with the X of the FLAT and CYLINDER geometries
    if not set_grind_process_state(True,
      [
        p[-dx_m / 2.0, -dy_m / 2.0, 0, 0, 0, 0],
        p[-dx_m / 2.0, 0, 0, -dry_rad / 2.0, 0, 0],
        p[0, 0, 0, -dry_rad / 2.0, -drx_rad / 2.0, 0]
      ]):
      return False
    end
  
    # Grind the pattern
    imover_realtime(True)
    start_user_timer()
    shape = robot_part_geometry[0]
    if shape == 1:
      pattern_line_flat(dx_m, dy_m, n_cycles)
    elif shape == 2:
      pattern_line_cylinder(dx_m, dry_rad, n_cycles)
    elif shape == 3:
      # Swapping axes here since RY is aligned with the X of the FLAT and CYLINDER geometries
      pattern_line_sphere(dry_rad, drx_rad, n_cycles)
    end
    stop_user_timer()
  
    if not stay_in_contact or not ok_to_proceed():
      set_grind_process_state(False)
    end
    return True
  end
  
  # Grind along a rect dx_mm x dy_mm centered on current tool position. Repeat n_cycles times. If stay_in_contact, stay_in_contact at end.
  # Move in x direction first, then y
  def grind_rect(dx_mm, dy_mm, n_cycles, stay_in_contact):
    if n_cycles < 1:
      return True
    end
  
    # Unit conversion
    dx_m = dx_mm / 1000.0
    dy_m = dy_mm / 1000.0
    diam_m = robot_part_geometry[1] / 1000.0
    radius_m = diam_m / 2.0
    drx_rad = dx_m / radius_m
    dry_rad = dy_m / radius_m
  
    # Grind time estimate
    time_ms = 2 * (dx_mm + dy_mm) * n_cycles / grind_linear_vel_mps + 1500
    socket_send_integer("robot_step_time_estimate_ms", time_ms)
  
    # Swapping sphere axes here since RY is aligned with the X of the FLAT and CYLINDER geometries
    # 4-point Version
    #if not set_grind_process_state(True,
    #  [
    #    p[-dx_m / 2.0, -dy_m / 2.0, 0, 0, 0, 0],
    #    p[-dx_m / 2.0, 0, 0, -dry_rad / 2.0, 0, 0],
    #    p[0, 0, 0, -dry_rad / 2.0, -drx_rad / 2.0, 0]
    #  ]):
    #  return False
    #end
  
    # 8-point Version
    if not set_grind_process_state(True,
      [
        p[-dx_m / 2.0 + grind_linear_blend_radius_m * 2, -dy_m / 2.0, 0, 0, 0, 0],
        p[-dx_m / 2.0 + grind_linear_blend_radius_m * 2, 0, 0, -dry_rad / 2.0, 0, 0],
        p[0, 0, 0, -dry_rad / 2.0 + grind_angular_blend_radius_rad * 8, -drx_rad / 2.0, 0]
      ]):
      return False
    end
  
    # Grind the pattern
    imover_realtime(True)
    start_user_timer()
    shape = robot_part_geometry[0]
    if shape == 1:
      pattern_rect_flat(dx_m, dy_m, n_cycles)
    elif shape == 2:
      pattern_rect_cylinder(dx_m, dry_rad, n_cycles)
    elif shape == 3:
      # Swapping sphere axes here since RY is aligned with the X of the FLAT and CYLINDER geometries
      pattern_rect_sphere(dry_rad, drx_rad, n_cycles)
    end
    stop_user_timer()
  
    if not stay_in_contact or not ok_to_proceed():
      set_grind_process_state(False)
    end
    return True
  end
  
  # Grind along a rect in serpentine dx_mm,dy_mm incrementing by xstep_mm,ystep_mm centered on current tool position. Repeat n_cycles times. If stay_in_contact, stay_in_contact at end.
  # Move in x direction first, then y
  def grind_serpentine(dx_mm, dy_mm, n_xsteps, n_ysteps, n_cycles, stay_in_contact):
    if n_cycles < 1:
      return True
    end
  
    # Either n_xsteps or n_ysteps must be 1. Whichever one is one will be the direction of the first move.
    if n_xsteps != 1 and n_ysteps != 1:
      return False
    end
  
    # Unit conversion
    dx_m = dx_mm / 1000.0
    dy_m = dy_mm / 1000.0
    part_radius_m = robot_part_geometry[1] / 2000.0
    drx_rad = dx_m / part_radius_m
    dry_rad = dy_m / part_radius_m
  
    # Grind time estimate
    # Per Cycle:
    # 1,3 does 4 passes in x and 1 in y     3,1 does 4 passes in Y and 1 in X
    #   ########################            #  ####  #
    #                          #            #  #  #  #
    #   ########################            #  #  #  #
    #   #                                   #  #  #  #
    #   ########################            #  #  #  #
    #                          #            #  #  #  #
    #   ########################            ####  ####
    if n_xsteps == 1:
      time_ms = (dx_mm * (n_ysteps + 1) + dy_mm) * n_cycles / grind_linear_vel_mps + 1500
    else:
      time_ms = (dx_mm + dy_mm * (n_xsteps + 1)) * n_cycles / grind_linear_vel_mps + 1500
    end
    socket_send_integer("robot_step_time_estimate_ms", time_ms)
  
    # Swapping sphere axes here since RY is aligned with the X of the FLAT and CYLINDER geometries
    if not set_grind_process_state(True,
      [
        p[-dx_m / 2.0, -dy_m / 2.0, 0, 0, 0, 0],
        p[-dx_m / 2.0, 0, 0, -dry_rad / 2.0, 0, 0],
        p[0, 0, 0, -dry_rad / 2.0, -drx_rad / 2.0, 0]
      ]):
      return False
    end
  
    # Grind the pattern
    imover_realtime(True)
    start_user_timer()
    shape = robot_part_geometry[0]
    if shape == 1:
      pattern_serpentine_flat(dx_m, dy_m, n_xsteps, n_ysteps, n_cycles)
    elif shape == 2:
      pattern_serpentine_cylinder(dx_m, dry_rad, n_xsteps, n_ysteps, n_cycles)
    elif shape == 3:
      # Swapping axes here since RY is aligned with the X of the FLAT and CYLINDER geometries
      pattern_serpentine_sphere(dry_rad, drx_rad, n_ysteps, n_xsteps, n_cycles)
    end
    stop_user_timer()
  
    if not stay_in_contact or not ok_to_proceed():
      set_grind_process_state(False)
    end
    return True
  end
  
  # Grind along a polygon with circle_diam_mm and n_sides. Repeat n_cycles times. If stay_in_contact, stay_in_contact at end.
  def grind_poly(circle_diam_mm, n_sides, n_cycles, stay_in_contact):
    if n_cycles < 1:
      return True
    end
  
    # Unit conversion
    local circle_diam_m = circle_diam_mm / 1000.0
    local part_diam_m = robot_part_geometry[1] / 1000.0
  
    # Grind time estimate
    local time_ms = MATH_PI * circle_diam_mm * n_cycles / grind_linear_vel_mps + 1500
    socket_send_integer("robot_step_time_estimate_ms", time_ms)
  
    if not set_grind_process_state(True,
      [
        p[-circle_diam_m / 2.0, 0, 0, 0, 0, 0],
        p[-circle_diam_m / 2.0, 0, 0, 0, 0, 0],
        p[0, 0, 0, -circle_diam_m / part_diam_m, 0, 0]
      ]):
      return False
    end
  
    # Grind the pattern
    imover_realtime(True)
    start_user_timer()
    local shape = robot_part_geometry[0]
    if shape == 1:
      pattern_poly_flat(circle_diam_m, n_sides, n_cycles)
    elif shape == 2:
      pattern_poly_cylinder(circle_diam_m, n_sides, part_diam_m, n_cycles)
    elif shape == 3:
      pattern_poly_sphere(circle_diam_m, n_sides, part_diam_m, n_cycles)
    end
    stop_user_timer()
  
    if not stay_in_contact or not ok_to_proceed():
      set_grind_process_state(False)
    end
    return True
  end
  
  # Grind along a circle with circle_diam_mm. Repeat n_cycles times. If stay_in_contact, stay_in_contact at end.
  def grind_circle(circle_diam_mm, n_cycles, stay_in_contact):
    if n_cycles < 1:
      return True
    end
  
    # Unit conversion
    local circle_diam_m = circle_diam_mm / 1000.0
    local part_diam_m = robot_part_geometry[1] / 1000.0
  
    # Grind time estimate
    local time_ms = MATH_PI * circle_diam_mm * n_cycles / grind_linear_vel_mps + 1500
    socket_send_integer("robot_step_time_estimate_ms", time_ms)
  
    if not set_grind_process_state(True,
      [
        p[-circle_diam_m / 2.0, 0, 0, 0, 0, 0],
        p[-circle_diam_m / 2.0, 0, 0, 0, 0, 0],
        p[0, 0, 0, -circle_diam_m / part_diam_m, 0, 0]
      ]):
      return False
    end
  
    # Grind the pattern
    imover_realtime(False) # True seems to workl!?
    start_user_timer()
    local shape = robot_part_geometry[0]
    if shape == 1:
      pattern_circle_flat(circle_diam_m, n_cycles)
    elif shape == 2:
      pattern_circle_cylinder(circle_diam_m, part_diam_m, n_cycles)
    elif shape == 3:
      pattern_circle_sphere(circle_diam_m, part_diam_m, n_cycles)
    end
    stop_user_timer()
  
    if not stay_in_contact or not ok_to_proceed():
      set_grind_process_state(False)
    end
    return True
  
    if grind_linear_blend_radius_m > 0.0:
      # Try setting n_sides to 1.5 blend radii
      local circum_m = MATH_PI * circle_diam_mm / 1000.
      global grind_circle_n_sides = ceil(circum_m / (grind_linear_blend_radius_m * 1.5))
    end
    return grind_poly(circle_diam_mm, grind_circle_n_sides, n_cycles, stay_in_contact)
  end
  
  # Grind along a spiral circle1_diam_mm to circle2_diam_mm in n_revolutions with rotations centered on current tool position. Repeat n_cycles times. If stay_in_contact, stay_in_contact at end.
  def grind_spiral(circle1_diam_mm, circle2_diam_mm, n_revolutions, n_cycles, stay_in_contact):
    if n_cycles < 1:
      return True
    end
  
    # Unit conversion
    local circle1_diam_m = circle1_diam_mm / 1000.0
    local circle2_diam_m = circle2_diam_mm / 1000.0
    local part_diam_m = robot_part_geometry[1] / 1000.0
  
    # Grind time estimate based on average diam
    local avg_diam_mm = (circle1_diam_mm + circle2_diam_mm) / 2.0
    local time_ms = MATH_PI * avg_diam_mm * n_revolutions * n_cycles / grind_linear_vel_mps + 1500
    socket_send_integer("robot_step_time_estimate_ms", time_ms)
  
    if not set_grind_process_state(True,
      [
        p[-circle1_diam_m / 2.0, 0, 0, 0, 0, 0],
        p[-circle1_diam_m / 2.0, 0, 0, 0, 0, 0],
        p[0, 0, 0, -circle1_diam_m / part_diam_m, 0, 0]
      ]):
      return False
    end
  
    # Grind the pattern
    imover_realtime(False) # True fails!?
    start_user_timer()
    local shape = robot_part_geometry[0]
    if shape == 1:
      pattern_spiral_flat(circle1_diam_m, circle2_diam_m, n_revolutions, n_cycles)
    elif shape == 2:
      pattern_spiral_cylinder(circle1_diam_m, circle2_diam_m, n_revolutions, part_diam_m, n_cycles)
    elif shape == 3:
      pattern_spiral_sphere(circle1_diam_m, circle2_diam_m, n_revolutions, part_diam_m, n_cycles)
    end
    stop_user_timer()
  
    if not stay_in_contact or not ok_to_proceed():
      set_grind_process_state(False)
    end
    return True
  end
  
  
  ######################################################################################
  ######################################################################################
  #
  # PATTERN GRINDING FUNCTIONS
  #
  
  ######################################################################################
  # LINE PATTERNS
  #
  # The line pattern sequence.
  # Assumes all point_dist are declared globally
  def pattern_line(n_cycles):
    global grind_cycle = 1
    local dpdest = dp2
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      socket_send_integer("grind_cycle", grind_cycle)
  
      draw_finish(dpdest)
  
      if dpdest == dp1:
        dpdest = dp2
      else:
        dpdest = dp1
      end
  
      grind_cycle = grind_cycle + 1
    end
  end
  
  # Move along a flat line dx_m x dy_m. Repeat n_cycles times.
  # Move in x direction first, then y
  def pattern_line_flat(dx_m, dy_m, n_cycles):
    local x2 = dx_m / 2.0
    local y2 = dy_m / 2.0
  
    global dp1 = dp_from_contact_center
    global dp2 = p[x2, y2, 0, 0, 0, 0]
  
    pattern_line(n_cycles)
  end
  
  # Move along a cylindrical line dx_m x dy_m. Repeat n_cycles times.
  # Move in x direction first, then y
  def pattern_line_cylinder(dx_m, drx_rad, n_cycles):
    local x2 = dx_m / 2.0
    local rx2 = drx_rad / 2.0
  
    global dp1 = dp_from_contact_center
    global dp2 = p[x2, 0, 0, rx2, 0, 0]
  
    # Cyline calibration is all done using lines on cylinders
    if cyline_cal_enabled:
      start_cal_timer()
    end
  
    pattern_line(n_cycles)
  
    # Cyline calibration cleanup
    if cyline_cal_enabled:
      local t = stop_cal_timer()
      adjust_cyline_coefficient(t)
    end
  end
  
  # Move along a sphere line dx_m x dy_m. Repeat n_cycles times.
  # Move in x direction first, then y
  def pattern_line_sphere(drx_rad, dry_rad, n_cycles):
    local rx2 = drx_rad / 2.0
    local ry2 = dry_rad / 2.0
  
    global dp1 = dp_from_contact_center
    global dp2 = p[0, 0, 0, rx2, ry2, 0]
  
    pattern_line(n_cycles)
  end
  
  ######################################################################################
  # RECT PATTERNS
  #
  # The rect pattern sequence. Assumes all points are defined globally!
  def pattern_rect(n_cycles):
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      socket_send_integer("grind_cycle", grind_cycle)
  
      # 4-point version (With blend)
      # Fails for blend radius/sanity check when in contact
      #draw_to(dp2)
      #draw_to(dp3)
      #draw_to(dp4)
      #if grind_cycle == n_cycles:
      #  draw_finish(dp1)
      #else:
      #  draw_to(dp1)
      #end
  
      # 4-point version (Without blend)
      #draw_finish(dp2)
      #draw_finish(dp3)
      #draw_finish(dp4)
      #draw_finish(dp1)
  
      # 8-point version (With blend)
      # Fails for blend radius/sanity check when in contact
      #draw_to(dp2a)
      #draw_to(dp2b)
      #draw_to(dp3a)
      #draw_to(dp3b)
      #draw_to(dp4a)
      #draw_to(dp4b)
      #draw_to(dp1a)
      #if grind_cycle == n_cycles:
      #  draw_finish(dp1b)
      #else:
      #  draw_to(dp1b)
      #end
  
      # 8-point version (Without blend)
      draw_finish(dp2a)
      draw_finish(dp2b)
      draw_finish(dp3a)
      draw_finish(dp3b)
      draw_finish(dp4a)
      draw_finish(dp4b)
      draw_finish(dp1a)
      draw_finish(dp1b)
  
      grind_cycle = grind_cycle + 1
    end
  end
  
  # Move along a flat rect dx_m x dy_m. Repeat n_cycles times.
  # Move in x direction first, then y
  def pattern_rect_flat(dx_m, dy_m, n_cycles):
    local x2 = dx_m / 2.0
    local y2 = dy_m / 2.0
  
    local dx = grind_linear_blend_radius_m * 2
  
    global dp1 = p[-x2, -y2, 0, 0, 0, 0]
    global dp1a = dp1
    global dp1b = dp1
    dp1a[1] = dp1a[1] + dx
    dp1b[0] = dp1b[0] + dx
  
    global dp2 = p[x2, -y2, 0, 0, 0, 0]
    global dp2a = dp2
    global dp2b = dp2
    dp2a[0] = dp2a[0] - dx
    dp2b[1] = dp2b[1] + dx
  
    global dp3 = p[x2, y2, 0, 0, 0, 0]
    global dp3a = dp3
    global dp3b = dp3
    dp3a[1] = dp3a[1] - dx
    dp3b[0] = dp3b[0] - dx
  
    global dp4 = p[-x2, y2, 0, 0, 0, 0]
    global dp4a = dp4
    global dp4b = dp4
    dp4a[0] = dp4a[0] + dx
    dp4b[1] = dp4b[1] - dx
  
    pattern_rect(n_cycles)
  end
  
  # Move along a cylindrical rect dx_mm,drx_rad. Repeat n_cycles times.
  # Move in x direction first, then rx
  def pattern_rect_cylinder(dx_m, drx_rad, n_cycles):
    local x2 = dx_m / 2.0
    local rx2 = drx_rad / 2.0
  
    local dx = grind_linear_blend_radius_m * 2
    local da = grind_angular_blend_radius_rad * 8
  
    global dp1 = p[-x2, 0, 0, -rx2, 0, 0]
    global dp1a = dp1
    global dp1b = dp1
    dp1a[3] = dp1a[3] + da
    dp1b[0] = dp1b[0] + dx
  
    global dp2 = p[x2, 0, 0, -rx2, 0, 0]
    global dp2a = dp2
    global dp2b = dp2
    dp2a[0] = dp2a[0] - dx
    dp2b[3] = dp2b[3] + da
  
    global dp3 = p[x2, 0, 0, rx2, 0, 0]
    global dp3a = dp3
    global dp3b = dp3
    dp3a[3] = dp3a[3] - da
    dp3b[0] = dp3b[0] - dx
  
    global dp4 = p[-x2, 0, 0, rx2, 0, 0]
    global dp4a = dp4
    global dp4b = dp4
    dp4a[0] = dp4a[0] + dx
    dp4b[3] = dp4b[3] - da
  
    pattern_rect(n_cycles)
  end
  
  # Move along a spherical rect drx_rad,dry_rad. Repeat n_cycles times.
  # Move in rx direction first, then ry
  def pattern_rect_sphere(drx_rad, dry_rad, n_cycles):
    local rx2 = drx_rad / 2.0
    local ry2 = dry_rad / 2.0
  
    local da = grind_angular_blend_radius_rad * 8
  
    global dp1 = p[0, 0, 0, -rx2, -ry2, 0]
    global dp1a = dp1
    global dp1b = dp1
    dp1a[4] = dp1a[4] + da
    dp1b[3] = dp1b[3] + da
  
    global dp2 = p[0, 0, 0, rx2, -ry2, 0]
    global dp2a = dp2
    global dp2b = dp2
    dp2a[3] = dp2a[3] - da
    dp2b[4] = dp2b[4] + da
  
    global dp3 = p[0, 0, 0, rx2, ry2, 0]
    global dp3a = dp3
    global dp3b = dp3
    dp3a[4] = dp3a[4] - da
    dp3b[3] = dp3b[3] - da
  
    global dp4 = p[0, 0, 0, -rx2, ry2, 0]
    global dp4a = dp4
    global dp4b = dp4
    dp4a[3] = dp4a[3] + da
    dp4b[4] = dp4b[4] - da
  
    pattern_rect(n_cycles)
  end
  
  ######################################################################################
  # SERPENTINE PATTERNS
  #
  # Move along a flat serpentine dx_m,dy_m in n_xsteps,n_ysteps. Repeat n_cycles times.
  # Move in direction of whichever nsteps is 1 first
  def pattern_serpentine_flat(dx_m, dy_m, n_xsteps, n_ysteps, n_cycles):
    local t_move_x = dx_m / grind_linear_vel_mps
    local t_move_y = dy_m / grind_linear_vel_mps
  
    # Bottom left corner, grid 0,0
    local x2 = dx_m / 2.0
    local y2 = dy_m / 2.0
    local dp1 = dp_from_contact_center
    local dp2 = dp1
  
    # Track our grid square number... we're in [0,0] and moving [+1,+1] in either x or y
    local x_grid = 0
    local y_grid = 0
    local x_incr = 1
    local y_incr = 1
    local grid_dx_m = dx_m / n_xsteps
    local grid_dy_m = dy_m / n_ysteps
  
    # How many moves does it take to complete a pass?
    global n_moves_per_pass = (n_xsteps + n_ysteps) * 2 - 1
  
    local move_count = 0
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      # This will repeat for each leg of the serpentine!
      socket_send_integer("grind_cycle", grind_cycle)
  
      # Skip first X move if we should start with a y move
      if move_count != 0 or n_xsteps == 1:
        # Advance x_grid by x_incr
        x_grid = x_grid + x_incr
  
        # Move to the corresponding position
        local dp = p[x_grid * grid_dx_m - x2, y_grid * grid_dy_m - y2, 0, 0, 0, 0]
        if move_count == n_moves_per_pass:
          draw_finish(dp)
        else:
          #draw_to(dp, r = 0)  # No blend
          draw_to(dp)  # Use blend
        end
  
        # Adjust x direction
        if x_grid >= n_xsteps:
          x_incr = -1
        elif x_grid <= 0:
          x_incr = 1
        end
        move_count = move_count + 1
      end
  
      if ok_to_proceed() and move_count < n_moves_per_pass:
        # Advance y_grid by y_incr
        y_grid = y_grid + y_incr
  
        # Move to the corresponding position
        local dp = p[x_grid * grid_dx_m - x2, y_grid * grid_dy_m - y2, 0, 0, 0, 0]
        if move_count == n_moves_per_pass:
          draw_finish(dp)
        else:
          #draw_to(dp, r = 0)  # No blend
          draw_to(dp)  # Use blend
        end
  
        # Adjust y direction
        if y_grid >= n_ysteps:
          y_incr = -1
        elif y_grid <= 0:
          y_incr = 1
        end
        move_count = move_count + 1
      end
  
      # Detect when we've covered all the grid squares!
      if move_count >= n_moves_per_pass:
        grind_cycle = grind_cycle + 1
        move_count = 0
      end
    end
  end
  
  # Move along a cylindrical serpentine dx_m,drx_rad in n_xsteps,n_rxsteps. Repeat n_cycles times.
  # Move in direction of whichever nsteps is 1 first
  def pattern_serpentine_cylinder(dx_m, drx_rad, n_xsteps, n_rxsteps, n_cycles):
    local t_move_x = dx_m / grind_linear_vel_mps
    local t_move_rx = drx_rad / grind_angular_vel_rps / 4
  
    # Bottom left corner, grid 0,0
    local x2 = dx_m / 2.0
    local rx2 = drx_rad / 2.0
    local dp1 = dp_from_contact_center
    local dp2 = dp1
  
    # Track our grid square number... we're in [0,0] and moving [+1,+1] in either x or y
    local x_grid = 0
    local y_grid = 0
    local x_incr = 1
    local y_incr = 1
    local grid_dx_m = dx_m / n_xsteps
    local grid_drx_rad = drx_rad / n_rxsteps
    local last_a = grind_linear_accel_mpss
    local last_v = grind_linear_vel_mps
  
    # How many moves does it take to complete a pass?
    global n_moves_per_pass = (n_xsteps + n_rxsteps) * 2 - 1
  
    local move_count = 0
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      # This will repeat for each leg of the serpentine!
      socket_send_integer("grind_cycle", grind_cycle)
  
      # Skip first X move if we should start with a y move
      if move_count != 0 or n_xsteps == 1:
        # Advance x_grid by x_incr
        x_grid = x_grid + x_incr
  
        # Move to the corresponding position
        local dp = p[x_grid * grid_dx_m - x2, 0, 0, y_grid * grid_drx_rad - rx2, 0, 0]
        if move_count == n_moves_per_pass:
          draw_finish(dp)
        else:
          #draw_to(dp, r = 0)  # No blend
          draw_to(dp)  # Use blend
        end
  
        # Adjust x direction
        if x_grid >= n_xsteps:
          x_incr = -1
        elif x_grid <= 0:
          x_incr = 1
        end
        move_count = move_count + 1
      end
  
      if ok_to_proceed() and move_count < n_moves_per_pass:
        # Advance y_grid by y_incr
        y_grid = y_grid + y_incr
  
        # Move to the corresponding position
        local dp = p[x_grid * grid_dx_m - x2, 0, 0, y_grid * grid_drx_rad - rx2, 0, 0]
        if move_count == n_moves_per_pass:
          draw_finish(dp)
        else:
          #draw_to(dp, r = 0)  # No blend
          draw_to(dp)  # Use blend
        end
  
        # Adjust y direction
        if y_grid >= n_rxsteps:
          y_incr = -1
        elif y_grid <= 0:
          y_incr = 1
        end
        move_count = move_count + 1
      end
  
      # Detect when we've covered all the grid squares!
      if move_count >= n_moves_per_pass:
        grind_cycle = grind_cycle + 1
        move_count = 0
      end
    end
  end
  
  # Move along a spherical serpentine drx_rad,dry_rad in n_rxsteps,n_rysteps. Repeat n_cycles times.
  # Move in direction of whichever nsteps is 1 first
  def pattern_serpentine_sphere(drx_rad, dry_rad, n_rxsteps, n_rysteps, n_cycles):
    local t_move_rx = drx_rad / grind_angular_vel_rps / 4
    local t_move_ry = dry_rad / grind_angular_vel_rps / 4
  
    # Bottom left corner, grid 0,0
    local rx2 = drx_rad / 2.0
    local ry2 = dry_rad / 2.0
    local dp1 = dp_from_contact_center
    local dp2 = dp1
  
    # Track our grid square number... we're in [0,0] and moving [+1,+1] in either x or y
    local x_grid = 0
    local y_grid = 0
    local x_incr = 1
    local y_incr = 1
    local grid_drx_rad = drx_rad / n_rxsteps
    local grid_dry_rad = dry_rad / n_rysteps
  
    # How many moves does it take to complete a pass?
    global n_moves_per_pass = (n_rxsteps + n_rysteps) * 2 - 1
  
    local move_count = 0
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      # This will repeat for each leg of the serpentine!
      socket_send_integer("grind_cycle", grind_cycle)
  
      # Skip first X move if we should start with a y move
      if move_count != 0 or n_rxsteps == 1:
        # Advance x_grid by x_incr
        x_grid = x_grid + x_incr
  
        # Move to the corresponding position
        local dp = p[0, 0, 0, x_grid * grid_drx_rad - rx2, y_grid * grid_dry_rad - ry2, 0]
        if move_count == n_moves_per_pass:
          draw_finish(dp)
        else:
          #draw_to(dp, r = 0)  # No blend
          draw_to(dp)  # Use blend
        end
  
        # Adjust x direction
        if x_grid >= n_rxsteps:
          x_incr = -1
        elif x_grid <= 0:
          x_incr = 1
        end
        move_count = move_count + 1
      end
  
      if ok_to_proceed() and move_count < n_moves_per_pass:
        # Advance y_grid by y_incr
        y_grid = y_grid + y_incr
  
        # Move to the corresponding position
        local dp = p[0, 0, 0, x_grid * grid_drx_rad - rx2, y_grid * grid_dry_rad - ry2, 0]
        if move_count == n_moves_per_pass:
          draw_finish(dp)
        else:
          #draw_to(dp, r = 0)  # No blend
          draw_to(dp)  # Use blend
        end
  
        # Adjust y direction
        if y_grid >= n_rysteps:
          y_incr = -1
        elif y_grid <= 0:
          y_incr = 1
        end
        move_count = move_count + 1
      end
  
      # Detect when we've covered all the grid squares!
      if move_count >= n_moves_per_pass:
        grind_cycle = grind_cycle + 1
        move_count = 0
      end
    end
  end
  
  ######################################################################################
  # POLYGONAL PATTERNS
  #
  # Grind along a polygon with circle_diam_m and n_sides on a flat. Repeat n_cycles times.
  def pattern_poly_flat(circle_diam_m, n_sides, n_cycles):
    local circle_radius_m = circle_diam_m / 2.0
  
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      socket_send_integer("grind_cycle", grind_cycle)
      local i = 0
      while ok_to_proceed() and i <= n_sides:
        local theta = d2r(180.0 + 360.0 * i / n_sides)
        local x = circle_radius_m * cos(theta)
        local y = circle_radius_m * sin(theta)
  
        local dp = p[x, y, 0, 0, 0, 0]
        if not ok_to_proceed() or i == n_sides:
          draw_finish(dp)
        else:
          #draw_to(dp, r = 0)  # No blend
          draw_to(dp)  # Use blend
        end
        i = i + 1
      end
  
      grind_cycle = grind_cycle + 1
    end
  end
  
  # Grind along a polygon with circle_diam_m and n_sides on a cylinder_radius_m. Repeat n_cycles times.
  def pattern_poly_cylinder(circle_diam_m, n_sides, cylinder_radius_m, n_cycles):
    local circle_radius_m = circle_diam_m / 2.0
  
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      socket_send_integer("grind_cycle", grind_cycle)
      local i = 0
      while ok_to_proceed() and i <= n_sides:
        local theta = d2r(180.0 + 360.0 * i / n_sides)
        local x = circle_radius_m * cos(theta)
        local y = circle_radius_m * sin(theta)
        local rx = 2.0 * y / cylinder_radius_m
  
        local dp = p[x, 0, 0, rx, 0, 0]
        if not ok_to_proceed() or i == n_sides:
          draw_finish(dp)
        else:
          #draw_to(dp, r = 0)  # No blend
          draw_to(dp)  # Use blend
        end
        i = i + 1
      end
  
      grind_cycle = grind_cycle + 1
    end
  end
  
  # Grind along a polygon with circle_diam_m and n_sides on a sphere_diam_m. Repeat n_cycles times.
  def pattern_poly_sphere(circle_diam_m, n_sides, sphere_diam_m, n_cycles):
    local circle_radius_m = circle_diam_m / 2.0
    local sphere_radius_m = sphere_diam_m / 2.0
  
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      socket_send_integer("grind_cycle", grind_cycle)
      local i = 0
      while ok_to_proceed() and i <= n_sides:
        local theta = d2r(180.0 + 360.0 * i / n_sides)
        local x = circle_radius_m * cos(theta)
        local rx = x / sphere_radius_m
        local y = circle_radius_m * sin(theta)
        local ry = y / sphere_radius_m
  
        local dp = p[0, 0, 0, rx, ry, 0]
        if not ok_to_proceed() or i == n_sides:
          draw_finish(dp)
        else:
          #draw_to(dp, r = 0)  # No blend
          draw_to(dp)  # Use blend
        end
        i = i + 1
      end
  
      grind_cycle = grind_cycle + 1
    end
  end
  
  ######################################################################################
  # CIRCULAR PATTERNS
  #
  global grind_circle_n_sides = 0
  # How many points should we use for a circle diam_m at speed_mps?
  def recommend_npoints(diam_m, speed_mps):
    local n_points_per_second = 2
    local circum_m = MATH_PI * diam_m
  
    # Calc 1: Interrupt rate
    # Want at least so many points per second
    local t_circle = circum_m / speed_mps
    global grind_circle_n_sides1 = limiter(ceil(t_circle * grind_point_frequency_hz), 2, 1000)
  
    # Calc 2: Smoothness
    # 100mm diam gets 50 points... seems about right
    global grind_circle_n_sides2 = limiter(diam_m * 500, 2, 1000)
  
    global grind_circle_n_sides = max(grind_circle_n_sides1, grind_circle_n_sides2)
  
    global grind_circle_n_sides3 = 0
    if grind_linear_blend_radius_m > 0.001:
      # Calc 3: Stay ahead of blend radius
      # Do a point every 3 blend radii
      global grind_circle_n_sides3 = limiter(ceil(circum_m / (grind_linear_blend_radius_m * 3)), 2, 1000)
      global grind_circle_n_sides = max(grind_circle_n_sides, grind_circle_n_sides3)
    end
  
    socket_send_num("aa_grind_circle_n_sides1", grind_circle_n_sides1)
    socket_send_num("aa_grind_circle_n_sides2", grind_circle_n_sides2)
    socket_send_num("aa_grind_circle_n_sides3", grind_circle_n_sides3)
    socket_send_num("aa_grind_circle_n_sides", grind_circle_n_sides)
    return grind_circle_n_sides
  end
  
  # Grind along a circle with circle_diam_m on a flat. Repeat n_cycles times.
  def pattern_circle_flat(circle_diam_m, n_cycles):
    local circle_radius_m = circle_diam_m / 2.0
    local n_points = recommend_npoints(circle_diam_m, grind_linear_vel_mps)
  
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      socket_send_integer("grind_cycle", grind_cycle)
      local i = 0
      while ok_to_proceed() and i <= n_points:
        local theta = d2r(180.0 + 360.0 * i / n_points)
        local x = circle_radius_m * cos(theta)
        local y = circle_radius_m * sin(theta)
  
        local dp = p[x, y, 0, 0, 0, 0]
        if not ok_to_proceed() or i == n_points:
          draw_finish(dp)
        else:
          draw_to(dp)
        end
        i = i + 1
      end
  
      grind_cycle = grind_cycle + 1
    end
  end
  
  # Grind along a circle with circle_diam_m on a cylinder_radius_m. Repeat n_cycles times.
  def pattern_circle_cylinder(circle_diam_m, cylinder_radius_m, n_cycles):
    local circle_radius_m = circle_diam_m / 2.0
    local n_points = recommend_npoints(circle_diam_m, grind_linear_vel_mps)
  
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      socket_send_integer("grind_cycle", grind_cycle)
      local i = 0
      while ok_to_proceed() and i <= n_points:
        local theta = d2r(180.0 + 360.0 * i / n_points)
        local x = circle_radius_m * cos(theta)
        local y = circle_radius_m * sin(theta)
        local rx = 2.0 * y / cylinder_radius_m
  
        local dp = p[x, 0, 0, rx, 0, 0]
        if not ok_to_proceed() or i == n_points:
          draw_finish(dp)
        else:
          draw_to(dp)
        end
        i = i + 1
      end
  
      grind_cycle = grind_cycle + 1
    end
  end
  
  # Grind along a circle with circle_diam_m on a sphere_diam_m. Repeat n_cycles times.
  def pattern_circle_sphere(circle_diam_m, sphere_diam_m, n_cycles):
    local circle_radius_m = circle_diam_m / 2.0
    local sphere_radius_m = sphere_diam_m / 2.0
    local n_points = recommend_npoints(circle_diam_m, grind_linear_vel_mps)
  
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      socket_send_integer("grind_cycle", grind_cycle)
      local i = 0
      while ok_to_proceed() and i <= n_points:
        local theta = d2r(180.0 + 360.0 * i / n_points)
        local x = circle_radius_m * cos(theta)
        local rx = x / sphere_radius_m
        local y = circle_radius_m * sin(theta)
        local ry = y / sphere_radius_m
  
        local dp = p[0, 0, 0, rx, ry, 0]
        if not ok_to_proceed() or i == n_points:
          draw_finish(dp)
        else:
          draw_to(dp)
        end
        i = i + 1
      end
  
      grind_cycle = grind_cycle + 1
    end
  end
  
  ######################################################################################
  # SPIRAL PATTERNS
  #
  # Grind a flat spiral from diam1 to diam2 in n_revolutions revolutions
  def new_pattern_spiral_flat(circle1_diam_m, circle2_diam_m, n_revolutions, n_cycles):
    local max_diam_m = max(circle1_diam_m, circle2_diam_m)
    local circle1_radius_m = circle1_diam_m / 2.0
    local circle2_radius_m = circle2_diam_m / 2.0
  
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      socket_send_integer("grind_cycle", grind_cycle)
  
      # Initial conditions
      local theta = d2r(180.0)
      local r_m = circle1_radius_m
      local revs_completed = 0.0
      local rev_slope = (circle2_radius_m - circle1_radius_m) / n_revolutions
      local move_m = grind_linear_blend_radius_m * 2
      #socket_send_num("aa_rev_slope", rev_slope)
      #socket_send_num("aa_move_m", move_m)
      #socket_send_num("aa_revs_completed", revs_completed)
      #socket_send_num("aa_r_m", r_m)
  
      while ok_to_proceed() and revs_completed < n_revolutions:
        local delta_theta = move_m / r_m
        local theta = theta + delta_theta
        #socket_send_num("aa_delta_theta", delta_theta)
        #socket_send_num("aa_theta", theta)
        local x = r_m * cos(theta)
        local y = r_m * sin(theta)
  
        local dp = p[x, y, 0, 0, 0, 0]
        if not ok_to_proceed() or revs_completed >= n_revolutions:
          draw_finish(dp)
        else:
          draw_to(dp)
        end
  
        local revs_completed = revs_completed + delta_theta / (2 * MATH_PI)
        local r_m = circle1_radius_m + rev_slope * revs_completed
        #socket_send_num("aa_revs_completed", revs_completed)
        #socket_send_num("aa_r_m", r_m)
      end
  
      grind_cycle = grind_cycle + 1
  
      # Next cycle- swap diameters so we go in/out/in etc.
      local old_circle1_radius_m = circle1_radius_m
      local circle1_radius_m = circle2_radius_m
      local circle2_radius_m = old_circle1_radius_m
    end
  end
  
  # Grind a flat spiral from diam1 to diam2 in n_revolutions revolutions
  def pattern_spiral_flat(circle1_diam_m, circle2_diam_m, n_revolutions, n_cycles):
    local max_diam_m = max(circle1_diam_m, circle2_diam_m)
    local n_points = recommend_npoints(max_diam_m, grind_linear_vel_mps)
    local n_total_points = n_revolutions * n_points
    local circle1_radius_m = circle1_diam_m / 2.0
    local circle2_radius_m = circle2_diam_m / 2.0
  
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      socket_send_integer("grind_cycle", grind_cycle)
  
      local rslope = (circle2_radius_m - circle1_radius_m) / n_total_points
      local i = 0
      while ok_to_proceed() and i <= n_total_points:
        local theta = d2r(180.0 + 360.0 * (i % n_points) / n_points)
        local r_instantaneous = i * rslope + circle1_radius_m
        local x = r_instantaneous * cos(theta)
        local y = r_instantaneous * sin(theta)
  
        local dp = p[x, y, 0, 0, 0, 0]
        if not ok_to_proceed() or i == n_total_points:
          draw_finish(dp)
        else:
          draw_to(dp)
        end
        i = i + 1
      end
  
      grind_cycle = grind_cycle + 1
  
      # Next cycle- swap diameters so we go in/out/in etc.
      local old_circle1_radius_m = circle1_radius_m
      local circle1_radius_m = circle2_radius_m
      local circle2_radius_m = old_circle1_radius_m
    end
  end
  
  # Grind a spiral on a cylinder from diam1 to diam2 in n_revolutions revolutions
  def pattern_spiral_cylinder(circle1_diam_m, circle2_diam_m, n_revolutions, cylinder_radius_m, n_cycles):
    local max_diam_m = max(circle1_diam_m, circle2_diam_m)
    local n_points = recommend_npoints(max_diam_m, grind_linear_vel_mps)
    local n_total_points = n_revolutions * n_points
    local circle1_radius_m = circle1_diam_m / 2.0
    local circle2_radius_m = circle2_diam_m / 2.0
  
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      socket_send_integer("grind_cycle", grind_cycle)
      local rslope = (circle2_radius_m - circle1_radius_m) / n_total_points
      local i = 0
      while ok_to_proceed() and i <= n_total_points:
        local theta = d2r(180.0 + 360.0 * (i % n_points) / n_points)
        local r_instantaneous = i * rslope + circle1_radius_m
        local x = r_instantaneous * cos(theta)
        local y = r_instantaneous * sin(theta)
        local rx = 2.0 * y / cylinder_radius_m
  
        local dp = p[x, 0, 0, rx, 0, 0]
  
        if not ok_to_proceed() or i == n_total_points:
          draw_finish(dp)
        else:
          draw_to(dp)
        end
        i = i + 1
      end
      grind_cycle = grind_cycle + 1
  
      # Next cycle- swap diameters so we go in/out/in etc.
      local old_circle1_radius_m = circle1_radius_m
      local circle1_radius_m = circle2_radius_m
      local circle2_radius_m = old_circle1_radius_m
    end
  end
  
  # Grind a spiral on a sphere from diam1 to diam2 in n_revolutions revolutions
  def pattern_spiral_sphere(circle1_diam_m, circle2_diam_m, n_revolutions, sphere_diam_m, n_cycles):
    local max_diam_m = max(circle1_diam_m, circle2_diam_m)
    local n_points = recommend_npoints(max_diam_m, grind_linear_vel_mps)
    local n_total_points = n_revolutions * n_points
    local circle1_radius_m = circle1_diam_m / 2.0
    local circle2_radius_m = circle2_diam_m / 2.0
    local sphere_radius_m = sphere_diam_m / 2.0
  
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      socket_send_integer("grind_cycle", grind_cycle)
      local rslope = (circle2_radius_m - circle1_radius_m) / n_total_points
      local i = 0
      while ok_to_proceed() and i <= n_total_points:
        local theta = d2r(180.0 + 360.0 * (i % n_points) / n_points)
        local r_instantaneous = i * rslope + circle1_radius_m
        local x = r_instantaneous * cos(theta)
        local rx = x / sphere_radius_m
        local y = r_instantaneous * sin(theta)
        local ry = y / sphere_radius_m
  
        local dp = p[0, 0, 0, rx, ry, 0]
        if not ok_to_proceed() or i == n_total_points:
          draw_finish(dp)
        else:
          draw_to(dp)
        end
        i = i + 1
      end
      grind_cycle = grind_cycle + 1
  
      # Next cycle- swap diameters so we go in/out/in etc.
      local old_circle1_radius_m = circle1_radius_m
      local circle1_radius_m = circle2_radius_m
      local circle2_radius_m = old_circle1_radius_m
    end
  end
  $ 5 "init_autogrind()"
  init_autogrind()
  $ 6 "currentTcpPose≔get_actual_tcp_pose()"
  global currentTcpPose= get_actual_tcp_pose ()
  $ 7 "MoveJ"
  $ 8 "currentTcpPose" "breakAfter"
  movej(currentTcpPose, a=1.3962634015954636, v=1.0471975511965976)
  $ 9 "socket_is_open≔ False "
  global socket_is_open=  False  
  while (True):
    $ 10 "Robot Program"
    $ 11 "Loop socket_is_open ≟  False "
    while (socket_is_open  ==    False  ):
      $ 12 "Wait: 0.25"
      sleep(0.25)
      $ 13 "socket_close()"
      socket_close()
      $ 14 "socket_is_open≔socket_open('169.254.254.200', 30000)"
      global socket_is_open=socket_open("169.254.254.200", 30000)
      $ 15 "If not socket_is_open"
      if (not socket_is_open):
        $ 16 "socket_is_open≔socket_open('169.254.254.210', 30000)"
        global socket_is_open=socket_open("169.254.254.210", 30000)
      end
      $ 17 "If not socket_is_open"
      if (not socket_is_open):
        $ 18 "socket_is_open≔socket_open('192.168.0.252', 30000)"
        global socket_is_open=socket_open("192.168.0.252", 30000)
      end
    end
    $ 19 "response≔'Unknown command'"
    global response="Unknown command"
    $ 20 "command≔socket_read_ascii_float(12)"
    global command=socket_read_ascii_float(12)
    $ 21 "If command_validate()"
    if (command_validate()):
      $ 22 "command_start()"
      command_start()
      $ 23 "Set Stacklight=On"
      set_standard_digital_out(0, True)
      $ 24 "Switch command[1]"
      switch_1 = command[1]
      $ 25 "Case 10"
      if (10 == switch_1):
        $ 26 "return_actual_tcp_pose()"
        return_actual_tcp_pose()
      elif (12 == switch_1):
        $ 27 "Case 12"
        $ 28 "return_tcp_offset()"
        return_tcp_offset()
      elif (13 == switch_1):
        $ 29 "Case 13"
        $ 30 "movel_relative_base(p[command[2], command[3], command[4], command[5], command[6], command[7]])"
        movel_relative_base(p[command[2], command[3], command[4], command[5], command[6], command[7]])
      elif (14 == switch_1):
        $ 31 "Case 14"
        $ 32 "movel_relative_tcp(p[command[2], command[3], command[4], command[5], command[6], command[7]])"
        movel_relative_tcp(p[command[2], command[3], command[4], command[5], command[6], command[7]])
      elif (15 == switch_1):
        $ 33 "Case 15"
        $ 34 "movel_relative_tcp_part(p[command[2], command[3], command[4], command[5], command[6], command[7]])"
        movel_relative_tcp_part(p[command[2], command[3], command[4], command[5], command[6], command[7]])
      elif (16 == switch_1):
        $ 35 "Case 16"
        $ 36 "movel_one_only(command[2],command[3])"
        movel_one_only(command[2],command[3])
      elif (18 == switch_1):
        $ 37 "Case 18"
        $ 38 "movel_rot_only(command[2],command[3],command[4])"
        movel_rot_only(command[2],command[3],command[4])
      elif (20 == switch_1):
        $ 39 "Case 20"
        $ 40 "return_get_actual_joint_positions()"
        return_get_actual_joint_positions()
      elif (21 == switch_1):
        $ 41 "Case 21"
        $ 42 "movej_ag([command[2], command[3], command[4], command[5], command[6], command[7]])"
        movej_ag([command[2], command[3], command[4], command[5], command[6], command[7]])
      elif (22 == switch_1):
        $ 43 "Case 22"
        $ 44 "movel_ag(p[command[2], command[3], command[4], command[5], command[6], command[7]])"
        movel_ag(p[command[2], command[3], command[4], command[5], command[6], command[7]])
      elif (25 == switch_1):
        $ 45 "Case 25"
        $ 46 "return_both_positions()"
        return_both_positions()
      elif (30 == switch_1):
        $ 47 "Case 30"
        $ 48 "set_variable()"
        set_variable()
      elif (35 == switch_1):
        $ 49 "Case 35"
        $ 50 "set_grind_variable()"
        set_grind_variable()
      elif (40 == switch_1):
        $ 51 "Case 40"
        $ 52 "grind()"
        grind()
      elif (98 == switch_1):
        $ 53 "Case 98"
        $ 54 "response≔'socket reset'"
        global response="socket reset"
      elif (99 == switch_1):
        $ 55 "Case 99"
        $ 56 "response≔'exiting'"
        global response="exiting"
      else:
        $ 57 "Default Case"
        $ 58 "response≔'unknown command'"
        global response="unknown command"
      end
      $ 59 "command_finish()"
      command_finish()
      $ 60 "Set Stacklight=Off"
      set_standard_digital_out(0, False)
      $ 61 "If command[1]≟98"
      if (command[1] == 98):
        $ 62 "Wait: 0.5"
        sleep(0.5)
        $ 63 "socket_close()"
        socket_close()
        $ 64 "socket_is_open≔ False "
        global socket_is_open=  False  
      end
      $ 65 "If command[1]≟99"
      if (command[1] == 99):
        $ 66 "Wait: 0.5"
        sleep(0.5)
        $ 67 "socket_close()"
        socket_close()
        $ 68 "socket_is_open≔ False "
        global socket_is_open=  False  
        $ 69 "Halt"
        halt
      end
    else:
      $ 70 "Else" "noBreak"
      $ 71 "no_command()"
      no_command()
    end
  end
end
