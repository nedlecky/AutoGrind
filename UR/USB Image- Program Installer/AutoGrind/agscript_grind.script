# File: agscript_grind.cs
# Project: AutoGrind
# Author: Ned Lecky, Olympus Controls
# Purpose: All grinding functions used in AutoGrind

global grind_abort_listener_thread_handle = 0
global pattern_grind_thread_handle = 0

global halt_count = 0
global halt_command = [0, 0, 0, 0]

global grind_ready = True
# grind_contact_enable:  0=No Contact   1=Touch but no tool/coolant on or force  2=Touch, Tool, Coolant, and Force
global grind_contact_enable = 0
global grind_touch_retract_mm = 3       # How far to retract after touch  (we do 2X this for ghrind_contact_enable=1)
global grind_touch_speed_mmps = 0.1     # How fast to go in for the touch
global grind_force_dwell_ms = 500       # How long to dwell after turning force more on
global grind_blend_radius_m = 0.001     # Blend radius to use while grinding
global grind_trial_speed_mmps = 20      # Grinding speed when not really grinding!
global grind_accel_mmpss = 100          # Acceleration to use in grinding moves

# Planning points
global p_operator_init = p[0, 0, 0, 0, 0, 0]    # Where we were when operator issued first grind command
global p_contact_init = p[0, 0, 0, 0, 0, 0]     # Where we first contacted the part
global p_contact_center = p[0, 0, 0, 0, 0, 0]   # Computed where center of pattern would be in contact with part

MATH_PI = 3.1415926535

# Set global grind_n_cycles based on whether we really going to grind
def n_cycle_setter(n_cycles):
  if grind_contact_enable == 2:
    global grind_n_cycles = limiter(n_cycles, 0, 100)
  else:
    global grind_n_cycles = limiter(n_cycles, 0, 1)
  end
  socket_set_var("grind_n_cycles", grind_n_cycles)
end

# Set all speed and acceleration globals based on part geometry and whether we really going to grind
def speed_setter(speed_mmps):
  speed_mmps = limiter(speed_mmps, 0.1, 40)
  if grind_contact_enable == 2:
    global grind_speed_mps = speed_mmps / 1000.0
  else:
    global grind_speed_mps = grind_trial_speed_mmps / 1000.0
  end
  global grind_accel_mpss = grind_accel_mmpss / 1000.0

  # Default rotational speeds same as linear
  global grind_rot_speed_rps = grind_speed_mps
  global grind_rot_accel_rpss = grind_accel_mpss
  global grind_rot_blend_radius_rad = grind_blend_radius_m

  # If part is cylinder or spherical, diameter will be >0
  diam_m = robot_part_geometry[1] / 1000.0
  if diam_m > 0.0:
    # These are 1/4 the theoretical rotational speeds but we need to set them like this to get the correct speed- why??????
    global grind_rot_speed_rps = grind_speed_mps * 0.5 / diam_m
    global grind_rot_accel_rpss = grind_accel_mpss * 0.5 / diam_m
    global grind_rot_blend_radius_rad = grind_blend_radius_m * 0.5 / diam_m
  end
end

# Set grind variables chosen by command[2]
# Value after set is always returned to socket
def set_grind_variable():
  global grind_ready = False
  socket_send_line("grind_ready=False")

  if command[2] == 1:
    global response = "set grind_contact_enable"
    if command[3] >= 0 and command[3] <= 2:
      global grind_contact_enable = command[3]
    end
    socket_set_var("grind_contact_enable", grind_contact_enable)
  elif command[2] == 2:
    global response = "set grind_touch_retract_mm"
    if command[3] >= 0:
      global grind_touch_retract_mm = command[3]
    end
    socket_set_var("grind_touch_retract_mm", grind_touch_retract_mm)
  elif command[2] == 3:
    global response = "set grind_touch_speed_mmps"
    if command[3] >= 0:
      global grind_touch_speed_mmps = command[3]
    end
    socket_set_var("grind_touch_speed_mmps", grind_touch_speed_mmps)
  elif command[2] == 4:
    global response = "set grind_force_dwell_ms"
    if command[3] >= 0:
      global grind_force_dwell_ms = command[3]
    end
    socket_set_var("grind_force_dwell_ms", grind_force_dwell_ms)
  elif command[2] == 5:
    global response = "set grind_max_wait_ms"
    if command[3] >= 0:
      global grind_max_wait_ms = command[3]
    end
    socket_set_var("grind_max_wait_ms", grind_max_wait_ms)
  elif command[2] == 6:
    global response = "set grind_blend_radius_mm"
    if command[3] >= 0:
      global grind_blend_radius_m = command[3] / 1000.0
    end
    socket_send_string("grind_blend_radius_mm=")
    socket_send_string(grind_blend_radius_m * 1000.0)
    socket_send_lf()
  elif command[2] == 7:
    global response = "set grind_trial_speed_mmps"
    if command[3] > 0:
      global grind_trial_speed_mmps = command[3]
    end
    socket_set_var("grind_trial_speed_mmps", grind_trial_speed_mmps)
  elif command[2] == 8:
    global response = "set grind_accel_mmpss"
    if command[3] > 0:
      global grind_accel_mmpss = command[3]
    end
    socket_set_var("grind_accel_mmpss", grind_accel_mmpss)
  else:
    global response = "Unknown grind set variable command"
  end

  global grind_ready = True
  socket_send_line("grind_ready=True")
end

# Execute the desired grind operation as specified in command[2]...
def grind():
  global grind_ready = False
  socket_send_line("grind_ready=False")

  # Start listening for abort commands from host
  if grind_abort_listener_thread_handle > 0:
    kill grind_abort_listener_thread_handle
    grind_abort_listener_thread_handle = 0
  end
  grind_abort_listener_thread_handle = run grind_abort_listener_thread()

  global grind_cycle = 0
  socket_set_var("grind_cycle", grind_cycle)

  # Defaults but any used should be set as needed below
  global grind_dx_mm = 0
  global grind_dy_mm = 0
  global grind_n_cycles = 0
  global grind_force_N = 10.0
  global grind_continue = False
  global grind_circle1_diam_mm = 0
  global grind_circle2_diam_mm = 0
  global grind_n_spirals = 0
  global grind_n_xsteps = 1
  global grind_n_ysteps = 1
  global grind_xstep_mm = 0
  global grind_ystep_mm = 0
  speed_setter(20)

  # Install tcp that puts tcp at center of part (noop for flat parts!)
  set_tcp(robot_tcp_part)

  if command[2] == 10:
    # LINEAR GRIND
    global response = "grind_line"
    global grind_dx_mm = limiter(command[3], 0, 1000)
    global grind_dy_mm = limiter(command[4], 0, 1000)
    n_cycle_setter(command[5])
    speed_setter(command[6])
    global grind_force_N = limiter(command[7], 0, 100)
    global grind_continue = command[8] > 0
    grind_line(grind_dx_mm, grind_dy_mm, grind_n_cycles, grind_continue)

  elif command[2] == 20:
    # RECTANGULAR GRIND
    global response = "grind_rect"
    global grind_dx_mm = limiter(command[3], 0, 1000)
    global grind_dy_mm = limiter(command[4], 0, 1000)
    n_cycle_setter(command[5])
    speed_setter(command[6])
    global grind_force_N = limiter(command[7], 0, 100)
    global grind_continue = command[8] > 0
    grind_rect(grind_dx_mm, grind_dy_mm, grind_n_cycles, grind_continue)

  elif command[2] == 30:
    # SERPENTINE GRIND
    global response = "grind_serpentine"
    global grind_dx_mm = limiter(command[3], 0, 1000)
    global grind_dy_mm = limiter(command[4], 0, 1000)
    global grind_n_xsteps = limiter(command[5], 1, grind_dx_mm)
    global grind_n_ysteps = limiter(command[6], 1, grind_dy_mm)
    n_cycle_setter(command[7])
    speed_setter(command[8])
    global grind_force_N = limiter(command[9], 0, 10)
    global grind_continue = command[10] > 0
    grind_serpentine(grind_dx_mm, grind_dy_mm, grind_n_xsteps, grind_n_ysteps, grind_n_cycles, grind_continue)

  elif command[2] == 40:
    # CIRCULAR GRIND
    global response = "grind_circle"
    global grind_circle1_diam_mm = limiter(command[3], 0, 1000)
    n_cycle_setter(command[4])
    speed_setter(command[5])
    global grind_force_N = limiter(command[6], 0, 100)
    global grind_continue = command[7] > 0
    grind_circle(grind_circle1_diam_mm, grind_n_cycles, grind_continue)

  elif command[2] == 50:
    # SPIRAL GRIND
    global response = "grind_spiral"
    global grind_circle1_diam_mm = limiter(command[3], 0, 1000)
    global grind_circle2_diam_mm = limiter(command[4], 0, 1000)
    global grind_n_spirals = limiter(command[5], 1, 100)
    n_cycle_setter(command[6])
    speed_setter(command[7])
    global grind_force_N = limiter(command[8], 0, 100)
    global grind_continue = command[9] > 0
    grind_spiral(grind_circle1_diam_mm, grind_circle2_diam_mm, grind_n_spirals, grind_n_cycles, grind_continue)

  elif command[2] == 99:
    # Retract Command
    global response = "grind_retract"
    set_grind_process_state(False)

  else:
    # Illegal grind command
    global response = "Unknown grind command"
  end

  # Restore tool-only tcp
  set_tcp(robot_tcp)

  # Stop listening for abort commands from host
  if grind_abort_listener_thread_handle > 0:
    kill grind_abort_listener_thread_handle
    grind_abort_listener_thread_handle = 0
  end

  global grind_ready = True
  socket_send_line("grind_ready=True")
end

# Get into contact with part (or away from it)
# enable:  0=No Contact   1=Touch but no tool/coolant on or force  2=Touch, Tool, Coolant, and Force
def contact_part(on = False, enable = 0):
  if on:
    if enable == 0:
      # Just do a small forward motion in the direction of touchoff- this is a simulated p_contact_init
      p_contact_init = pose_trans(get_forward_kin(), p[0, 0, 0.005, 0, 0, 0])
      movel(p_contact_init, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
    elif enable == 1:
      # Advance until contact but retract 2X grind distance and use this as a simulated p_contact_init
      success = touchoff(grind_touch_speed_mmps, grind_touch_retract_mm * 2.0)
      p_contact_init = get_target_tcp_pose()
      return success
    elif enable == 2:
      # Advance until contact
      success = touchoff(grind_touch_speed_mmps, grind_touch_retract_mm)
      # Touchoff has backed off by grind_touch_retract_mm so we need to compute that actual p_contact_init
      p_contact_init = pose_trans(get_forward_kin(), p[0, 0, grind_touch_retract_mm / 1000.0, 0, 0, 0])
      return success
    end
  else:  # Back off
    stopl(2.0)
    sleep(0.020)
    p1 = pose_trans(get_forward_kin(), p[0, 0, -0.010, 0, 0, 0])
    movel(p1, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
  end

  return True
end

# Sets digital outpus based 8-element list of 4 pairs DOUT#,State.  -1 indicates unused slot
def set_digital_output_list(list):
  i = 0
  while i < 8:
    if list[i] >= 0:
      b = list[i + 1] == 1
      set_digital_out(list[i], b)
    end
    i = i + 2
  end
end

# Turn tool power on/off if enable=2
def tool_power(on = False, enable = 0):
  if enable < 2:
    return None
  end

  if on:
    # ON IO
    set_digital_output_list(robot_tool_on_outputs)
  else:
    # OFF IO
    set_digital_output_list(robot_tool_off_outputs)
  end

  return None
end

# Turn coolant on/off if enable=2
def coolant_flow(on = False, enable = 0):
  if enable < 2:
    return None
  end

  if on:
    # ON IO
    set_digital_output_list(robot_coolant_on_outputs)
  else:
    # OFF IO
    set_digital_output_list(robot_coolant_off_outputs)
  end

  return None
end

# Turn foce mode on/pff if enable=2
def apply_force(on = False, enable = 0, approach_speed_mmps = 10):
  if enable < 2:
    return None
  end

  if on:
    # Settle and zero the force/torque sensor
    sleep(0.1)
    zero_ftsensor()
    # Force is in tool frame
    # Compliant in Tool Z
    # Applying grind_force_N in Z+
    # 2: Force frame not transformed
    # Speed limits
    force_mode(tool_pose(), [0, 0, 1, 0, 0, 0], [0.0, 0.0, grind_force_N, 0.0, 0.0, 0.0], 2, [0.1, 0.1, approach_speed_mmps / 1000.0, 0.3490658503988659, 0.3490658503988659, 0.3490658503988659])
    # Now we sleep as directed to hopefully come into contact with the part!
    sleep(grind_force_dwell_ms / 1000.0)
  else:
    end_force_mode()
    sleep(0.1)
  end

  return None
end

# Start/stop Grinding (on/off)
# Pose to center is the offset we shgould move to initial touch point [0]=FLAT [1]=CYLINDER [2]=SPHERE
global grind_process_state = False
def set_grind_process_state(on = False, pose_to_center = [p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0]]):
  if on and not grind_process_state:
    global p_operator_init = get_target_tcp_pose()

    # Move to start position for touchoff
    shape = robot_part_geometry[0]
    if shape < 1 or shape > 3:
      return False
    end

    p1 = pose_trans(p_operator_init, pose_to_center[shape-1])
    movel(p1, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)

    # Touch part and set p_contact_init
    if not contact_part(True, grind_contact_enable):
      # Failure to contact part should abort... don't set grind_process_state and return False
      movel(p_operator_init, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
      socket_send_line("grind_process_state=False")
      return False
    end

    # Compute p_contact_center... where we would have been if we had touched off from the operator teach position!
    reverse_pose_to_center = pose_to_center[shape-1]
    i = 0
    while i < 6:
      reverse_pose_to_center[i] = -reverse_pose_to_center[i]
      i = i + 1
    end
    global p_contact_center = pose_trans(p_contact_init, reverse_pose_to_center)

    # Now power everything on (although these will do nothing unless conact_enable==2)
    tool_power(True, grind_contact_enable)
    coolant_flow(True, grind_contact_enable)
    apply_force(True, grind_contact_enable, grind_touch_speed_mmps)
    grind_process_state = True
  elif not on and grind_process_state:
    # Shut everything down and return to original pose
    apply_force(False, grind_contact_enable, 0)
    contact_part(False, grind_contact_enable)
    coolant_flow(False, grind_contact_enable)
    tool_power(False, grind_contact_enable)
    movel(p_operator_init, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
    grind_process_state = False
  end

  # Always let the host know status
  if grind_process_state:
    socket_send_line("grind_process_state=True")
  else:
    socket_send_line("grind_process_state=False")
  end
  return True
end

######################################################################################
# Thread to listen for abort messages while grinding
#
thread grind_abort_listener_thread():
  global halt_command = [0, 0, 0, 0]
  global halt_count = 0
  while (halt_count == 0):
    global halt_command = socket_read_ascii_float(3, timeout = 0.1)

    # If door is open, that adds a halt count (anything >0 will stop us!)
    if not is_door_closed():
      global halt_count = halt_count + 1
    end

    # If we've received(index,checksum,10,...) that adds a halt count (as long as checksum matches)
    if halt_command[0] > 2:
      global test_index = halt_command[1]
      global test_checksum = halt_command[2]
      global test_command = halt_command[3]

      if test_checksum == 1000 - test_index and test_command == 10:
        global halt_count = halt_count + 1

        # Send an start/finish acknowledgement just for this command!
        socket_set_var("robot_starting", test_index)
        socket_set_var("robot_completed", test_index)
      end
    end
    sync()
  end
  return None
end

# Should we proceed? lat_count==0 means no door-opens and no abort commands from host
def ok_to_proceed():
  return halt_count == 0
end
#
# Thread to listen for abort messages while grinding
######################################################################################


######################################################################################
# TOP LEVEL GRIND FUNCTIONS
#

# Grind along a line dx_mm x dy_mm centered on current tool position. Repeat n_cycles times. If stay_in_contact, stay_in_contact at end.
def grind_line(dx_mm, dy_mm, n_cycles, stay_in_contact):
  if n_cycles < 1:
    return True
  end

  # Unit conversion
  dx_m = dx_mm / 1000.0
  dy_m = dy_mm / 1000.0
  radius_m = robot_part_geometry[1] / 2000.0
  drx_rad = dx_m / radius_m
  dry_rad = dy_m / radius_m

  # Grind time estimate
  time_ms = sqrt(dx_mm * dx_mm + dy_mm * dy_mm) * n_cycles / grind_speed_mps + 1500
  socket_set_var("robot_step_time_estimate_ms", time_ms)

  if not set_grind_process_state(True, [p[-dx_m / 2.0, -dy_m / 2.0, 0, 0, 0, 0], p[-dx_m / 2.0, 0, 0, -dry_rad / 2.0, 0, 0], p[0, 0, 0, -drx_rad / 2.0, -dry_rad / 2.0, 0]]):
    return False
  end

  # Grind the pattern
  shape = robot_part_geometry[0]
  diam_m = robot_part_geometry[1] / 1000.0
  if shape == 1:
    pattern_line_flat(p_contact_center, dx_m, dy_m, n_cycles)
  elif shape == 2:
    # Speed factor is 0.5/diam for pure rotational (all y) and 1.0 for pure translational (all x)
    max_speed_factor = 0.5 / diam_m
    theta = atan2(abs(dy_mm), abs(dx_mm))
    speed_factor = 1.0 + (max_speed_factor-1.0) * abs(sin(theta))
    pattern_line_cylinder(p_contact_center, dx_m, dry_rad, speed_factor, n_cycles)
  elif shape == 3:
    pattern_line_sphere(p_contact_center, drx_rad, dry_rad, n_cycles)
  end

  if not stay_in_contact or not ok_to_proceed():
    set_grind_process_state(False)
  end
  return True
end

# Grind along a rect dx_mm x dy_mm centered on current tool position. Repeat n_cycles times. If stay_in_contact, stay_in_contact at end.
# Move in x direction first, then y
def grind_rect(dx_mm, dy_mm, n_cycles, stay_in_contact):
  if n_cycles < 1:
    return True
  end

  # Unit conversion
  dx_m = dx_mm / 1000.0
  dy_m = dy_mm / 1000.0
  diam_m = robot_part_geometry[1] / 1000.0
  radius_m = diam_m / 2.0
  drx_rad = dx_m / radius_m
  dry_rad = dy_m / radius_m
  speed_factor = 0.5 / diam_m  # 0.5 / diam_m is the speedup needed on rotational moves

  # Grind time estimate
  time_ms = 2 * (dx_mm + dy_mm) * n_cycles / grind_speed_mps + 1500
  socket_set_var("robot_step_time_estimate_ms", time_ms)

  # Swapping sphere axes here since RY is aligned with the X of the FLAT and CYLINDER geometries
  if not set_grind_process_state(True, [p[-dx_m / 2.0, -dy_m / 2.0, 0, 0, 0, 0], p[-dx_m / 2.0, 0, 0, -dry_rad / 2.0, 0, 0], p[0, 0, 0, -dry_rad / 2.0, -drx_rad / 2.0, 0]]):
    return False
  end

  # Grind the pattern
  shape = robot_part_geometry[0]
  if shape == 1:
    pattern_rect_flat(p_contact_center, dx_m, dy_m, n_cycles)
  elif shape == 2:
    pattern_rect_cylinder(p_contact_center, dx_m, dry_rad, n_cycles)
  elif shape == 3:
    # Swapping sphere axes here since RY is aligned with the X of the FLAT and CYLINDER geometries
    pattern_rect_sphere(p_contact_center, dry_rad, drx_rad, n_cycles)
  end

  if not stay_in_contact or not ok_to_proceed():
    set_grind_process_state(False)
  end
  return True
end

# Grind along a rect in serpentine dx_mm,dy_mm incrementing by xstep_mm,ystep_mm centered on current tool position. Repeat n_cycles times. If stay_in_contact, stay_in_contact at end.
# Move in x direction first, then y
def grind_serpentine(dx_mm, dy_mm, n_xsteps, n_ysteps, n_cycles, stay_in_contact):
  if n_cycles < 1:
    return True
  end

  # Either n_xsteps or n_ysteps must be 1. Whichever one is one will be the direction of the first move.
  if n_xsteps != 1 and n_ysteps != 1:
    return False
  end

  # Unit conversion
  dx_m = dx_mm / 1000.0
  dy_m = dy_mm / 1000.0
  part_radius_m = robot_part_geometry[1] / 2000.0
  drx_rad = dx_m / part_radius_m
  dry_rad = dy_m / part_radius_m

  # Grind time estimate
  # Per Cycle:
  # 1,3 does 4 passes in x and 1 in y     3,1 does 4 passes in Y and 1 in X
  #   ########################            #  ####  #
  #                          #            #  #  #  #
  #   ########################            #  #  #  #
  #   #                                   #  #  #  #
  #   ########################            #  #  #  #
  #                          #            #  #  #  #
  #   ########################            ####  ####
  if n_xsteps == 1:
    time_ms = (dx_mm * (n_ysteps + 1) + dy_mm) * n_cycles / grind_speed_mps + 1500
  else:
    time_ms = (dx_mm + dy_mm * (n_xsteps + 1)) * n_cycles / grind_speed_mps + 1500
  end
  socket_set_var("robot_step_time_estimate_ms", time_ms)

  # Swapping sphere axes here since RY is aligned with the X of the FLAT and CYLINDER geometries
  if not set_grind_process_state(True, [p[-dx_m / 2.0, -dy_m / 2.0, 0, 0, 0, 0], p[-dx_m / 2.0, 0, 0, -dry_rad / 2.0, 0, 0], p[0, 0, 0, -dry_rad / 2.0, -drx_rad / 2.0, 0]]):
    return False
  end

  # Grind the pattern
  shape = robot_part_geometry[0]
  if shape == 1:
    pattern_serpentine_flat(p_contact_center, dx_m, dy_m, n_xsteps, n_ysteps, n_cycles)
  elif shape == 2:
    pattern_serpentine_cylinder(p_contact_center, dx_m, dry_rad, n_xsteps, n_ysteps, n_cycles)
  elif shape == 3:
    # Swapping axes here since RY is aligned with the X of the FLAT and CYLINDER geometries
    pattern_serpentine_sphere(p_contact_center, dry_rad, drx_rad, n_ysteps, n_xsteps, n_cycles)
  end

  if not stay_in_contact or not ok_to_proceed():
    set_grind_process_state(False)
  end
  return True
end

# Grind along a circle with circle_diam_mm centered on p_center. Repeat n_cycles times. If stay_in_contact, stay_in_contact at end.
def grind_circle(circle_diam_mm, n_cycles, stay_in_contact):
  if n_cycles < 1:
    return True
  end

  # Unit conversion
  circle_diam_m = circle_diam_mm / 1000.0
  part_diam_m = robot_part_geometry[1] / 1000.0

  # Grind time estimate
  time_ms = MATH_PI * circle_diam_mm * n_cycles / grind_speed_mps + 1500
  socket_set_var("robot_step_time_estimate_ms", time_ms)


  if not set_grind_process_state(True, [p[-circle_diam_m / 2.0, 0, 0, 0, 0, 0], p[-circle_diam_m / 2.0, 0, 0, 0, 0, 0], p[0, 0, 0, -circle_diam_m / part_diam_m, 0, 0]]):
    return False
  end

  # Grind the pattern
  shape = robot_part_geometry[0]
  if shape == 1:
    pattern_circle_flat(p_contact_center, circle_diam_m, n_cycles)
  elif shape == 2:
    pattern_circle_cylinder(p_contact_center, circle_diam_m, part_diam_m, n_cycles)
  elif shape == 3:
    pattern_circle_sphere(p_contact_center, circle_diam_m, part_diam_m, n_cycles)
  end

  if not stay_in_contact or not ok_to_proceed():
    set_grind_process_state(False)
  end
  return True
end

# Grind along a spiral circle1_diam_mm to circle2_diam_mm in n_spirals with rotations centered on current tool position. Repeat n_cycles times. If stay_in_contact, stay_in_contact at end.
def grind_spiral(circle1_diam_mm, circle2_diam_mm, n_spirals, n_cycles, stay_in_contact):
  if n_cycles < 1:
    return True
  end

  # Unit conversion
  circle1_diam_m = circle1_diam_mm / 1000.0
  circle2_diam_m = circle2_diam_mm / 1000.0
  part_diam_m = robot_part_geometry[1] / 1000.0

  # Grind time estimate based on average diam
  avg_diam_mm = (circle1_diam_mm + circle2_diam_mm) / 2.0
  time_ms = MATH_PI * avg_diam_mm * n_spirals * n_cycles / grind_speed_mps + 1500
  socket_set_var("robot_step_time_estimate_ms", time_ms)

  if not set_grind_process_state(True, [p[-circle1_diam_m / 2.0, 0, 0, 0, 0, 0], p[-circle1_diam_m / 2.0, 0, 0, 0, 0, 0], p[0, 0, 0, -circle1_diam_m / part_diam_m, 0, 0]]):
    return False
  end

  # Grind the pattern
  shape = robot_part_geometry[0]
  if shape == 1:
    pattern_spiral_flat(p_contact_center, circle1_diam_m, circle2_diam_m, n_spirals, n_cycles)
  elif shape == 2:
    pattern_spiral_cylinder(p_contact_center, circle1_diam_m, circle2_diam_m, n_spirals, part_diam_m, n_cycles)
  elif shape == 3:
    pattern_spiral_sphere(p_contact_center, circle1_diam_m, circle2_diam_m, n_spirals, part_diam_m, n_cycles)
  end

  if not stay_in_contact or not ok_to_proceed():
    set_grind_process_state(False)
  end
  return True
end


######################################################################################
# PATTERN GRINDING SUPPORT FUNCTIONS
#

#
# Segmented move grind_movel... grinds along a polygon point by point (in any coordinates) in 250mS segments
#
global grind_movel_p_center = p[0, 0, 0, 0, 0, 0]
global grind_movel_dp1 = p[0, 0, 0, 0, 0, 0]
global grind_movel_p1 = p[0, 0, 0, 0, 0, 0]
global grind_movel_p_latest = p[0, 0, 0, 0, 0, 0]
global grind_movel_accel_mpss = 1
global grind_movel_speed_mps = 1

# Start a grind_movel
def grind_movel_start(p_center, dp, a, v):
  global grind_movel_p_center = p_center
  global grind_movel_dp1 = dp
  global grind_movel_p1 = pose_trans(p_center, grind_movel_dp1)
  global grind_movel_p_latest = grind_movel_p1
  global grind_movel_accel_mpss = a
  global grind_movel_speed_mps = v

  global grind_cycle = 1
  if ok_to_proceed():
    movel(grind_movel_p1, a = a, v = v)
  end
end

# Complete a grind_movel
def grind_movel_finish():
  movel(grind_movel_p_latest, a = grind_movel_accel_mpss, v = grind_movel_speed_mps)
  #pattern_complete()
end

# Next waypoint in the polygon
def grind_movel(dp, a, v, t, r):
  if not ok_to_proceed():
    return None
  end

  # Compute our delta dp
  local ddp = dp
  local i = 0
  while i <= 5:
    ddp[i] = ddp[i] - grind_movel_dp1[i]
    i = i + 1
  end

  local n = 1
  if t > 0:
    n = ceil(t * 4.0) # number of segments to use; 4 per second ==> can stop within 0.25s
  end

  local i = 1
  while i <= n:
    local dp = grind_movel_dp1
    local scale = i / n
    local j = 0
    while j <= 5:
      dp[j] = grind_movel_dp1[j] + ddp[j] * scale
      j = j + 1
    end
    global grind_movel_p_latest = pose_trans(grind_movel_p_center, dp)
    local br = r
    if not ok_to_proceed():
      local br = 0
    end
    movel(grind_movel_p_latest, a = a, v = v, r = br)
    if not ok_to_proceed():
      break
    end
    i = i + 1
  end
  global grind_movel_dp1 = dp
end

# Call at end of pattern
def pattern_complete():
  # This stops motion but won't kill force_mode the way stopl will
  local p0 = get_actual_tcp_pose()
  movel(p0, a = grind_accel_mpss, v = grind_speed_mps)

  # If you are inside the old blend radius the above did nothing!
  # So try again
  local p0 = get_actual_tcp_pose()
  movel(p0, a = grind_accel_mpss, v = grind_speed_mps)
end

######################################################################################
######################################################################################
######################################################################################
#
# PATTERN GRINDING FUNCTIONS
#

######################################################################################
# LINE PATTERNS
#

# Move along a flat line dx_m x dy_m centered on p_center. Repeat n_cycles times.
# Move in x direction first, then y
def pattern_line_flat(p_center, dx_m, dy_m, n_cycles):
  local dp1 = p[-dx_m / 2.0, -dy_m / 2.0, 0, 0, 0, 0]
  local dp2 = p[dx_m / 2.0, dy_m / 2.0, 0, 0, 0, 0]
  local t_move = sqrt(dx_m * dx_m + dy_m * dy_m) / grind_speed_mps
  local dp_dest = dp2

  global grind_cycle = 1
  grind_movel_start(p_center, dp1, a = grind_accel_mpss, v = grind_speed_mps)
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)

    grind_movel(dp_dest, a = grind_accel_mpss, v = grind_speed_mps, t = t_move, r = grind_blend_radius_m)

    # Alternate directions for multiple cycles
    if dp_dest == dp1:
      dp_dest = dp2
    else:
      dp_dest = dp1
    end

    grind_cycle = grind_cycle + 1
  end
  grind_movel_finish()
end

# Move along a cylindrical line dx_mm,drx_rad centered on p_center. Repeat n_cycles times.
# Move in x direction first, then rx
def pattern_line_cylinder(p_center, dx_m, drx_rad, speed_factor, n_cycles):
  dp1 = p[-dx_m / 2.0, 0, 0, -drx_rad / 2.0, 0, 0]
  dp2 = p[dx_m / 2.0, 0, 0, drx_rad / 2.0, 0, 0]
  t_move = sqrt(pow(dx_m / grind_speed_mps, 2) + pow(drx_rad / grind_rot_speed_rps / 4, 2))
  local dp_dest = dp2

  global grind_cycle = 1
  grind_movel_start(p_center, dp1, a = grind_accel_mpss * speed_factor, v = grind_speed_mps * speed_factor)
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)

    grind_movel(dp_dest, a = grind_accel_mpss * speed_factor, v = grind_speed_mps * speed_factor, t = t_move, r = grind_blend_radius_m * speed_factor)

    # Alternate directions for multiple cycles
    if dp_dest == dp1:
      dp_dest = dp2
    else:
      dp_dest = dp1
    end

    grind_cycle = grind_cycle + 1
  end
  grind_movel_finish()
end

# Move along a spherical line drx_rad,dry_rad centered on p_center. Repeat n_cycles times.
# Move in rx direction first, then ry
def pattern_line_sphere(p_center, drx_rad, dry_rad, n_cycles):
  dp1 = p[0, 0, 0, -drx_rad / 2.0, -dry_rad / 2.0, 0]
  dp2 = p[0, 0, 0, drx_rad / 2.0, dry_rad / 2.0, 0]
  t_move = sqrt(drx_rad * drx_rad + dry_rad * dry_rad) / grind_rot_speed_rps / 4
  local dp_dest = dp2

  global grind_cycle = 1
  grind_movel_start(p_center, dp1, a = grind_rot_accel_rpss, v = grind_rot_speed_rps)
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)

    grind_movel(dp_dest, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, t = t_move, r = grind_rot_blend_radius_rad)

    # Alternate directions for multiple cycles
    if dp_dest == dp1:
      dp_dest = dp2
    else:
      dp_dest = dp1
    end

    grind_cycle = grind_cycle + 1
  end
  grind_movel_finish()
end


######################################################################################
# RECT PATTERNS
#

# Move along a flat rect dx_m x dy_m centered on p_center. Repeat n_cycles times.
# Move in x direction first, then y
def pattern_rect_flat(p_center, dx_m, dy_m, n_cycles):
  local t_move_x = dx_m / grind_speed_mps
  local t_move_y = dy_m / grind_speed_mps

  local x2 = dx_m / 2.0
  local y2 = dy_m / 2.0

  local dp1 = p[-x2, -y2, 0, 0, 0, 0]
  local dp1a = p[-x2 + grind_blend_radius_m * 1.1, -y2, 0, 0, 0, 0]
  local dp2 = p[x2, -y2, 0, 0, 0, 0]
  local dp3 = p[x2, y2, 0, 0, 0, 0]
  local dp4 = p[-x2, y2, 0, 0, 0, 0]

  global grind_cycle = 1

  grind_movel_start(p_center, dp1, a = grind_accel_mpss, v = grind_speed_mps)
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)

    grind_movel(dp2, a = grind_accel_mpss, v = grind_speed_mps, t = t_move_x, r = grind_blend_radius_m)
    grind_movel(dp3, a = grind_accel_mpss, v = grind_speed_mps, t = t_move_y, r = grind_blend_radius_m)
    grind_movel(dp4, a = grind_accel_mpss, v = grind_speed_mps, t = t_move_x, r = grind_blend_radius_m)
    grind_movel(dp1, a = grind_accel_mpss, v = grind_speed_mps, t = t_move_y, r = grind_blend_radius_m)

    grind_cycle = grind_cycle + 1
  end
  # dp1a just barely turns the corner, larger then the blend radius
  # This stops the motion since you need to be out of bland radius and move with blend=0 to stop motion!
  grind_movel(dp1a, a = grind_accel_mpss, v = grind_speed_mps, t = 0, r = 0)
  grind_movel_finish()
end

# Move along a cylindrical rect dx_mm,drx_rad centered on p_center. Repeat n_cycles times.
# Move in x direction first, then rx
def pattern_rect_cylinder(p_center, dx_m, drx_rad, n_cycles):
  local t_move_x = dx_m / grind_speed_mps
  local t_move_rx = drx_rad / grind_rot_speed_rps / 4
  local x2 = dx_m / 2.0
  local rx2 = drx_rad / 2.0

  local dp1 = p[-x2, 0, 0, -rx2, 0, 0]
  local dp1a = p[-x2 + grind_rot_blend_radius_rad * 5, 0, 0, -rx2, 0, 0]
  local dp2 = p[x2, 0, 0, -rx2, 0, 0]
  local dp3 = p[x2, 0, 0, rx2, 0, 0]
  local dp4 = p[-x2, 0, 0, rx2, 0, 0]

  global grind_cycle = 1
  grind_movel_start(p_center, dp1, a = grind_accel_mpss, v = grind_speed_mps)
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)

    grind_movel(dp2, a = grind_accel_mpss, v = grind_speed_mps, t = t_move_x, r = grind_blend_radius_m)
    grind_movel(dp3, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, t = t_move_rx, r = grind_rot_blend_radius_rad)
    grind_movel(dp4, a = grind_accel_mpss, v = grind_speed_mps, t = t_move_x, r = grind_blend_radius_m)
    grind_movel(dp1, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, t = t_move_rx, r = grind_rot_blend_radius_rad)

    grind_cycle = grind_cycle + 1
  end
  # dp1a just barely turns the corner, larger then the blend radius
  # This stops the motion since you need to be out of bland radius and move with blend=0 to stop motion!
  grind_movel(dp1a, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, t = 0, r = 0)
  grind_movel_finish()
end

# Move along a spherical rect drx_rad,dry_rad centered on p_center. Repeat n_cycles times.
# Move in rx direction first, then ry
def pattern_rect_sphere(p_center, drx_rad, dry_rad, n_cycles):
  local t_move_rx = drx_rad / grind_rot_speed_rps / 4
  local t_move_ry = dry_rad / grind_rot_speed_rps / 4
  local rx2 = drx_rad / 2.0
  local ry2 = dry_rad / 2.0

  local dp1 = p[0, 0, 0, -rx2, -ry2, 0]
  local dp1a = p[0, 0, 0, -rx2 + grind_rot_blend_radius_rad * 5, -ry2, 0]
  local dp2 = p[0, 0, 0, rx2, -ry2, 0]
  local dp3 = p[0, 0, 0, rx2, ry2, 0]
  local dp4 = p[0, 0, 0, -rx2, ry2, 0]

  global grind_cycle = 1
  grind_movel_start(p_center, dp1, a = grind_rot_accel_rpss, v = grind_rot_speed_rps)
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)

    grind_movel(dp2, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, t = t_move_rx, r = grind_rot_blend_radius_rad)
    grind_movel(dp3, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, t = t_move_ry, r = grind_rot_blend_radius_rad)
    grind_movel(dp4, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, t = t_move_rx, r = grind_rot_blend_radius_rad)
    grind_movel(dp1, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, t = t_move_ry, r = grind_rot_blend_radius_rad)

    grind_cycle = grind_cycle + 1
  end
  # dp1a just barely turns the corner, larger then the blend radius
  # This stops the motion since you need to be out of bland radius and move with blend=0 to stop motion!
  grind_movel(dp1a, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, t = 0, r = 0)
  grind_movel_finish()
end


######################################################################################
# SERPENTINE PATTERNS
#

# Move along a flat serpentine dx_m,dy_m in n_xsteps,n_ysteps centered on p_center. Repeat n_cycles times.
# Move in direction of whichever nsteps is 1 first
def pattern_serpentine_flat(p_center, dx_m, dy_m, n_xsteps, n_ysteps, n_cycles):
  local t_move_x = dx_m / grind_speed_mps
  local t_move_y = dy_m / grind_speed_mps

  # Bottom left corner, grid 0,0
  local x2 = dx_m / 2.0
  local y2 = dy_m / 2.0
  local dp1 = p[-x2, -y2, 0, 0, 0, 0]


  # Track our grid square number... we're in [0,0] and moving [+1,+1] in either x or y
  local x_grid = 0
  local y_grid = 0
  local x_incr = 1
  local y_incr = 1
  local grid_dx_m = dx_m / n_xsteps
  local grid_dy_m = dy_m / n_ysteps

  # How many moves does it take to complete a pass?
  global n_moves_per_pass = (n_xsteps + n_ysteps) * 2 - 1

  local move_count = 0
  global grind_cycle = 1
  grind_movel_start(p_center, dp1, a = grind_accel_mpss, v = grind_speed_mps)
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    # This will repeat for each leg of the serpentine!
    socket_set_var("grind_cycle", grind_cycle)

    # Skip first X move if we should start with a y move
    if grind_cycle != 1 or move_count != 0 or n_xsteps == 1:
      # Advance x_grid by x_incr
      x_grid = x_grid + x_incr

      # Move to the corresponding position
      local dp2 = p[x_grid * grid_dx_m - x2, y_grid * grid_dy_m - y2, 0, 0, 0, 0]
      grind_movel(dp2, a = grind_accel_mpss, v = grind_speed_mps, t = t_move_x / n_xsteps, r = grind_blend_radius_m)

      # Adjust x direction
      if x_grid >= n_xsteps:
        x_incr = -1
      elif x_grid <= 0:
        x_incr = 1
      end
      move_count = move_count + 1
    end

    if ok_to_proceed() and move_count < n_moves_per_pass:
      # Advance y_grid by y_incr
      y_grid = y_grid + y_incr

      # Move to the corresponding position
      local dp2 = p[x_grid * grid_dx_m - x2, y_grid * grid_dy_m - y2, 0, 0, 0, 0]
      grind_movel(dp2, a = grind_accel_mpss, v = grind_speed_mps, t = t_move_y / n_ysteps, r = grind_blend_radius_m)

      # Adjust y direction
      if y_grid >= n_ysteps:
        y_incr = -1
      elif y_grid <= 0:
        y_incr = 1
      end
      move_count = move_count + 1
    end

    # Detect when we've covered all the grid squares!
    if move_count >= n_moves_per_pass:
      grind_cycle = grind_cycle + 1
      move_count = 0
    end
  end
  grind_movel_finish()
end

# Move along a cylindrical serpentine dx_m,drx_rad in n_xsteps,n_rxsteps centered on p_center. Repeat n_cycles times.
# Move in direction of whichever nsteps is 1 first
def pattern_serpentine_cylinder(p_center, dx_m, drx_rad, n_xsteps, n_rxsteps, n_cycles):
  local t_move_x = dx_m / grind_speed_mps
  local t_move_rx = drx_rad / grind_rot_speed_rps / 4

  # Bottom left corner, grid 0,0
  local x2 = dx_m / 2.0
  local rx2 = drx_rad / 2.0
  local dp1 = p[-x2, 0, 0, -rx2, 0, 0]

  # Track our grid square number... we're in [0,0] and moving [+1,+1] in either x or y
  local x_grid = 0
  local y_grid = 0
  local x_incr = 1
  local y_incr = 1
  local grid_dx_m = dx_m / n_xsteps
  local grid_drx_rad = drx_rad / n_rxsteps

  # How many moves does it take to complete a pass?
  global n_moves_per_pass = (n_xsteps + n_rxsteps) * 2 - 1

  local move_count = 0
  global grind_cycle = 1
  grind_movel_start(p_center, dp1, a = grind_accel_mpss, v = grind_speed_mps)
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    # This will repeat for each leg of the serpentine!
    socket_set_var("grind_cycle", grind_cycle)

    # Skip first X move if we should start with a y move
    if grind_cycle != 1 or move_count != 0 or n_xsteps == 1:
      # Advance x_grid by x_incr
      x_grid = x_grid + x_incr

      # Move to the corresponding position
      local dp2 = p[x_grid * grid_dx_m - x2, 0, 0, y_grid * grid_drx_rad - rx2, 0, 0]
      grind_movel(dp2, a = grind_accel_mpss, v = grind_speed_mps, t = t_move_x / n_xsteps, r = grind_blend_radius_m)

      # Adjust x direction
      if x_grid >= n_xsteps:
        x_incr = -1
      elif x_grid <= 0:
        x_incr = 1
      end
      move_count = move_count + 1
    end

    if ok_to_proceed() and move_count < n_moves_per_pass:
      # Advance y_grid by y_incr
      y_grid = y_grid + y_incr

      # Move to the corresponding position
      local dp2 = p[x_grid * grid_dx_m - x2, 0, 0, y_grid * grid_drx_rad - rx2, 0, 0]
      grind_movel(dp2, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, t = t_move_rx / n_rxsteps, r = grind_rot_blend_radius_rad)

      # Adjust y direction
      if y_grid >= n_rxsteps:
        y_incr = -1
      elif y_grid <= 0:
        y_incr = 1
      end
      move_count = move_count + 1
    end

    # Detect when we've covered all the grid squares!
    if move_count >= n_moves_per_pass:
      grind_cycle = grind_cycle + 1
      move_count = 0
    end
  end
  grind_movel_finish()
end

# Move along a sperical serpentine drx_rad,dry_rad in n_rxsteps,n_rysteps centered on p_center. Repeat n_cycles times.
# Move in direction of whichever nsteps is 1 first
def pattern_serpentine_sphere(p_center, drx_rad, dry_rad, n_rxsteps, n_rysteps, n_cycles):
  local t_move_rx = drx_rad / grind_rot_speed_rps / 4
  local t_move_ry = dry_rad / grind_rot_speed_rps / 4

  # Bottom left corner, grid 0,0
  local rx2 = drx_rad / 2.0
  local ry2 = dry_rad / 2.0
  local dp1 = p[0, 0, 0, -rx2, -ry2, 0]

  # Track our grid square number... we're in [0,0] and moving [+1,+1] in either x or y
  local x_grid = 0
  local y_grid = 0
  local x_incr = 1
  local y_incr = 1
  local grid_drx_rad = drx_rad / n_rxsteps
  local grid_dry_rad = dry_rad / n_rysteps

  # How many moves does it take to complete a pass?
  global n_moves_per_pass = (n_rxsteps + n_rysteps) * 2 - 1

  local move_count = 0
  global grind_cycle = 1
  grind_movel_start(p_center, dp1, a = grind_rot_accel_rpss, v = grind_rot_speed_rps)
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    # This will repeat for each leg of the serpentine!
    socket_set_var("grind_cycle", grind_cycle)

    # Skip first X move if we should start with a y move
    if grind_cycle != 1 or move_count != 0 or n_rxsteps == 1:
      # Advance x_grid by x_incr
      x_grid = x_grid + x_incr

      # Move to the corresponding position
      local dp2 = p[0, 0, 0, x_grid * grid_drx_rad - rx2, y_grid * grid_dry_rad - ry2, 0]
      grind_movel(dp2, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, t = t_move_rx / n_rxsteps, r = grind_rot_blend_radius_rad)

      # Adjust x direction
      if x_grid >= n_rxsteps:
        x_incr = -1
      elif x_grid <= 0:
        x_incr = 1
      end
      move_count = move_count + 1
    end

    if ok_to_proceed() and move_count < n_moves_per_pass:
      # Advance y_grid by y_incr
      y_grid = y_grid + y_incr

      # Move to the corresponding position
      local dp2 = p[0, 0, 0, x_grid * grid_drx_rad - rx2, y_grid * grid_dry_rad - ry2, 0]
      grind_movel(dp2, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, t = t_move_ry / n_rysteps, r = grind_rot_blend_radius_rad)

      # Adjust y direction
      if y_grid >= n_rysteps:
        y_incr = -1
      elif y_grid <= 0:
        y_incr = 1
      end
      move_count = move_count + 1
    end

    # Detect when we've covered all the grid squares!
    if move_count >= n_moves_per_pass:
      grind_cycle = grind_cycle + 1
      move_count = 0
    end
  end
  grind_movel_finish()
end


######################################################################################
# CIRCULAR PATTERNS
#

# What is a good number of points to use for a circular pattern?
def recommend_npoints(diam_m, blend_radius_m):
  circum_m = diam_m * MATH_PI
  if blend_radius_m > 0:
    # How many blend_radii to cover the circumference
    n_points = ceil(circum_m / blend_radius_m)
  else:
    # Blend radius is 0... model would be 10 points for a 10mm diameter (1000 points for 1m diameter!)
    n_points = ceil(diam_m * 1000.0)
  end
  return limiter(n_points, 1, 1000)
end

# Grind along a flat circle circle_diam_m centered on p_center. Repeat n_cycles times.
def pattern_circle_flat(p_center, circle_diam_m, n_cycles):

  # Local calculations
  n_points = recommend_npoints(circle_diam_m, grind_blend_radius_m)
  circle_radius_m = circle_diam_m / 2.0

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    i = 0
    while ok_to_proceed() and i <= n_points:
      theta = d2r(180.0 + 360.0 * i / n_points)
      x = circle_radius_m * cos(theta)
      y = circle_radius_m * sin(theta)

      p1 = pose_trans(p_center, p[x, y, 0, 0, 0, 0])
      if i == n_points or not ok_to_proceed():
        local br = 0
      else:
        local br = grind_blend_radius_m
      end
      movel(p1, a = grind_accel_mpss, v = grind_speed_mps, r = br)
      i = i + 1
    end

    grind_cycle = grind_cycle + 1
  end
  pattern_complete()
end

# Move along a cylindrical circle circle_diam_m on a cylinder_diam_m object starting at the current tool position. Repeat n_cycles times.
def pattern_circle_cylinder(p_center, circle_diam_m, cylinder_radius_m, n_cycles):

  # Local calculations
  n_points = recommend_npoints(circle_diam_m, grind_blend_radius_m)
  circle_radius_m = circle_diam_m / 2.0
  speed_factor = 0.5 / (robot_part_geometry[1] / 1000.0)

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    i = 0
    while ok_to_proceed() and i <= n_points:
      theta = d2r(180.0 + 360.0 * i / n_points)
      x = circle_radius_m * cos(theta)
      y = circle_radius_m * sin(theta)
      rx = 2.0 * y / cylinder_radius_m

      p1 = pose_trans(p_center, p[x, 0, 0, rx, 0, 0])
      # Speed_factor needs to be applied when running radially, and needs to be 1.0 when running laterally. This smooths it all the way around!
      global this_speed_factor = (speed_factor - 1) * abs(cos(theta)) + 1.0
      if i == n_points or not ok_to_proceed():
        local br = 0
      else:
        local br = grind_blend_radius_m
      end
      movel(p1, a = grind_accel_mpss * this_speed_factor, v = grind_speed_mps * this_speed_factor, r = br)
      i = i + 1
    end

    grind_cycle = grind_cycle + 1
  end
  pattern_complete()
end

# Move along a spherical circle circle_diam_m on a sphere_diam_m object starting at the current tool position. Repeat n_cycles times.
def pattern_circle_sphere(p_center, circle_diam_m, sphere_diam_m, n_cycles):
  # Local calculations
  n_points = recommend_npoints(circle_diam_m, grind_blend_radius_m)
  circle_radius_m = circle_diam_m / 2.0
  sphere_radius_m = sphere_diam_m / 2.0

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    i = 0
    while ok_to_proceed() and i <= n_points:
      theta = d2r(180.0 + 360.0 * i / n_points)
      x = circle_radius_m * cos(theta)
      rx = x / sphere_radius_m
      y = circle_radius_m * sin(theta)
      ry = y / sphere_radius_m

      p1 = pose_trans(p_center, p[0, 0, 0, rx, ry, 0])
      if i == n_points or not ok_to_proceed():
        local br = 0
      else:
        local br = grind_rot_blend_radius_rad
      end
      movel(p1, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, r = br)
      i = i + 1
    end

    grind_cycle = grind_cycle + 1
  end
  pattern_complete()
end


######################################################################################
# SPIRAL PATTERNS
#

def pattern_spiral_flat(p_center, circle1_diam_m, circle2_diam_m, n_spirals, n_cycles):
  # Local calculations
  max_diam_m = max(circle1_diam_m, circle2_diam_m)
  n_points = recommend_npoints(max_diam_m, grind_blend_radius_m)
  n_total_points = n_spirals * n_points
  circle1_radius_m = circle1_diam_m / 2.0
  circle2_radius_m = circle2_diam_m / 2.0

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    rslope = (circle2_radius_m - circle1_radius_m) / n_total_points
    i = 0
    while ok_to_proceed() and i <= n_total_points:
      theta = d2r(180.0 + 360.0 * (i % n_points) / n_points)
      r_instantaneous = i * rslope + circle1_radius_m
      x = r_instantaneous * cos(theta)
      y = r_instantaneous * sin(theta)

      p1 = pose_trans(p_center, p[x, y, 0, 0, 0, 0])
      if i == n_total_points or not ok_to_proceed():
        local br = 0
      else:
        local br = grind_blend_radius_m
      end
      movel(p1, a = grind_accel_mpss, v = grind_speed_mps, r = br)
      i = i + 1
    end

    grind_cycle = grind_cycle + 1
    # Next cycle- swap diameters so we go in/out/in etc.
    old_circle1_radius_m = circle1_radius_m
    circle1_radius_m = circle2_radius_m
    circle2_radius_m = old_circle1_radius_m
  end
  pattern_complete()
end

def pattern_spiral_cylinder(p_center, circle1_diam_m, circle2_diam_m, n_spirals, cylinder_radius_m, n_cycles):
  # Local calculations
  max_diam_m = max(circle1_diam_m, circle2_diam_m)
  n_points = recommend_npoints(max_diam_m, grind_blend_radius_m)
  n_total_points = n_spirals * n_points
  circle1_radius_m = circle1_diam_m / 2.0
  circle2_radius_m = circle2_diam_m / 2.0
  speed_factor = 0.5 / (robot_part_geometry[1] / 1000.0)

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    rslope = (circle2_radius_m - circle1_radius_m) / n_total_points
    i = 0
    while ok_to_proceed() and i <= n_total_points:
      theta = d2r(180.0 + 360.0 * (i % n_points) / n_points)
      r_instantaneous = i * rslope + circle1_radius_m
      x = r_instantaneous * cos(theta)
      y = r_instantaneous * sin(theta)
      rx = 2.0 * y / cylinder_radius_m

      p1 = pose_trans(p_center, p[x, 0, 0, rx, 0, 0])

      # Speed_factor needs to be applied when running radially, and needs to be 1.0 when running laterally. This smooths it all the way around!
      global this_speed_factor = (speed_factor - 1) * abs(cos(theta)) + 1.0
      if i == n_total_points or not ok_to_proceed():
        local br = 0
      else:
        local br = grind_blend_radius_m
      end
      movel(p1, a = grind_accel_mpss * this_speed_factor, v = grind_speed_mps * this_speed_factor, r = br)
      i = i + 1
    end

    grind_cycle = grind_cycle + 1
    # Next cycle- swap diameters so we go in/out/in etc.
    old_circle1_radius_m = circle1_radius_m
    circle1_radius_m = circle2_radius_m
    circle2_radius_m = old_circle1_radius_m
  end
  pattern_complete()
end

def pattern_spiral_sphere(p_center, circle1_diam_m, circle2_diam_m, n_spirals, sphere_diam_m, n_cycles):
  # Local calculations
  max_diam_m = max(circle1_diam_m, circle2_diam_m)
  n_points = recommend_npoints(max_diam_m, grind_blend_radius_m)
  n_total_points = n_spirals * n_points
  circle1_radius_m = circle1_diam_m / 2.0
  circle2_radius_m = circle2_diam_m / 2.0
  sphere_radius_m = sphere_diam_m / 2.0

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    rslope = (circle2_radius_m - circle1_radius_m) / n_total_points
    i = 0
    while ok_to_proceed() and i <= n_total_points:
      theta = d2r(180.0 + 360.0 * (i % n_points) / n_points)
      r_instantaneous = i * rslope + circle1_radius_m
      x = r_instantaneous * cos(theta)
      rx = x / sphere_radius_m
      y = r_instantaneous * sin(theta)
      ry = y / sphere_radius_m

      p1 = pose_trans(p_center, p[0, 0, 0, rx, ry, 0])
      if i == n_total_points or not ok_to_proceed():
        local br = 0
      else:
        local br = grind_rot_blend_radius_rad
      end
      movel(p1, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, r = br)
      i = i + 1
    end

    grind_cycle = grind_cycle + 1
    # Next cycle- swap diameters so we go in/out/in etc.
    old_circle1_radius_m = circle1_radius_m
    circle1_radius_m = circle2_radius_m
    circle2_radius_m = old_circle1_radius_m
  end
  pattern_complete()
end