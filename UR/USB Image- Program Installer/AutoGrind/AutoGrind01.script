def AutoGrind01():
  set_gravity([0.0, 0.0, 9.82])
  set_standard_analog_input_domain(0, 1)
  set_standard_analog_input_domain(1, 1)
  set_tool_analog_input_domain(0, 1)
  set_tool_analog_input_domain(1, 1)
  set_analog_outputdomain(0, 1)
  set_analog_outputdomain(1, 1)
  set_input_actions_to_default()
  set_standard_digital_input_action(7, "freedrive")
  set_runstate_standard_digital_output_to_value(1, 5)
  set_safety_mode_transition_hardness(1)
  set_tcp(p[0.0,-0.2,0.05,0.0,2.221441469079183,-2.221441469079183])
  step_count_d168a517_5913_465e_a9e6_db3ec59335fb = 0.0
  thread Step_Counter_Thread_37651b9b_038e_4e7c_a928_a3449be30df5():
    while (True):
      step_count_d168a517_5913_465e_a9e6_db3ec59335fb = step_count_d168a517_5913_465e_a9e6_db3ec59335fb + 1.0
      sync()
    end
  end
  run Step_Counter_Thread_37651b9b_038e_4e7c_a928_a3449be30df5()
  set_tool_communication(False, 115200, 0, 1, 1.5, 3.5)
  set_tool_output_mode(0)
  set_tool_digital_output_mode(0, 1)
  set_tool_digital_output_mode(1, 1)
  set_tool_voltage(0)
  set_target_payload(0.650000, [0.009000, 0.054000, 0.034000], [0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000])
  global Vertical_3_p=p[.138885408770, -.597734994115, .345465728645, .020328607375, .009472346729, .004936256276]
  global Vertical_3_q=[1.5825845003128052, -1.3035788101008912, 1.3692634741412562, -1.6159240208067835, -1.5805562178241175, 3.148454189300537]
  global Tilted_1_p=p[.138883686744, -.597728142783, .345429622193, -.448043800451, .010443563975, .002601926233]
  global Tilted_1_q=[1.5845965147018433, -1.4651393455317994, 1.7312191168414515, -2.2846466503539027, -1.5859773794757288, 3.1494011878967285]
  global Vertical_4_p=p[.138907887118, -.597724961045, .477595501516, .000033070909, -.000020568314, .002680866690]
  global Vertical_4_q=[1.5797940492630005, -1.280219630604126, 1.0041268507586878, -1.2945302587798615, -1.5720770994769495, 3.1477832794189453]
  global Vertical_6_p=p[.138875969234, -.597730539026, .130475163479, .000006847317, .000017170136, .002581409666]
  global Vertical_6_q=[1.5792073011398315, -1.1477825206569214, 1.743450943623678, -2.1663156948485316, -1.570512596760885, 3.1478190422058105]
  def AG_50():
    $ 75 "AG_50" "noBreak"
    $ 76 "MoveL"
    $ 77 "Vertical_3" "breakAfter"
    movel(Vertical_3_p, a=1.2, v=0.25)
    $ 78 "Tilted_1" "breakAfter"
    movel(Tilted_1_p, a=1.2, v=0.25)
    $ 79 "Vertical_4" "breakAfter"
    movel(Vertical_4_p, a=1.2, v=0.25)
    $ 80 "Vertical_6" "breakAfter"
    movel(Vertical_6_p, a=1.2, v=0.25)
  end
  $ 1 "BeforeStart"
  $ 2 "Script: agscript_util.script"
  # File: agscript_grind.cs
  # Project: AutoGrind
  # Author: Ned Lecky, Olympus Controls
  # Purpose: General utility function used in AutoGrind
  
  # Return max of 2 numeric values
  def max(n1, n2):
    if n1 > n2:
      return n1
    else:
      return n2
    end
  end
  
  # Return min of 2 numeric values
  def min(n1, n2):
    if n1 < n2:
      return n1
    else:
      return n2
    end
  end
  
  # Return absolute value of a numeric value
  def abs(n):
    if n < 0:
      return -n
    else:
      return n
    end
  end
  
  # Return param limited to lowLim <= param <= hiLim
  def limiter(param, loLim, hiLim):
    if param < loLim:
      return loLim
    elif param > hiLim:
      return hiLim
    else:
      return param
    end
  end
  
  # Send LF out the socket
  def socket_send_lf():
    socket_send_byte(10)
  end
  
  # Send n-vectors back to socket as [n,n,n,n,n,n]
  def return_vector(p, n = 6):
    socket_send_string("[")
    i = 0
    while i < n:
      if i > 0:
        socket_send_string(",")
      end
      socket_send_string(p[i])
      i = i + 1
    end
    socket_send_string("]")
  end
  
  # Send 6-element position back to socket as:
  #   (isPose=False)  name=[n,n,n,n,n,n]
  #   (isPose=True)   name=p[n,n,n,n,n,n]
  def return_position(name, isPose, p):
    socket_send_string(name)
    socket_send_string("=")
    if isPose == True:
      socket_send_string("p")
    end
    return_vector(p, 6)
    socket_send_lf()
  end
  
  # Return a 6-element vector to socket as a pose name=p[.....]
  def return_pose(name, p):
    return_position(name, True, p)
  end
  
  # Return a 6-element vector to socket as joint angles name=[.....]
  def return_joints(name, p):
    return_position(name, False, p)
  end
  
  # Special support to receive 1-4 port,value pairs and always pad with -1s to make 4 pairs
  # Essentialy returns command[3:end] padded out with -1s to always be 8 elements
  # Assumes length of command is specified in command[0]
  def command_3_padded_8(command):
    ret8 = [-1, -1, -1, -1, -1, -1, -1, -1]
    i = 0
    while i < command[0]-2:
      ret8[i] = command[i + 3]
      i = i + 1
    end
    return ret8
  end
  $ 3 "Script: agscript_robot.script"
  # File: agscript_robot.cs
  # Project: AutoGrind
  # Author: Ned Lecky, Olympus Controls
  # Purpose: Robot control commands supporting the AutoGrind application
  
  global response = "unknown"
  global robot_index = 0
  global robot_checkvalue = 0
  
  global robot_linear_speed_mps = 0.2
  global robot_linear_accel_mpss = 0.4
  global robot_blend_radius_m = 0.003
  global robot_joint_speed_rps = 1.0
  global robot_joint_accel_rpss = 4.0
  global robot_tcp = p[0, 0, 0.175, 0, 0, 0]
  global robot_tcp_part = robot_tcp
  global robot_payload_mass_kg = 1.0
  global robot_payload_cog_m = [0, 0, 0.50]
  # Geometry [1=FLAT 2=CYL 3=SPHERE, diameter_mm)
  global robot_part_geometry = [0, 0]
  global robot_door_closed_input = [-1, -1]
  global robot_tool_on_outputs = [-1, -1, -1, -1, -1, -1, -1, -1]
  global robot_tool_off_outputs = [-1, -1, -1, -1, -1, -1, -1, -1]
  global robot_coolant_on_outputs = [-1, -1, -1, -1, -1, -1, -1, -1]
  global robot_coolant_off_outputs = [-1, -1, -1, -1, -1, -1, -1, -1]
  global robot_freedrive_mode = 0
  
  # Defaults get set on load... and can be queried (or changed) from C#
  set_tcp(robot_tcp)
  set_payload(robot_payload_mass_kg, robot_payload_cog_m)
  set_gravity([0.0, 0.0, 9.82])
  
  # command should be[nElements,index,checkval,param[0],param[1],...]
  # put index into robot_index
  # validate checkval
  # Remove both from command so we get command = [nElements-2, param[0], param[1],...]
  def command_validate():
    # must be at least index, check, and 1 param
    if command[0] < 3:
      command[0] = 0
      return False
    end
  
    # Now make sure checksum matches what we expect
    global test_index = command[1]
    global test_checksum = command[2]
    if test_checksum != 1000 - test_index:
      command[0] = 0
      return False
    end
  
    # Now if we are still in the grind state and we are not getting a grind command (40) make sure we're are off the part!
    if grind_process_state and command[3] != 40:
      # Using set_grind_process_state which assumes robot_tcp_part!
      set_tcp(robot_tcp_part)
      set_grind_process_state(False)
      set_tcp(robot_tcp)
    end
  
    # Slide the robot commands and parameters back in command[] to remove the index and checksum
    local i = 3
    while (i < command[0] + 1):
      command[i-2] = command[i]
      i = i + 1
    end
    command[i-1] = 0
    command[i-2] = 0
    command[0] = command[0] - 2    # 2 fewer elements in the array now!
  
    global robot_index = test_index
    return True
  end
  
  # Call this when starting command execution
  def command_start():
    global last_comand = command
  
    # This one signifies we're starting a new command!
    global robot_starting = robot_index
    socket_set_var("robot_starting", robot_starting)
    socket_send_line("robot_ready=False")
  end
  
  # Call this when a command is complete
  def command_finish():
    local retval = "robot_response=" + response + "#robot_ready=True"
    socket_send_line(retval)
  
    global robot_completed = robot_index
    socket_set_var("robot_completed", robot_completed)
  end
  
  # Set variable interface. Interprets command[2] to select what to set and returns result to socket
  # Can also be used for validation and enforcing limits
  def set_variable():
    if command[2] == 1:
      # Set speed to s if s>0. Always returns current value
      s = command[3]
      if s > 0:
        robot_linear_speed_mps = s / 1000.0
      end
      socket_set_var("robot_linear_speed_mmps", robot_linear_speed_mps * 1000.0)
      global response = "set_linear_speed()"
    elif command[2] == 2:
      # Set accel to a if a>0. Always returns current value
      a = command[3]
      if a > 0:
        robot_linear_accel_mpss = a / 1000.0
      end
      socket_set_var("robot_linear_accel_mmpss", robot_linear_accel_mpss * 1000.0)
      global response = "set_linear_accel()"
    elif command[2] == 3:
      # Set blend to b if b>=0. Always returns current value
      b = command[3]
      if b >= 0:
        robot_blend_radius_m = b / 1000.0
      end
      socket_set_var("robot_blend_radius_mm", robot_blend_radius_m * 1000.0)
      global response = "set_blend_radius()"
    elif command[2] == 4:
      # Set joint speed to s if s>0. Always returns current value
      s = command[3]
      if s > 0:
        robot_joint_speed_rps = d2r(s)
      end
      socket_set_var("robot_joint_speed_dps", r2d(robot_joint_speed_rps))
      global response = "set_joint_speed()"
    elif command[2] == 5:
      # Set joint accel to a if a>0. Always returns current value
      a = command[3]
      if a > 0:
        robot_joint_accel_rpss = d2r(a)
      end
      socket_set_var("robot_joint_accel_dpss", r2d(robot_joint_accel_rpss))
      global response = "set_joint_accel()"
    elif command[2] == 6:
      # Set part_geometry to [shape, diameter_mm] if shape==1,2,3. Always returns "robot_part_geometry=[current geometry]"
      # Also updates robot_part_tcp using update_robot_tcp_part
      shape = command[3]
      if shape == 1:
        robot_part_geometry = [1, 0]
      elif shape == 2 or shape == 3:
        diameter_mm = limiter(command[4], 50, 1100)
        robot_part_geometry = [shape, diameter_mm]
      end
  
      update_robot_tcp_part()
  
      socket_send_string("robot_part_geometry=")
      return_vector(robot_part_geometry, 2)
      socket_send_lf()
      global response = "set_part_geometry()"
    elif command[2] == 10:
      # Set door closed IO
      if command[3] >= 0:
        robot_door_closed_input[0] = command[3]
        robot_door_closed_input[1] = command[4]
      end
  
      socket_send_string("robot_door_closed_input=")
      return_vector(robot_door_closed_input, 2)
      socket_send_lf()
      socket_set_var("robot_door_closed", is_door_closed())
      global response = "set_door_closed_input()"
    elif command[2] == 11:
      # Set tool on Output
      robot_tool_on_outputs = command_3_padded_8(command)
  
      socket_send_string("robot_tool_on_outputs=")
      return_vector(robot_tool_on_outputs, 8)
      socket_send_lf()
      global response = "set_tool_on_outputs()"
    elif command[2] == 12:
      # Set tool off Output
      robot_tool_off_outputs = command_3_padded_8(command)
  
      socket_send_string("robot_tool_off_outputs=")
      return_vector(robot_tool_off_outputs, 8)
      socket_send_lf()
      global response = "set_tool_off_outputs()"
    elif command[2] == 13:
      # Set coolant on Output
      robot_coolant_on_outputs = command_3_padded_8(command)
  
      socket_send_string("robot_coolant_on_outputs=")
      return_vector(robot_coolant_on_outputs, 8)
      socket_send_lf()
      global response = "set_coolant_on_outputs()"
    elif command[2] == 14:
      # Set coolant off Output
      robot_coolant_off_outputs = command_3_padded_8(command)
  
      socket_send_string("robot_coolant_off_outputs=")
      return_vector(robot_coolant_off_outputs, 8)
      socket_send_lf()
      global response = "set_coolant_off_outputs()"
    elif command[2] == 15:
      # tool_on
      tool_power(True, grind_contact_enable)
      global response = "tool_on()"
    elif command[2] == 16:
      # tool_off
      tool_power(False, grind_contact_enable)
      global response = "tool_off()"
    elif command[2] == 17:
      # coolant_on
      coolant_flow(True, grind_contact_enable)
      global response = "coolant_on()"
    elif command[2] == 18:
      # coolant_off
      coolant_flow(False, grind_contact_enable)
      global response = "coolant_off()"
    elif command[2] == 19:
      # freedrive 1=on/0=off, 0=base|1=tcp|2=tcp_part, 6 axisEnables
      if command[3] == 0:
        end_freedrive_mode()
        set_tcp(robot_tcp)
        robot_freedrive_mode = 0
        socket_set_var("robot_freedrive_mode", robot_freedrive_mode)
      else:
        local coordSys = command[4]
        local freeAxes = [command[5], command[6], command[7], command[8], command[9], command[10]]
        if coordSys == 1:
          set_tcp(robot_tcp)
          freedrive_mode(freeAxes = freeAxes, feature = "tool")
        elif coordSys == 2:
          set_tcp(robot_tcp_part)
          freedrive_mode(freeAxes = freeAxes, feature = "tool")
        else:
          # Base
          freedrive_mode(freeAxes = freeAxes)
        end
        robot_freedrive_mode = 1
        socket_set_var("robot_freedrive_mode", robot_freedrive_mode)
      end
      global response = "freedrive_mode()"
    elif command[2] == 20:
      # set_tcp if command[3] > -10. Always returns robot_tcp=p[...]
      if command[3] > -10:
        robot_tcp = p[command[3], command[4], command[5], command[6], command[7], command[8]]
        set_tcp(robot_tcp)
      end
      return_pose("robot_tcp", get_tcp_offset())
      # Recompute robot_tcp_part based on current geometry
      update_robot_tcp_part()
      global response = "set_tcp()"
    elif command[2] == 21:
      # set_payload if command[3] > 0. Always return robot_m and robot_cog
      if command[3] > 0:
        robot_payload_mass_kg = command[3]
        robot_payload_cog_m = [command[4], command[5], command[6]]
        set_payload(robot_payload_mass_kg, robot_payload_cog_m)
      end
      socket_set_var("robot_payload_mass_kg", robot_payload_mass_kg)
      socket_send_string("robot_payload_cog_m=")
      return_vector(robot_payload_cog_m, 3)
      socket_send_lf()
      global response = "set_payload()"
    else:
      global response = "set_variable ERROR"
    end
  end
  
  # Compute appropriate robot_tcp for the part based on robot_tcp and robot_part_geometry
  # They're the same for flat parts, but the TCP is adjusted to the center of the cylinder or sphere
  def update_robot_tcp_part():
    shape = robot_part_geometry[0]
    if shape == 1:  # Flat
      robot_tcp_part = robot_tcp
    else:  # Cylinder or Sphere
      robot_tcp_part = pose_trans(robot_tcp, p[0, 0, robot_part_geometry[1] / 2000.0, 0, 0, 0])
    end
    return_pose("robot_tcp_part", robot_tcp_part)
  end
  
  # Send get_tcp_offset() result to socket
  def return_tcp_offset():
    p = get_tcp_offset()
    return_pose("tcp_offset", p)
    global response = "return_tcp_offset()"
  end
  
  # Send get_actual_tcp_pose() to socket
  def return_actual_tcp_pose():
    p = get_actual_tcp_pose()
    return_pose("actual_tcp_pose", p)
    global response = "return_actual_tcp_pose()"
  end
  
  # Send get_actual_joint_positions() to socket
  def return_get_actual_joint_positions():
    p = get_actual_joint_positions()
    return_joints("actual_joint_positions", p)
    global response = "return_get_actual_joint_positions()"
  end
  
  # Send both joints and pose to socket labeled position_p and position_q
  def return_both_positions():
    return_joints("position_q", get_actual_joint_positions())
    return_pose("position_p", get_actual_tcp_pose())
    global response = "return_both_positions()"
  end
  
  # Movel relatively in base coordinates
  def movel_relative_base(p1):
    local p0 = get_actual_tcp_pose()
    local p2 = pose_add(p0, p1)
    if p1[0] == 0 and p1[1] == 0 and p1[2] == 0:  # Rotational move
      movel(p2, robot_joint_accel_rpss, robot_joint_speed_rps)
    else:
      movel(p2, robot_linear_accel_mpss, robot_linear_speed_mps)
    end
    global response = "movel_relative_base()"
  end
  
  # Movel relatively in TCP coordinates
  def movel_relative_tcp(p1):
    local p2 = pose_trans(get_forward_kin(), p1)
    if p1[0] == 0 and p1[1] == 0 and p1[2] == 0:  # Rotational move
      movel(p2, robot_joint_accel_rpss, robot_joint_speed_rps)
    else:
      movel(p2, robot_linear_accel_mpss, robot_linear_speed_mps)
    end
    global response = "movel_relative_tcp()"
  end
  
  # Movel relatively in TCP_part coordinates
  def movel_relative_tcp_part(p1):
    set_tcp(robot_tcp_part)
    local p2 = pose_trans(get_forward_kin(), p1)
    if p1[0] == 0 and p1[1] == 0 and p1[2] == 0:  # Rotational move
      movel(p2, robot_joint_accel_rpss, robot_joint_speed_rps)
    else:
      movel(p2, robot_linear_accel_mpss, robot_linear_speed_mps)
    end
    set_tcp(robot_tcp)
    global response = "movel_relative_tcp_part()"
  end
  
  # Change one element of current pose and movel there
  def movel_one_only(index = 0, val = 0):
    local p = get_actual_tcp_pose()
    p[index] = val
    if index < 3:  # Translational
      movel(p, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
    else:
      movel(p, a = robot_joint_accel_rpss, v = robot_joint_speed_rps)
    end
    global response = "movel_one_only()"
  end
  
  # Change only rotation elements of current pose and movel there
  def movel_rot_only(r1 = 0, r2 = 0, r3 = 0):
    local p = get_actual_tcp_pose()
    p[3] = r1
    p[4] = r2
    p[5] = r3
    movel(p, a = robot_joint_accel_rpss, v = robot_joint_speed_rps)
    global response = "movel_rot_only()"
  end
  
  # Movej to position (works with joints or poses)
  def movej_ag(p):
    movej(p, a = robot_joint_accel_rpss, v = robot_joint_speed_rps)
    global response = "movej_ag()"
  end
  
  # Movel to position (works with joints or poses)
  def movel_ag(p):
    movel(p, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
    global response = "movel_ag()"
  end
  
  # ####################################################################################
  # Interrupting Motion
  # Motion and force_mode and part contact muct all end if any of 3 things happen
  #  1) Door is opened
  #  2) We're in contact with the part and grinding, but no grind command comes within some time (default 1.5s)
  #  3) We receive an abort message from the host
  #
  # How is it implemented?
  #
  # 1) door_monitor_thread (below) is ALWAYS running. Fires every time_door_check_rate_s (0.25s)
  #    - Whenever it sees the state of the door change, it sends SET robot_door_closed state to host
  #    - It monitors if we're still in contact wth the part butr not grinding (grind_process_state and grind_ready)
  #      - If that goes beyond grind_max_wait_ms it sets halt_grind=True
  # 2) no_command function (below). Called by PolScript everyu time it's waiting for a command and doesn't get one with a second
  #    - If halt_grind is set (by door monitor thread above)
  #      - stopl and simulate receiving a grind_retract
  #      - THIS FORCES THE force_off and motion commands to come from the primary thread, as they must
  # 3) listener_thread started by grind()
  #    - This runs only while a grind is in progress
  #    - It listens for commands from the host since PolyScope is blocked
  #    - Any command received increments halt_count which makes ok_to_proceed() false
  #    - That is checked in all the grinding programs and forces them to finish up and get off the part in an orderly fashion
  
  # ####################################################################################
  # START AUTOMATED DOOR MONITORING THREAD
  #
  # Return True if door in closed state (or if door I/IO is undefined)
  def is_door_closed():
    if robot_door_closed_input[0] < 0:
      return True
    end
    if get_standard_digital_in(robot_door_closed_input[0]):
      f = 1
    else:
      f = 0
    end
    return f == robot_door_closed_input[1]
  end
  
  global robot_door_closed = is_door_closed()
  global time_in_uncommanded_grind = 0
  global time_door_check_rate_s = 0.250
  global grind_max_wait_ms = 1500
  thread door_monitor_thread():
    while True:
      sleep(time_door_check_rate_s)
      new_door_closed = is_door_closed()
  
      # Notify host if door state has changed
      if robot_door_closed != new_door_closed:
        robot_door_closed = new_door_closed
        socket_set_var("robot_door_closed", robot_door_closed)
      end
  
      # Check for still in grind process but not executing a grind command
      # This is what happens after a grind_...(....,1) executes while waiting for next command
      if grind_process_state and grind_ready:
        time_in_uncommanded_grind = time_in_uncommanded_grind + time_door_check_rate_s
        # No new grind commands for grind_max_wait_ms... schedule a grind_retract!
        if time_in_uncommanded_grind > grind_max_wait_ms / 1000.0:
          global halt_grind = True
        end
      else:
        time_in_uncommanded_grind = 0
      end
    end
  end
  global doorMonitorThread = run door_monitor_thread()
  #
  # END AUTOMATED DOOR MONITORING THREAD
  # ####################################################################################
  
  # ####################################################################################
  # START NO_COMMAND HOUSEKEEPING
  # This gets called when the PolyScope receives no command (about 1/second)
  # We can fire off any command here safely since no others will be seen until we exit
  #
  global no_command_count = 0
  global halt_grind = False
  def no_command():
    global no_command_count = no_command_count + 1
  
    if grind_process_state and grind_ready and halt_grind:
      halt_grind = False
      stopl(20)
  
      set_tcp(robot_tcp_part)
      set_grind_process_state(False)
      set_tcp(robot_tcp)
    end
  end
  #
  # END NO_COMMAND HOUSEKEEPING
  # ####################################################################################
  
  ######################################################################################
  # movel_int  Segmented (interruptable) movel
  #
  global grind_distance_m = 0
  def movel_int(p, a = 1.2, v = 0.25, t = 0, r = 0, t_move = 1):
    local p0 = get_target_tcp_pose()
    # Chugging on CYL 80 lines and rects at 4Hz
    # Generate 10 points per second
    global grind_n_segments = limiter(ceil(t_move * 10.0), 1, 1000)
  
    i = 1
    while i <= grind_n_segments and ok_to_proceed():
      local p1 = interpolate_pose(p0, p, i / grind_n_segments)
      movel(p1, a = a, v = v, r = r)
      i = i + 1
    end
    return None
  end
  #
  # Movel_int  Segmented (interruptable) movel
  ######################################################################################
  
  # ####################################################################################
  # START TOUCHOFF HANDLER
  #
  def calculate_point_to_move_towards(feature, direction, position_distance):
    local posDir = [direction[0], direction[1], direction[2]]
    if (norm(posDir) < 1e-6):
      return get_target_waypoint()
    end
    local direction_vector_normalized = normalize(posDir)
    local displacement_pose = p[direction_vector_normalized[0] * position_distance, direction_vector_normalized[1] * position_distance, direction_vector_normalized[2] * position_distance, 0, 0, 0]
    local wanted_displacement_in_base_frame = pose_sub(pose_trans(feature, displacement_pose), feature)
    return pose_add(get_target_waypoint(), wanted_displacement_in_base_frame)
  end
  #$ 7 "Robot Program"
  #$ 8 "MoveL"
  #$ 9 "Direction: Tool Z+"
  global move_thread_flag = 0
  global move_thread_approach_speed_mps = 0.01
  thread move_thread():
    enter_critical
    move_thread_flag = 1
    local towardsPos = calculate_point_to_move_towards(get_forward_kin(), [0.0, 0.0, 1.0], 0.025)
    movel(towardsPos, a = 0.5, v = move_thread_approach_speed_mps)
    move_thread_flag = 2
    exit_critical
  end
  # Currently using speed_mmps for both approach and 2X for departure
  def touchoff(approach_speed_mmps, retract_mm):
    approach_speed_mps = approach_speed_mmps / 1000.0
    global move_thread_approach_speed_mps = approach_speed_mps
  
    retract_speed_mps = approach_speed_mps * 2.0
  
    retract_m = retract_mm / 1000.0
  
    move_thread_flag = 0
    move_thread_han = run move_thread()
    while (True):
      local targetTcpDirection = get_target_tcp_speed()
      local stepsToRetract = tool_contact(direction = targetTcpDirection)
      if (stepsToRetract > 0):
        kill move_thread_han
        stopl(20)
        local backTrackMovement = get_actual_joint_positions_history(stepsToRetract)
        local contactPose = get_forward_kin(backTrackMovement)
        local posDir = [targetTcpDirection[0], targetTcpDirection[1], targetTcpDirection[2]]
        local retractTo = contactPose
        if (norm(posDir) > 1e-6):
          local normalizedPosDir = normalize(posDir)
          local additionalRetraction = p[normalizedPosDir[0] * retract_m, normalizedPosDir[1] * retract_m, normalizedPosDir[2] * retract_m, 0, 0, 0]
          retractTo = pose_sub(contactPose, additionalRetraction)
        end
        movel(retractTo, a = 1.0, v = retract_speed_mps)
        #$ 10 "Until (tool_contact_detection)"
        return True
        break
      end
      sleep(1.0E-10)
      if (move_thread_flag > 1):
        join move_thread_han
        #$ 11 "Until (distance)"
        #$ 12 "Popup: No part encountered"
        #popup("No part encountered", "Message", False, False, blocking = True)
        return False
        break
      end
      sync()
    end
    return False
  end
  #
  # END TOUCHOFF HANDLER
  # ####################################################################################
  $ 4 "Script: agscript_grind.script"
  # File: agscript_grind.cs
  # Project: AutoGrind
  # Author: Ned Lecky, Olympus Controls
  # Purpose: All grinding functions used in AutoGrind
  
  global grind_abort_listener_thread_handle = 0
  global pattern_grind_thread_handle = 0
  
  global halt_count = 0
  global halt_command = [0, 0, 0, 0]
  
  global grind_ready = True
  # grind_contact_enable:  0=No Contact   1=Touch but no tool/coolant on or force  2=Touch, Tool, Coolant, and Force
  global grind_contact_enable = 0
  global grind_touch_retract_mm = 3       # How far to retract after touch  (we do 2X this for ghrind_contact_enable=1)
  global grind_touch_speed_mmps = 0.1     # How fast to go in for the touch
  global grind_force_dwell_ms = 500       # How long to dwell after turning force more on
  global grind_blend_radius_m = 0.001     # Blend radius to use while grinding
  global grind_trial_speed_mmps = 20      # Grinding speed when not really grinding!
  global grind_accel_mmpss = 100          # Acceleration to use in grinding moves
  
  # Planning points
  global p_operator_init = p[0, 0, 0, 0, 0, 0]    # Where we were when operator issued first grind command
  global p_contact_init = p[0, 0, 0, 0, 0, 0]     # Where we first contacted the part
  global p_contact_center = p[0, 0, 0, 0, 0, 0]   # Computed where center of pattern would be in contact with part
  
  MATH_PI = 3.1415926535
  
  # Set global grind_n_cycles based on whether we really going to grind
  def n_cycle_setter(n_cycles):
    if grind_contact_enable == 2:
      global grind_n_cycles = n_cycles
    else:
      global grind_n_cycles = limiter(n_cycles, 0, 1)
    end
    socket_set_var("grind_n_cycles", grind_n_cycles)
  end
  
  # Set all speed and acceleration globals based on part geometry and whether we really going to grind
  def speed_setter(speed_mmps):
    if grind_contact_enable == 2:
      global grind_speed_mps = speed_mmps / 1000.0
    else:
      global grind_speed_mps = grind_trial_speed_mmps / 1000.0
    end
    global grind_accel_mpss = grind_accel_mmpss / 1000.0
  
    # Default rotational speeds same as linear
    global grind_rot_speed_rps = grind_speed_mps
    global grind_rot_accel_rpss = grind_accel_mpss
    global grind_rot_blend_radius_rad = grind_blend_radius_m
  
    # If part is cylinder or spherical, diameter will be >0
    diam_m = robot_part_geometry[1] / 1000.0
    if diam_m > 0.0:
      # These are 1/4 the theoretical rotational speeds but we need to set them like this to get the correct speed- why??????
      global grind_rot_speed_rps = grind_speed_mps * 0.5 / diam_m
      global grind_rot_accel_rpss = grind_accel_mpss * 0.5 / diam_m
      global grind_rot_blend_radius_rad = grind_blend_radius_m * 0.5 / diam_m #TRYING THIS AGAIN * 0.5 / diam_m Cannot scale blend_radius down! Leave as-is
    end
  end
  
  # Set grind variables chosen by command[2]
  # Value after set is always returned to socket
  def set_grind_variable():
    global grind_ready = False
    socket_send_line("grind_ready=False")
  
    if command[2] == 1:
      global response = "set grind_contact_enable"
      if command[3] >= 0 and command[3] <= 2:
        global grind_contact_enable = command[3]
      end
      socket_set_var("grind_contact_enable", grind_contact_enable)
    elif command[2] == 2:
      global response = "set grind_touch_retract_mm"
      if command[3] >= 0:
        global grind_touch_retract_mm = command[3]
      end
      socket_set_var("grind_touch_retract_mm", grind_touch_retract_mm)
    elif command[2] == 3:
      global response = "set grind_touch_speed_mmps"
      if command[3] >= 0:
        global grind_touch_speed_mmps = command[3]
      end
      socket_set_var("grind_touch_speed_mmps", grind_touch_speed_mmps)
    elif command[2] == 4:
      global response = "set grind_force_dwell_ms"
      if command[3] >= 0:
        global grind_force_dwell_ms = command[3]
      end
      socket_set_var("grind_force_dwell_ms", grind_force_dwell_ms)
    elif command[2] == 5:
      global response = "set grind_max_wait_ms"
      if command[3] >= 0:
        global grind_max_wait_ms = command[3]
      end
      socket_set_var("grind_max_wait_ms", grind_max_wait_ms)
    elif command[2] == 6:
      global response = "set grind_blend_radius_mm"
      if command[3] >= 0:
        global grind_blend_radius_m = command[3] / 1000.0
      end
      socket_send_string("grind_blend_radius_mm=")
      socket_send_string(grind_blend_radius_m * 1000.0)
      socket_send_lf()
    elif command[2] == 7:
      global response = "set grind_trial_speed_mmps"
      if command[3] > 0:
        global grind_trial_speed_mmps = command[3]
      end
      socket_set_var("grind_trial_speed_mmps", grind_trial_speed_mmps)
    elif command[2] == 8:
      global response = "set grind_accel_mmpss"
      if command[3] > 0:
        global grind_accel_mmpss = command[3]
      end
      socket_set_var("grind_accel_mmpss", grind_accel_mmpss)
    else:
      global response = "Unknown grind set variable command"
    end
  
    global grind_ready = True
    socket_send_line("grind_ready=True")
  end
  
  # Execute the desired grind operation as specified in command[2]...
  def grind():
    global grind_ready = False
    socket_send_line("grind_ready=False")
  
    # Start listening for abort commands from host
    if grind_abort_listener_thread_handle > 0:
      kill grind_abort_listener_thread_handle
      grind_abort_listener_thread_handle = 0
    end
    grind_abort_listener_thread_handle = run grind_abort_listener_thread()
  
    global grind_cycle = 0
    socket_set_var("grind_cycle", grind_cycle)
  
    # Defaults but any used should be set as needed below
    global grind_dx_mm = 0
    global grind_dy_mm = 0
    global grind_n_cycles = 0
    global grind_force_N = 10.0
    global grind_continue = False
    global grind_circle1_diam_mm = 0
    global grind_circle2_diam_mm = 0
    global grind_n_spirals = 0
    global grind_n_xsteps = 1
    global grind_n_ysteps = 1
    global grind_xstep_mm = 0
    global grind_ystep_mm = 0
    speed_setter(20)
  
    # Install tcp that puts tcp at center of part (noop for flat parts!)
    set_tcp(robot_tcp_part)
  
    if command[2] == 10:
      # LINEAR GRIND
      global response = "grind_line"
      global grind_dx_mm = command[3]
      global grind_dy_mm = command[4]
      n_cycle_setter(command[5])
      speed_setter(command[6])
      global grind_force_N = command[7]
      global grind_continue = command[8] > 0
      grind_line(grind_dx_mm, grind_dy_mm, grind_n_cycles, grind_continue)
  
    elif command[2] == 20:
      # RECTANGULAR GRIND
      global response = "grind_rect"
      global grind_dx_mm = command[3]
      global grind_dy_mm = command[4]
      n_cycle_setter(command[5])
      speed_setter(command[6])
      global grind_force_N = command[7]
      global grind_continue = command[8] > 0
      grind_rect(grind_dx_mm, grind_dy_mm, grind_n_cycles, grind_continue)
  
    elif command[2] == 30:
      # SERPENTINE GRIND
      global response = "grind_serpentine"
      global grind_dx_mm = command[3]
      global grind_dy_mm = command[4]
      global grind_n_xsteps = limiter(command[5], 1, 10)
      global grind_n_ysteps = limiter(command[6], 1, 10)
      n_cycle_setter(command[7])
      speed_setter(command[8])
      global grind_force_N = command[9]
      global grind_continue = command[10] > 0
      grind_serpentine(grind_dx_mm, grind_dy_mm, grind_n_xsteps, grind_n_ysteps, grind_n_cycles, grind_continue)
  
    elif command[2] == 40:
      # CIRCULAR GRIND
      global response = "grind_circle"
      global grind_circle1_diam_mm = command[3]
      n_cycle_setter(command[4])
      speed_setter(command[5])
      global grind_force_N = command[6]
      global grind_continue = command[7] > 0
      grind_circle(grind_circle1_diam_mm, grind_n_cycles, grind_continue)
  
    elif command[2] == 50:
      # SPIRAL GRIND
      global response = "grind_spiral"
      global grind_circle1_diam_mm = command[3]
      global grind_circle2_diam_mm = command[4]
      global grind_n_spirals = command[5]
      n_cycle_setter(command[6])
      speed_setter(command[7])
      global grind_force_N = command[8]
      global grind_continue = command[9] > 0
      grind_spiral(grind_circle1_diam_mm, grind_circle2_diam_mm, grind_n_spirals, grind_n_cycles, grind_continue)
  
    elif command[2] == 99:
      # Retract Command
      global response = "grind_retract"
      set_grind_process_state(False)
  
    else:
      # Illegal grind command
      global response = "Unknown grind command"
    end
  
    # Restore tool-only tcp
    set_tcp(robot_tcp)
  
    # Stop listening for abort commands from host
    if grind_abort_listener_thread_handle > 0:
      kill grind_abort_listener_thread_handle
      grind_abort_listener_thread_handle = 0
    end
  
    global grind_ready = True
    socket_send_line("grind_ready=True")
  end
  
  # Get into contact with part (or away from it)
  # enable:  0=No Contact   1=Touch but no tool/coolant on or force  2=Touch, Tool, Coolant, and Force
  def contact_part(on = False, enable = 0):
    if on:
      if enable == 0:
        # Just do a small forward motion in the direction of touchoff- this is a simulated p_contact_init
        p_contact_init = pose_trans(get_forward_kin(), p[0, 0, 0.005, 0, 0, 0])
        movel(p_contact_init, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
      elif enable == 1:
        # Advance until contact but retract 2X grind distance and use this as a simulated p_contact_init
        success = touchoff(grind_touch_speed_mmps, grind_touch_retract_mm * 2.0)
        p_contact_init = get_target_tcp_pose()
        return success
      elif enable == 2:
        # Advance until contact
        success = touchoff(grind_touch_speed_mmps, grind_touch_retract_mm)
        # Touchoff has backed off by grind_touch_retract_mm so we need to compute that actual p_contact_init
        p_contact_init = pose_trans(get_forward_kin(), p[0, 0, grind_touch_retract_mm / 1000.0, 0, 0, 0])
        return success
      end
    else:  # Back off
      stopl(2.0)
      sleep(0.020)
      p1 = pose_trans(get_forward_kin(), p[0, 0, -0.010, 0, 0, 0])
      movel(p1, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
    end
  
    return True
  end
  
  # Sets digital outpus based 8-element list of 4 pairs DOUT#,State.  -1 indicates unused slot
  def set_digital_output_list(list):
    i = 0
    while i < 8:
      if list[i] >= 0:
        b = list[i + 1] == 1
        set_digital_out(list[i], b)
      end
      i = i + 2
    end
  end
  
  # Turn tool power on/off if enable=2
  def tool_power(on = False, enable = 0):
    if enable < 2:
      return None
    end
  
    if on:
      # ON IO
      set_digital_output_list(robot_tool_on_outputs)
    else:
      # OFF IO
      set_digital_output_list(robot_tool_off_outputs)
    end
  
    return None
  end
  
  # Turn coolant on/off if enable=2
  def coolant_flow(on = False, enable = 0):
    if enable < 2:
      return None
    end
  
    if on:
      # ON IO
      set_digital_output_list(robot_coolant_on_outputs)
    else:
      # OFF IO
      set_digital_output_list(robot_coolant_off_outputs)
    end
  
    return None
  end
  
  # Turn foce mode on/pff if enable=2
  def apply_force(on = False, enable = 0, approach_speed_mmps = 10):
    if enable < 2:
      return None
    end
  
    if on:
      # Settle and zero the force/torque sensor
      sleep(0.1)
      zero_ftsensor()
      # Force is in tool frame
      # Compliant in Tool Z
      # Applying grind_force_N in Z+
      # 2: Force frame not transformed
      # Speed limits
      force_mode(tool_pose(), [0, 0, 1, 0, 0, 0], [0.0, 0.0, grind_force_N, 0.0, 0.0, 0.0], 2, [0.1, 0.1, approach_speed_mmps / 1000.0, 0.3490658503988659, 0.3490658503988659, 0.3490658503988659])
      # Now we sleep as directed to hopefully come into contact with the part!
      sleep(grind_force_dwell_ms / 1000.0)
    else:
      end_force_mode()
      sleep(0.1)
    end
  
    return None
  end
  
  # Start/stop Grinding (on/off)
  # Pose to center is the offset we shgould move to initial touch point [0]=FLAT [1]=CYLINDER [2]=SPHERE
  global grind_process_state = False
  def set_grind_process_state(on = False, pose_to_center = [p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0]]):
    if on and not grind_process_state:
      global p_operator_init = get_target_tcp_pose()
  
      # Move to start position for touchoff
      shape = robot_part_geometry[0]
      if shape < 1 or shape > 3:
        return False
      end
  
      p1 = pose_trans(p_operator_init, pose_to_center[shape-1])
      movel(p1, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
  
      # Touch part and set p_contact_init
      if not contact_part(True, grind_contact_enable):
        # Failure to contact part should abort... don't set grind_process_state and return False
        movel(p_operator_init, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
        socket_send_line("grind_process_state=False")
        return False
      end
  
      # Compute p_contact_center... where we would have been if we had touched off from the operator teach position!
      reverse_pose_to_center = pose_to_center[shape-1]
      i = 0
      while i < 6:
        reverse_pose_to_center[i] = -reverse_pose_to_center[i]
        i = i + 1
      end
      global p_contact_center = pose_trans(p_contact_init, reverse_pose_to_center)
  
      # Now power everything on (although these will do nothing unless conact_enable==2)
      tool_power(True, grind_contact_enable)
      coolant_flow(True, grind_contact_enable)
      apply_force(True, grind_contact_enable, grind_touch_speed_mmps)
      grind_process_state = True
    elif not on and grind_process_state:
      # Shut everything down and return to original pose
      apply_force(False, grind_contact_enable, 0)
      contact_part(False, grind_contact_enable)
      coolant_flow(False, grind_contact_enable)
      tool_power(False, grind_contact_enable)
      movel(p_operator_init, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
      grind_process_state = False
    end
  
    # Always let the host know status
    if grind_process_state:
      socket_send_line("grind_process_state=True")
    else:
      socket_send_line("grind_process_state=False")
    end
    return True
  end
  
  ######################################################################################
  # Thread to listen for abort messages while grinding
  #
  thread grind_abort_listener_thread():
    global halt_command = [0, 0, 0, 0]
    global halt_count = 0
    while (halt_count == 0):
      global halt_command = socket_read_ascii_float(3, timeout = 0.1)
  
      # If door is open, that adds a halt count (anything >0 will stop us!)
      if not is_door_closed():
        global halt_count = halt_count + 1
      end
  
      # If we've received(index,checksum,10,...) that adds a halt count (as long as checksum matches)
      if halt_command[0] > 2:
        global test_index = halt_command[1]
        global test_checksum = halt_command[2]
        global test_command = halt_command[3]
  
        if test_checksum == 1000 - test_index and test_command == 10:
          global halt_count = halt_count + 1
  
          # Send an start/finish acknowledgement just for this command!
          socket_set_var("robot_starting", test_index)
          socket_set_var("robot_completed", test_index)
        end
      end
      sync()
    end
    return None
  end
  
  # Should we proceed? lat_count==0 means no door-opens and no abort commands from host
  def ok_to_proceed():
    return halt_count == 0
  end
  #
  # Thread to listen for abort messages while grinding
  ######################################################################################
  
  
  ######################################################################################
  # TOP LEVEL GRIND FUNCTIONS
  #
  
  # Grind along a line dx_mm x dy_mm centered on current tool position. Repeat n_cycles times. If stay_in_contact, stay_in_contact at end.
  def grind_line(dx_mm, dy_mm, n_cycles, stay_in_contact):
    if n_cycles < 1:
      return True
    end
  
    # Unit conversion
    dx_m = dx_mm / 1000.0
    dy_m = dy_mm / 1000.0
    radius_m = robot_part_geometry[1] / 2000.0
    drx_rad = dx_m / radius_m
    dry_rad = dy_m / radius_m
  
    # Grind time estimate
    time_ms = sqrt(dx_mm * dx_mm + dy_mm * dy_mm) * n_cycles / grind_speed_mps + 1500
    socket_set_var("robot_step_time_estimate_ms", time_ms)
  
    if not set_grind_process_state(True, [p[-dx_m / 2.0, -dy_m / 2.0, 0, 0, 0, 0], p[-dx_m / 2.0, 0, 0, -dry_rad / 2.0, 0, 0], p[0, 0, 0, -drx_rad / 2.0, -dry_rad / 2.0, 0]]):
      return False
    end
  
    # Grind the pattern
    shape = robot_part_geometry[0]
    diam_m = robot_part_geometry[1] / 1000.0
    if shape == 1:
      pattern_line_flat(p_contact_center, dx_m, dy_m, n_cycles)
    elif shape == 2:
      # Speed factor is 0.5/diam for pure rotational (all y) and 1.0 for pure translational (all x)
      max_speed_factor = 0.5 / diam_m
      theta = atan2(abs(dy_mm), abs(dx_mm))
      speed_factor = 1.0 + (max_speed_factor-1.0) * abs(sin(theta))
      pattern_line_cylinder(p_contact_center, dx_m, dry_rad, speed_factor, n_cycles)
    elif shape == 3:
      pattern_line_sphere(p_contact_center, drx_rad, dry_rad, n_cycles)
    end
  
    if not stay_in_contact or not ok_to_proceed():
      set_grind_process_state(False)
    end
    return True
  end
  
  # Grind along a rect dx_mm x dy_mm centered on current tool position. Repeat n_cycles times. If stay_in_contact, stay_in_contact at end.
  # Move in x direction first, then y
  def grind_rect(dx_mm, dy_mm, n_cycles, stay_in_contact):
    if n_cycles < 1:
      return True
    end
  
    # Unit conversion
    dx_m = dx_mm / 1000.0
    dy_m = dy_mm / 1000.0
    diam_m = robot_part_geometry[1] / 1000.0
    radius_m = diam_m / 2.0
    drx_rad = dx_m / radius_m
    dry_rad = dy_m / radius_m
    speed_factor = 0.5 / diam_m  # 0.5 / diam_m is the speedup needed on rotational moves
  
    # Grind time estimate
    time_ms = 2 * (dx_mm + dy_mm) * n_cycles / grind_speed_mps + 1500
    socket_set_var("robot_step_time_estimate_ms", time_ms)
  
    if not set_grind_process_state(True, [p[-dx_m / 2.0, -dy_m / 2.0, 0, 0, 0, 0], p[-dx_m / 2.0, 0, 0, -dry_rad / 2.0, 0, 0], p[0, 0, 0, -drx_rad / 2.0, -dry_rad / 2.0, 0]]):
      return False
    end
  
    # Grind the pattern
    shape = robot_part_geometry[0]
    if shape == 1:
      pattern_rect_flat(p_contact_center, dx_m, dy_m, n_cycles)
    elif shape == 2:
      pattern_rect_cylinder(p_contact_center, dx_m, dry_rad, n_cycles)
    elif shape == 3:
      pattern_rect_sphere(p_contact_center, drx_rad, dry_rad, n_cycles)
    end
  
    if not stay_in_contact or not ok_to_proceed():
      set_grind_process_state(False)
    end
    return True
  end
  
  # Grind along a rect in serpentine dx_mm,dy_mm incrementing by xstep_mm,ystep_mm centered on current tool position. Repeat n_cycles times. If stay_in_contact, stay_in_contact at end.
  # Move in x direction first, then y
  def grind_serpentine(dx_mm, dy_mm, n_xsteps, n_ysteps, n_cycles, stay_in_contact):
    if n_cycles < 1:
      return True
    end
  
    # Either n_xsteps or n_ysteps must be 1. Whichever one is one will be the direction of the first move.
    if n_xsteps != 1 and n_ysteps != 1:
      return False
    end
  
    # Unit conversion
    dx_m = dx_mm / 1000.0
    dy_m = dy_mm / 1000.0
    part_radius_m = robot_part_geometry[1] / 2000.0
    drx_rad = dy_m / part_radius_m
    dry_rad = dy_m / part_radius_m
  
    # Grind time estimate
    # Per Cycle:
    # 1,3 does 4 passes in x and 1 in y     3,1 does 4 passes in Y and 1 in X
    #   ########################            #  ####  #
    #                          #            #  #  #  #
    #   ########################            #  #  #  #
    #   #                                   #  #  #  #
    #   ########################            #  #  #  #
    #                          #            #  #  #  #
    #   ########################            ####  ####
    if n_xsteps == 1:
      time_ms = (dx_mm * (n_ysteps + 1) + dy_mm) * n_cycles / grind_speed_mps + 1500
    else:
      time_ms = (dx_mm + dy_mm * (n_xsteps + 1)) * n_cycles / grind_speed_mps + 1500
    end
    socket_set_var("robot_step_time_estimate_ms", time_ms)
  
    if not set_grind_process_state(True, [p[-dx_m / 2.0, -dy_m / 2.0, 0, 0, 0, 0], p[-dx_m / 2.0, 0, 0, -dry_rad / 2.0, 0, 0], p[0, 0, 0, -drx_rad / 2.0, -dry_rad / 2.0, 0]]):
      return False
    end
  
    # Grind the pattern
    shape = robot_part_geometry[0]
    if shape == 1:
      pattern_serpentine_flat(p_contact_center, dx_m, dy_m, n_xsteps, n_ysteps, n_cycles)
    elif shape == 2:
      pattern_serpentine_cylinder(p_contact_center, dx_m, drx_rad, n_xsteps, n_ysteps, n_cycles)
    elif shape == 3:
      pattern_serpentine_sphere(p_contact_center, drx_rad, dry_rad, n_xsteps, n_ysteps, n_cycles)
    end
  
    if not stay_in_contact or not ok_to_proceed():
      set_grind_process_state(False)
    end
    return True
  end
  
  # Grind along a circle with circle_diam_mm centered on p_center. Repeat n_cycles times. If stay_in_contact, stay_in_contact at end.
  def grind_circle(circle_diam_mm, n_cycles, stay_in_contact):
    if n_cycles < 1:
      return True
    end
  
    # Unit conversion
    circle_diam_m = circle_diam_mm / 1000.0
    part_diam_m = robot_part_geometry[1] / 1000.0
  
    # Grind time estimate
    time_ms = MATH_PI * circle_diam_mm * n_cycles / grind_speed_mps + 1500
    socket_set_var("robot_step_time_estimate_ms", time_ms)
  
  
    if not set_grind_process_state(True, [p[-circle_diam_m / 2.0, 0, 0, 0, 0, 0], p[-circle_diam_m / 2.0, 0, 0, 0, 0, 0], p[0, 0, 0, -circle_diam_m / part_diam_m, 0, 0]]):
      return False
    end
  
    # Grind the pattern
    shape = robot_part_geometry[0]
    if shape == 1:
      pattern_circle_flat(p_contact_center, circle_diam_m, n_cycles)
    elif shape == 2:
      pattern_circle_cylinder(p_contact_center, circle_diam_m, part_diam_m, n_cycles)
    elif shape == 3:
      pattern_circle_sphere(p_contact_center, circle_diam_m, part_diam_m, n_cycles)
    end
  
    if not stay_in_contact or not ok_to_proceed():
      set_grind_process_state(False)
    end
    return True
  end
  
  # Grind along a spiral circle1_diam_mm to circle2_diam_mm in n_spirals with rotations centered on current tool position. Repeat n_cycles times. If stay_in_contact, stay_in_contact at end.
  def grind_spiral(circle1_diam_mm, circle2_diam_mm, n_spirals, n_cycles, stay_in_contact):
    if n_cycles < 1:
      return True
    end
  
    # Unit conversion
    circle1_diam_m = circle1_diam_mm / 1000.0
    circle2_diam_m = circle2_diam_mm / 1000.0
    part_diam_m = robot_part_geometry[1] / 1000.0
  
    # Grind time estimate based on average diam
    avg_diam_mm = (circle1_diam_mm + circle2_diam_mm) / 2.0
    time_ms = MATH_PI * avg_diam_mm * n_spirals * n_cycles / grind_speed_mps + 1500
    socket_set_var("robot_step_time_estimate_ms", time_ms)
  
    if not set_grind_process_state(True, [p[-circle1_diam_m / 2.0, 0, 0, 0, 0, 0], p[-circle1_diam_m / 2.0, 0, 0, 0, 0, 0], p[0, 0, 0, -circle1_diam_m / part_diam_m, 0, 0]]):
      return False
    end
  
    # Grind the pattern
    shape = robot_part_geometry[0]
    if shape == 1:
      pattern_spiral_flat(p_contact_center, circle1_diam_m, circle2_diam_m, n_spirals, n_cycles)
    elif shape == 2:
      pattern_spiral_cylinder(p_contact_center, circle1_diam_m, circle2_diam_m, n_spirals, part_diam_m, n_cycles)
    elif shape == 3:
      pattern_spiral_sphere(p_contact_center, circle1_diam_m, circle2_diam_m, n_spirals, part_diam_m, n_cycles)
    end
  
    if not stay_in_contact or not ok_to_proceed():
      set_grind_process_state(False)
    end
    return True
  end
  
  
  ######################################################################################
  # PATTERN GRINDING FUNCTIONS
  #
  
  # Call at end of pattern
  def pattern_complete():
    # This stops motion but won't kill force_mode the way stopl will
    local p0 = get_actual_tcp_pose()
    movel(p0, a = grind_accel_mpss, v = grind_speed_mps)
  
    local p0a = get_target_tcp_pose()
    global pattern_dist1 = pose_dist(p0a, p0)
  
    local p0b = get_actual_tcp_pose()
    global pattern_dist2 = pose_dist(p0b, p0)
  end
  
  ######################################################################################
  # LINE PATTERNS
  #
  
  # Move along a flat line dx_m x dy_m centered on p_center. Repeat n_cycles times.
  # Move in x direction first, then y
  def pattern_line_flat(p_center, dx_m, dy_m, n_cycles):
    p0 = pose_trans(p_center, p[-dx_m / 2.0, -dy_m / 2.0, 0, 0, 0, 0])
    p1 = pose_trans(p_center, p[dx_m / 2.0, dy_m / 2.0, 0, 0, 0, 0])
    t_move = sqrt(dx_m * dx_m + dy_m * dy_m) / grind_speed_mps
    pdest = p1
  
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      socket_set_var("grind_cycle", grind_cycle)
  
      if ok_to_proceed():
        movel_int(pdest, a = grind_accel_mpss, v = grind_speed_mps, r = grind_blend_radius_m, t_move = t_move)
      end
  
      # Alternate directions for multiple cycles
      if pdest == p0:
        pdest = p1
      else:
        pdest = p0
      end
  
      grind_cycle = grind_cycle + 1
    end
    pattern_complete()
  end
  
  # Move along a cylindrical line dx_mm,drx_rad centered on p_center. Repeat n_cycles times.
  # Move in x direction first, then rx
  def pattern_line_cylinder(p_center, dx_m, drx_rad, speed_factor, n_cycles):
    p0 = pose_trans(p_center, p[-dx_m / 2.0, 0, 0, -drx_rad / 2.0, 0, 0])
    p1 = pose_trans(p_center, p[dx_m / 2.0, 0, 0, drx_rad / 2.0, 0, 0])
    t_move = sqrt(pow(dx_m / grind_speed_mps, 2) + pow(drx_rad / grind_rot_speed_rps / 4, 2))
    pdest = p1
  
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      socket_set_var("grind_cycle", grind_cycle)
  
      if ok_to_proceed():
        # Chugging
        #movel_int(pdest, a = grind_accel_mpss * speed_factor, v = grind_speed_mps * speed_factor, r = grind_blend_radius_m, t_move = t_move)
        # Better?
        movel_int(pdest, a = grind_accel_mpss * speed_factor, v = grind_speed_mps * speed_factor, r = grind_blend_radius_m * speed_factor, t_move = t_move)
      end
  
      # Alternate directions for multiple cycles
      if pdest == p0:
        pdest = p1
      else:
        pdest = p0
      end
  
      grind_cycle = grind_cycle + 1
    end
    pattern_complete()
  end
  
  # Move along a spherical line drx_rad,dry_rad centered on p_center. Repeat n_cycles times.
  # Move in rx direction first, then ry
  def pattern_line_sphere(p_center, drx_rad, dry_rad, n_cycles):
    p0 = pose_trans(p_center, p[0, 0, 0, -drx_rad / 2.0, -dry_rad / 2.0, 0])
    p1 = pose_trans(p_center, p[0, 0, 0, drx_rad / 2.0, dry_rad / 2.0, 0])
    t_move = sqrt(drx_rad * drx_rad + dry_rad * dry_rad) / grind_rot_speed_rps / 4
    pdest = p1
  
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      socket_set_var("grind_cycle", grind_cycle)
  
      if ok_to_proceed():
        movel_int(pdest, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, r = grind_rot_blend_radius_rad, t_move = t_move)
      end
  
      # Alternate directions for multiple cycles
      if pdest == p0:
        pdest = p1
      else:
        pdest = p0
      end
  
      grind_cycle = grind_cycle + 1
    end
    pattern_complete()
  end
  
  
  ######################################################################################
  # RECT PATTERNS
  #
  
  # Move along a flat rect dx_m x dy_m centered on p_center. Repeat n_cycles times.
  # Move in x direction first, then y
  def pattern_rect_flat(p_center, dx_m, dy_m, n_cycles):
    t_move_x = dx_m / grind_speed_mps
    t_move_y = dy_m / grind_speed_mps
  
    global grind_cycle = 1
    if ok_to_proceed():
      p1 = pose_trans(p_center, p[-dx_m / 2.0, -dy_m / 2.0, 0, 0, 0, 0])
      movel_int(p1, a = grind_accel_mpss, v = grind_speed_mps, r = grind_blend_radius_m, t_move = 1)
    end
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      socket_set_var("grind_cycle", grind_cycle)
  
      if ok_to_proceed():
        p1 = pose_trans(p_center, p[dx_m / 2.0, -dy_m / 2.0, 0, 0, 0, 0])
        movel_int(p1, a = grind_accel_mpss, v = grind_speed_mps, r = grind_blend_radius_m, t_move = t_move_x)
      end
  
      if ok_to_proceed():
        p1 = pose_trans(p_center, p[dx_m / 2.0, dy_m / 2.0, 0, 0, 0, 0])
        movel_int(p1, a = grind_accel_mpss, v = grind_speed_mps, r = grind_blend_radius_m, t_move = t_move_y)
      end
  
      if ok_to_proceed():
        p1 = pose_trans(p_center, p[-dx_m / 2.0, dy_m / 2.0, 0, 0, 0, 0])
        movel_int(p1, a = grind_accel_mpss, v = grind_speed_mps, r = grind_blend_radius_m, t_move = t_move_x)
      end
  
      if ok_to_proceed():
        p1 = pose_trans(p_center, p[-dx_m / 2.0, -dy_m / 2.0, 0, 0, 0, 0])
        movel_int(p1, a = grind_accel_mpss, v = grind_speed_mps, r = grind_blend_radius_m, t_move = t_move_y)
      end
      grind_cycle = grind_cycle + 1
    end
    pattern_complete()
  end
  
  # Move along a cylindrical rect dx_mm,drx_rad centered on p_center. Repeat n_cycles times.
  # Move in x direction first, then rx
  def pattern_rect_cylinder(p_center, dx_m, drx_rad, n_cycles):
    t_move_x = dx_m / grind_speed_mps
    t_move_rx = drx_rad / grind_rot_speed_rps / 4
  
    if ok_to_proceed():
      p1 = pose_trans(p_center, p[-dx_m / 2.0, 0, 0, -drx_rad / 2.0, 0, 0])
      movel_int(p1, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, r = grind_rot_blend_radius_rad, t_move = 1)
    end
  
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      socket_set_var("grind_cycle", grind_cycle)
      if ok_to_proceed():
        p1 = pose_trans(p_center, p[dx_m / 2.0, 0, 0, -drx_rad / 2.0, 0, 0])
        movel_int(p1, a = grind_accel_mpss, v = grind_speed_mps, r = grind_blend_radius_m, t_move = t_move_x)
      end
  
      if ok_to_proceed():
        p1 = pose_trans(p_center, p[dx_m / 2.0, 0, 0, drx_rad / 2.0, 0, 0])
        movel_int(p1, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, r = grind_rot_blend_radius_rad, t_move = t_move_rx)
      end
  
      if ok_to_proceed():
        p1 = pose_trans(p_center, p[-dx_m / 2.0, 0, 0, drx_rad / 2.0, 0, 0])
        movel_int(p1, a = grind_accel_mpss, v = grind_speed_mps, r = grind_blend_radius_m, t_move = t_move_x)
      end
  
      if ok_to_proceed():
        p1 = pose_trans(p_center, p[-dx_m / 2.0, 0, 0, -drx_rad / 2.0, 0, 0])
        movel_int(p1, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, r = grind_rot_blend_radius_rad, t_move = t_move_rx)
      end
      grind_cycle = grind_cycle + 1
    end
    pattern_complete()
  end
  
  # Move along a spherical rect drx_rad,dry_rad centered on p_center. Repeat n_cycles times.
  # Move in rx direction first, then ry
  def pattern_rect_sphere(p_center, drx_rad, dry_rad, n_cycles):
    t_move_rx = drx_rad / grind_rot_speed_rps / 4
    t_move_ry = dry_rad / grind_rot_speed_rps / 4
  
    if ok_to_proceed():
      p1 = pose_trans(p_center, p[0, 0, 0, -drx_rad / 2.0, -dry_rad / 2.0, 0])
      movel_int(p1, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, r = grind_rot_blend_radius_rad, t_move = 1)
    end
  
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      socket_set_var("grind_cycle", grind_cycle)
      if ok_to_proceed():
        p1 = pose_trans(p_center, p[0, 0, 0, drx_rad / 2.0, -dry_rad / 2.0, 0])
        movel_int(p1, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, r = grind_rot_blend_radius_rad, t_move = t_move_rx)
      end
  
      if ok_to_proceed():
        p1 = pose_trans(p_center, p[0, 0, 0, drx_rad / 2.0, dry_rad / 2.0, 0])
        movel_int(p1, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, r = grind_rot_blend_radius_rad, t_move = t_move_ry)
      end
  
      if ok_to_proceed():
        p1 = pose_trans(p_center, p[0, 0, 0, -drx_rad / 2.0, dry_rad / 2.0, 0])
        movel_int(p1, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, r = grind_rot_blend_radius_rad, t_move = t_move_rx)
      end
  
      if ok_to_proceed():
        p1 = pose_trans(p_center, p[0, 0, 0, -drx_rad / 2.0, -dry_rad / 2.0, 0])
        movel_int(p1, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, r = grind_rot_blend_radius_rad, t_move = t_move_ry)
      end
      grind_cycle = grind_cycle + 1
    end
    pattern_complete()
  end
  
  
  ######################################################################################
  # SERPENTINE PATTERNS
  #
  
  # Move along a flat serpentine dx_m,dy_m in n_xsteps,n_ysteps centered on p_center. Repeat n_cycles times.
  # Move in direction of whichever nsteps is 1 first
  def pattern_serpentine_flat(p_center, dx_m, dy_m, n_xsteps, n_ysteps, n_cycles):
    t_move_x = dx_m / grind_speed_mps
    t_move_y = dy_m / grind_speed_mps
  
    # Bottom left corner, grid 0,0
    p0 = pose_trans(p_center, p[-dx_m / 2.0, -dy_m / 2.0, 0, 0, 0, 0])
  
    # Track our grid square number... we're in [0,0] and moving [+1,+1] in either x or y
    x_grid = 0
    y_grid = 0
    x_incr = 1
    y_incr = 1
    grid_dx_m = dx_m / n_xsteps
    grid_dy_m = dy_m / n_ysteps
  
    # How many moves does it take to complete a pass?
    global n_moves_per_pass = (n_xsteps + n_ysteps) * 2 - 1
  
    move_count = 0
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      # This will repeat for each leg of the serpentine!
      socket_set_var("grind_cycle", grind_cycle)
  
      # Skip first X move if we should start with a y move
      if grind_cycle != 1 or move_count != 0 or n_xsteps == 1:
        # Advance x_grid by x_incr
        x_grid = x_grid + x_incr
  
        # Move to the corresponding position
        p1 = pose_trans(p0, p[x_grid * grid_dx_m, y_grid * grid_dy_m, 0, 0, 0, 0])
        movel_int(p1, a = grind_accel_mpss, v = grind_speed_mps, r = grind_blend_radius_m, t_move = t_move_x / n_xsteps)
  
        # Adjust x direction
        if x_grid >= n_xsteps:
          x_incr = -1
        elif x_grid <= 0:
          x_incr = 1
        end
        move_count = move_count + 1
      end
  
      if ok_to_proceed() and move_count < n_moves_per_pass:
        # Advance y_grid by y_incr
        y_grid = y_grid + y_incr
  
        # Move to the corresponding position
        p1 = pose_trans(p0, p[x_grid * grid_dx_m, y_grid * grid_dy_m, 0, 0, 0, 0])
        movel_int(p1, a = grind_accel_mpss, v = grind_speed_mps, r = grind_blend_radius_m, t_move = t_move_y / n_ysteps)
  
        # Adjust y direction
        if y_grid >= n_ysteps:
          y_incr = -1
        elif y_grid <= 0:
          y_incr = 1
        end
        move_count = move_count + 1
      end
  
      # Detect when we've covered all the grid squares!
      if move_count >= n_moves_per_pass:
        grind_cycle = grind_cycle + 1
        move_count = 0
      end
    end
    pattern_complete()
  end
  
  # Move along a cylindrical serpentine dx_m,drx_rad in n_xsteps,n_rxsteps centered on p_center. Repeat n_cycles times.
  # Move in direction of whichever nsteps is 1 first
  def pattern_serpentine_cylinder(p_center, dx_m, drx_rad, n_xsteps, n_rxsteps, n_cycles):
    t_move_x = dx_m / grind_speed_mps
    t_move_rx = drx_rad / grind_rot_speed_rps / 4
  
    # Bottom left corner, grid 0,0
    p0 = pose_trans(p_center, p[-dx_m / 2.0, 0, 0, -drx_rad / 2.0, 0, 0])
  
    # Track our grid square number... we're in [0,0] and moving [+1,+1] in either x or y
    x_grid = 0
    y_grid = 0
    x_incr = 1
    y_incr = 1
    grid_dx_m = dx_m / n_xsteps
    grid_drx_rad = drx_rad / n_rxsteps
  
    # How many moves does it take to complete a pass?
    global n_moves_per_pass = (n_xsteps + n_rxsteps) * 2 - 1
  
    move_count = 0
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      # This will repeat for each leg of the serpentine!
      socket_set_var("grind_cycle", grind_cycle)
  
      # Skip first X move if we should start with a y move
      if grind_cycle != 1 or move_count != 0 or n_xsteps == 1:
        # Advance x_grid by x_incr
        x_grid = x_grid + x_incr
  
        # Move to the corresponding position
        p1 = pose_trans(p0, p[x_grid * grid_dx_m, 0, 0, y_grid * grid_drx_rad, 0, 0])
        movel_int(p1, a = grind_accel_mpss, v = grind_speed_mps, r = grind_blend_radius_m, t_move = t_move_x / n_xsteps)
  
        # Adjust x direction
        if x_grid >= n_xsteps:
          x_incr = -1
        elif x_grid <= 0:
          x_incr = 1
        end
        move_count = move_count + 1
      end
  
      if ok_to_proceed() and move_count < n_moves_per_pass:
        # Advance y_grid by y_incr
        y_grid = y_grid + y_incr
  
        # Move to the corresponding position
        p1 = pose_trans(p0, p[x_grid * grid_dx_m, 0, 0, y_grid * grid_drx_rad, 0, 0])
        movel_int(p1, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, r = grind_rot_blend_radius_rad, t_move = t_move_rx / n_rxsteps)
  
        # Adjust y direction
        if y_grid >= n_rxsteps:
          y_incr = -1
        elif y_grid <= 0:
          y_incr = 1
        end
        move_count = move_count + 1
      end
  
      # Detect when we've covered all the grid squares!
      if move_count >= n_moves_per_pass:
        grind_cycle = grind_cycle + 1
        move_count = 0
      end
    end
    pattern_complete()
  end
  
  # Move along a sperical serpentine drx_rad,dry_rad in n_rxsteps,n_rysteps centered on p_center. Repeat n_cycles times.
  # Move in direction of whichever nsteps is 1 first
  def pattern_serpentine_sphere(p_center, drx_rad, dry_rad, n_rxsteps, n_rysteps, n_cycles):
    t_move_rx = drx_rad / grind_rot_speed_rps / 4
    t_move_ry = dry_rad / grind_rot_speed_rps / 4
  
    # Bottom left corner, grid 0,0
    p0 = pose_trans(p_center, p[0, 0, 0, -drx_rad / 2.0, -dry_rad / 2.0, 0])
  
    # Track our grid square number... we're in [0,0] and moving [+1,+1] in either x or y
    x_grid = 0
    y_grid = 0
    x_incr = 1
    y_incr = 1
    grid_drx_rad = drx_rad / n_rxsteps
    grid_dry_rad = dry_rad / n_rysteps
  
    # How many moves does it take to complete a pass?
    global n_moves_per_pass = (n_rxsteps + n_rysteps) * 2 - 1
  
    move_count = 0
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      # This will repeat for each leg of the serpentine!
      socket_set_var("grind_cycle", grind_cycle)
  
      # Skip first X move if we should start with a y move
      if grind_cycle != 1 or move_count != 0 or n_rxsteps == 1:
        # Advance x_grid by x_incr
        x_grid = x_grid + x_incr
  
        # Move to the corresponding position
        p1 = pose_trans(p0, p[0, 0, 0, x_grid * grid_drx_rad, y_grid * grid_dry_rad, 0])
        movel_int(p1, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, r = grind_rot_blend_radius_rad, t_move = t_move_rx / n_rxsteps)
  
        # Adjust x direction
        if x_grid >= n_rxsteps:
          x_incr = -1
        elif x_grid <= 0:
          x_incr = 1
        end
        move_count = move_count + 1
      end
  
      if ok_to_proceed() and move_count < n_moves_per_pass:
        # Advance y_grid by y_incr
        y_grid = y_grid + y_incr
  
        # Move to the corresponding position
        p1 = pose_trans(p0, p[0, 0, 0, x_grid * grid_drx_rad, y_grid * grid_dry_rad, 0])
        movel_int(p1, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, r = grind_rot_blend_radius_rad, t_move = t_move_ry / n_rysteps)
  
        # Adjust y direction
        if y_grid >= n_rysteps:
          y_incr = -1
        elif y_grid <= 0:
          y_incr = 1
        end
        move_count = move_count + 1
      end
  
      # Detect when we've covered all the grid squares!
      if move_count >= n_moves_per_pass:
        grind_cycle = grind_cycle + 1
        move_count = 0
      end
    end
    pattern_complete()
  end
  
  
  ######################################################################################
  # CIRCULAR PATTERNS
  #
  
  # What is a good number of points to use for a circular pattern?
  def recommend_npoints(diam_m, blend_radius_m):
    circum_m = diam_m * MATH_PI
    if blend_radius_m > 0:
      # How many blend_radii to cover the circumference
      n_points = ceil(circum_m / blend_radius_m)
    else:
      # Blend radius is 0... model would be 10 points for a 10mm diameter (1000 points for 1m diameter!)
      n_points = ceil(diam_m * 1000.0)
    end
    return limiter(n_points, 1, 100)
  end
  
  # Grind along a flat circle circle_diam_m centered on p_center. Repeat n_cycles times.
  def pattern_circle_flat(p_center, circle_diam_m, n_cycles):
  
    # Local calculations
    n_points = recommend_npoints(circle_diam_m, grind_blend_radius_m)
    circle_radius_m = circle_diam_m / 2.0
  
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      socket_set_var("grind_cycle", grind_cycle)
      i = 0
      while ok_to_proceed() and i <= n_points:
        theta = d2r(180.0 + 360.0 * i / n_points)
        x = circle_radius_m * cos(theta)
        y = circle_radius_m * sin(theta)
  
        p1 = pose_trans(p_center, p[x, y, 0, 0, 0, 0])
        movel(p1, a = grind_accel_mpss, v = grind_speed_mps, r = grind_blend_radius_m)
        i = i + 1
      end
  
      grind_cycle = grind_cycle + 1
    end
    pattern_complete()
  end
  
  # Move along a cylindrical circle circle_diam_m on a cylinder_diam_m object starting at the current tool position. Repeat n_cycles times.
  def pattern_circle_cylinder(p_center, circle_diam_m, cylinder_radius_m, n_cycles):
  
    # Local calculations
    n_points = recommend_npoints(circle_diam_m, grind_blend_radius_m)
    circle_radius_m = circle_diam_m / 2.0
    speed_factor = 0.5 / (robot_part_geometry[1] / 1000.0)
  
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      socket_set_var("grind_cycle", grind_cycle)
      i = 0
      while ok_to_proceed() and i <= n_points:
        theta = d2r(180.0 + 360.0 * i / n_points)
        x = circle_radius_m * cos(theta)
        y = circle_radius_m * sin(theta)
        rx = 2.0 * y / cylinder_radius_m
  
        p1 = pose_trans(p_center, p[x, 0, 0, rx, 0, 0])
        # Speed_factor needs to be applied when running radially, and needs to be 1.0 when running laterally. This smooths it all the way around!
        global this_speed_factor = (speed_factor - 1) * abs(cos(theta)) + 1.0
        movel(p1, a = grind_accel_mpss * this_speed_factor, v = grind_speed_mps * this_speed_factor, r = grind_blend_radius_m)
        i = i + 1
      end
  
      grind_cycle = grind_cycle + 1
    end
    pattern_complete()
  end
  
  # Move along a spherical circle circle_diam_m on a sphere_diam_m object starting at the current tool position. Repeat n_cycles times.
  def pattern_circle_sphere(p_center, circle_diam_m, sphere_diam_m, n_cycles):
    # Local calculations
    n_points = recommend_npoints(circle_diam_m, grind_blend_radius_m)
    circle_radius_m = circle_diam_m / 2.0
    sphere_radius_m = sphere_diam_m / 2.0
  
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      socket_set_var("grind_cycle", grind_cycle)
      i = 0
      while ok_to_proceed() and i <= n_points:
        theta = d2r(180.0 + 360.0 * i / n_points)
        x = circle_radius_m * cos(theta)
        rx = x / sphere_radius_m
        y = circle_radius_m * sin(theta)
        ry = y / sphere_radius_m
  
        p1 = pose_trans(p_center, p[0, 0, 0, rx, ry, 0])
        movel(p1, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, r = grind_rot_blend_radius_rad)
        i = i + 1
      end
  
      grind_cycle = grind_cycle + 1
    end
    pattern_complete()
  end
  
  
  ######################################################################################
  # SPIRAL PATTERNS
  #
  
  def pattern_spiral_flat(p_center, circle1_diam_m, circle2_diam_m, n_spirals, n_cycles):
    # Local calculations
    max_diam_m = max(circle1_diam_m, circle2_diam_m)
    n_points = recommend_npoints(max_diam_m, grind_blend_radius_m)
    n_total_points = n_spirals * n_points
    circle1_radius_m = circle1_diam_m / 2.0
    circle2_radius_m = circle2_diam_m / 2.0
  
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      socket_set_var("grind_cycle", grind_cycle)
      rslope = (circle2_radius_m - circle1_radius_m) / n_total_points
      i = 0
      while ok_to_proceed() and i <= n_total_points:
        theta = d2r(180.0 + 360.0 * (i % n_points) / n_points)
        r_instantaneous = i * rslope + circle1_radius_m
        x = r_instantaneous * cos(theta)
        y = r_instantaneous * sin(theta)
  
        p1 = pose_trans(p_center, p[x, y, 0, 0, 0, 0])
        movel(p1, a = grind_accel_mpss, v = grind_speed_mps, r = grind_blend_radius_m)
        i = i + 1
      end
  
      grind_cycle = grind_cycle + 1
      # Next cycle- swap diameters so we go in/out/in etc.
      old_circle1_radius_m = circle1_radius_m
      circle1_radius_m = circle2_radius_m
      circle2_radius_m = old_circle1_radius_m
    end
    pattern_complete()
  end
  
  def pattern_spiral_cylinder(p_center, circle1_diam_m, circle2_diam_m, n_spirals, cylinder_radius_m, n_cycles):
    # Local calculations
    max_diam_m = max(circle1_diam_m, circle2_diam_m)
    n_points = recommend_npoints(max_diam_m, grind_blend_radius_m)
    n_total_points = n_spirals * n_points
    circle1_radius_m = circle1_diam_m / 2.0
    circle2_radius_m = circle2_diam_m / 2.0
    speed_factor = 0.5 / (robot_part_geometry[1] / 1000.0)
  
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      socket_set_var("grind_cycle", grind_cycle)
      rslope = (circle2_radius_m - circle1_radius_m) / n_total_points
      i = 0
      while ok_to_proceed() and i <= n_total_points:
        theta = d2r(180.0 + 360.0 * (i % n_points) / n_points)
        r_instantaneous = i * rslope + circle1_radius_m
        x = r_instantaneous * cos(theta)
        y = r_instantaneous * sin(theta)
        rx = 2.0 * y / cylinder_radius_m
  
        p1 = pose_trans(p_center, p[x, 0, 0, rx, 0, 0])
  
        # Speed_factor needs to be applied when running radially, and needs to be 1.0 when running laterally. This smooths it all the way around!
        global this_speed_factor = (speed_factor - 1) * abs(cos(theta)) + 1.0
        movel(p1, a = grind_accel_mpss * this_speed_factor, v = grind_speed_mps * this_speed_factor, r = grind_blend_radius_m)
        i = i + 1
      end
  
      grind_cycle = grind_cycle + 1
      # Next cycle- swap diameters so we go in/out/in etc.
      old_circle1_radius_m = circle1_radius_m
      circle1_radius_m = circle2_radius_m
      circle2_radius_m = old_circle1_radius_m
    end
    pattern_complete()
  end
  
  def pattern_spiral_sphere(p_center, circle1_diam_m, circle2_diam_m, n_spirals, sphere_diam_m, n_cycles):
    # Local calculations
    max_diam_m = max(circle1_diam_m, circle2_diam_m)
    n_points = recommend_npoints(max_diam_m, grind_blend_radius_m)
    n_total_points = n_spirals * n_points
    circle1_radius_m = circle1_diam_m / 2.0
    circle2_radius_m = circle2_diam_m / 2.0
    sphere_radius_m = sphere_diam_m / 2.0
  
    global grind_cycle = 1
    while (ok_to_proceed() and grind_cycle <= n_cycles):
      socket_set_var("grind_cycle", grind_cycle)
      rslope = (circle2_radius_m - circle1_radius_m) / n_total_points
      i = 0
      while ok_to_proceed() and i <= n_total_points:
        theta = d2r(180.0 + 360.0 * (i % n_points) / n_points)
        r_instantaneous = i * rslope + circle1_radius_m
        x = r_instantaneous * cos(theta)
        rx = x / sphere_radius_m
        y = r_instantaneous * sin(theta)
        ry = y / sphere_radius_m
  
        p1 = pose_trans(p_center, p[0, 0, 0, rx, ry, 0])
        movel(p1, a = grind_rot_accel_rpss, v = grind_rot_speed_rps, r = grind_rot_blend_radius_rad)
        i = i + 1
      end
  
      grind_cycle = grind_cycle + 1
      # Next cycle- swap diameters so we go in/out/in etc.
      old_circle1_radius_m = circle1_radius_m
      circle1_radius_m = circle2_radius_m
      circle2_radius_m = old_circle1_radius_m
    end
    pattern_complete()
  end
  $ 5 "currentTcpPose≔get_actual_tcp_pose()"
  global currentTcpPose= get_actual_tcp_pose ()
  $ 6 "MoveJ"
  $ 7 "currentTcpPose" "breakAfter"
  movej(currentTcpPose, a=1.3962634015954636, v=1.0471975511965976)
  $ 10 "socket_is_open≔ False "
  global socket_is_open=  False  
  while (True):
    $ 11 "Robot Program"
    $ 12 "Loop socket_is_open ≟  False "
    while (socket_is_open  ==    False  ):
      $ 13 "Wait: 0.25"
      sleep(0.25)
      $ 14 "socket_close()"
      socket_close()
      $ 15 "socket_is_open≔socket_open('169.254.254.200', 30000)"
      global socket_is_open=socket_open("169.254.254.200", 30000)
      $ 16 "If not socket_is_open"
      if (not socket_is_open):
        $ 17 "socket_is_open≔socket_open('169.254.254.210', 30000)"
        global socket_is_open=socket_open("169.254.254.210", 30000)
      end
      $ 18 "If not socket_is_open"
      if (not socket_is_open):
        $ 19 "socket_is_open≔socket_open('192.168.0.121', 30000)"
        global socket_is_open=socket_open("192.168.0.121", 30000)
      end
    end
    $ 20 "response≔'Unknown command'"
    global response="Unknown command"
    $ 21 "command≔socket_read_ascii_float(12)"
    global command=socket_read_ascii_float(12)
    $ 22 "If command_validate()"
    if (command_validate()):
      $ 23 "command_start()"
      command_start()
      $ 24 "Set Stacklight=On"
      set_standard_digital_out(0, True)
      $ 25 "Switch command[1]"
      switch_1 = command[1]
      $ 26 "Case 10"
      if (10 == switch_1):
        $ 27 "return_actual_tcp_pose()"
        return_actual_tcp_pose()
      elif (12 == switch_1):
        $ 28 "Case 12"
        $ 29 "return_tcp_offset()"
        return_tcp_offset()
      elif (13 == switch_1):
        $ 30 "Case 13"
        $ 31 "movel_relative_base(p[command[2], command[3], command[4], command[5], command[6], command[7]])"
        movel_relative_base(p[command[2], command[3], command[4], command[5], command[6], command[7]])
      elif (14 == switch_1):
        $ 32 "Case 14"
        $ 33 "movel_relative_tcp(p[command[2], command[3], command[4], command[5], command[6], command[7]])"
        movel_relative_tcp(p[command[2], command[3], command[4], command[5], command[6], command[7]])
      elif (15 == switch_1):
        $ 34 "Case 15"
        $ 35 "movel_relative_tcp_part(p[command[2], command[3], command[4], command[5], command[6], command[7]])"
        movel_relative_tcp_part(p[command[2], command[3], command[4], command[5], command[6], command[7]])
      elif (16 == switch_1):
        $ 36 "Case 16"
        $ 37 "movel_one_only(command[2],command[3])"
        movel_one_only(command[2],command[3])
      elif (18 == switch_1):
        $ 38 "Case 18"
        $ 39 "movel_rot_only(command[2],command[3],command[4])"
        movel_rot_only(command[2],command[3],command[4])
      elif (20 == switch_1):
        $ 40 "Case 20"
        $ 41 "return_get_actual_joint_positions()"
        return_get_actual_joint_positions()
      elif (21 == switch_1):
        $ 42 "Case 21"
        $ 43 "movej_ag([command[2], command[3], command[4], command[5], command[6], command[7]])"
        movej_ag([command[2], command[3], command[4], command[5], command[6], command[7]])
      elif (22 == switch_1):
        $ 44 "Case 22"
        $ 45 "movel_ag(p[command[2], command[3], command[4], command[5], command[6], command[7]])"
        movel_ag(p[command[2], command[3], command[4], command[5], command[6], command[7]])
      elif (25 == switch_1):
        $ 46 "Case 25"
        $ 47 "return_both_positions()"
        return_both_positions()
      elif (30 == switch_1):
        $ 48 "Case 30"
        $ 49 "set_variable()"
        set_variable()
      elif (35 == switch_1):
        $ 50 "Case 35"
        $ 51 "set_grind_variable()"
        set_grind_variable()
      elif (40 == switch_1):
        $ 52 "Case 40"
        $ 53 "grind()"
        grind()
      elif (50 == switch_1):
        $ 54 "Case 50"
        $ 55 "Call AG_50"
        AG_50()
      elif (98 == switch_1):
        $ 56 "Case 98"
        $ 57 "response≔'socket reset'"
        global response="socket reset"
      elif (99 == switch_1):
        $ 58 "Case 99"
        $ 59 "response≔'exiting'"
        global response="exiting"
      else:
        $ 60 "Default Case"
        $ 61 "response≔'unknown command'"
        global response="unknown command"
      end
      $ 62 "command_finish()"
      command_finish()
      $ 63 "Set Stacklight=Off"
      set_standard_digital_out(0, False)
      $ 64 "If command[1]≟98"
      if (command[1] == 98):
        $ 65 "Wait: 0.5"
        sleep(0.5)
        $ 66 "socket_close()"
        socket_close()
        $ 67 "socket_is_open≔ False "
        global socket_is_open=  False  
      end
      $ 68 "If command[1]≟99"
      if (command[1] == 99):
        $ 69 "Wait: 0.5"
        sleep(0.5)
        $ 70 "socket_close()"
        socket_close()
        $ 71 "socket_is_open≔ False "
        global socket_is_open=  False  
        $ 72 "Halt"
        halt
      end
    else:
      $ 73 "Else" "noBreak"
      $ 74 "no_command()"
      no_command()
    end
  end
end
