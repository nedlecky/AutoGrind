# File: agscript_grind-2.script
# Project: AutoGrind Code Rev 2 IMOVER
# Author: Ned Lecky, Lecky Engineering LLC
# Purpose: All grinding functions used in AutoGrind

global grind_version = "Rev 2 2022-06-07"

global grind_abort_listener_thread_handle = 0
global pattern_grind_thread_handle = 0

global halt_count = 0
global halt_command = [0, 0, 0, 0]

global grind_ready = True
# grind_contact_enable:  0=No Contact   1=Touch but no tool/coolant on or force  2=Touch, Tool, Coolant, and Force
global grind_contact_enable = 0
global grind_touch_retract_mm = 3       # How far to retract after touch  (we do 2X this for ghrind_contact_enable=1)
global grind_touch_speed_mmps = 0.1     # How fast to go in for the touch
global grind_force_dwell_ms = 500       # How long to dwell after turning force more on
global grind_max_blend_radius_m = 0.010 # Max blend radius to use while grinding
global grind_blend_radius_m = 0.001     # Current blend radius to use while grinding
global grind_trial_speed_mmps = 20      # Grinding speed when not really grinding!
global grind_accel_mmpss = 100          # Acceleration to use in grinding moves
global grind_point_frequency_hz = 4     # Points per second to generate in grind_movel

# Planning points
global p_operator_init = p[0, 0, 0, 0, 0, 0]    # Where we were when operator issued first grind command
global p_contact_init = p[0, 0, 0, 0, 0, 0]     # Where we first contacted the part
global dp_from_contact_center = p[0, 0, 0, 0, 0, 0]   # How did we offset from p_operator_int prior to contact?
global p_contact_center = p[0, 0, 0, 0, 0, 0]   # Computed where center of pattern would be in contact with part

MATH_PI = 3.1415926535

# Set global grind_n_cycles based on whether we really going to grind
def n_cycle_setter(n_cycles):
  if grind_contact_enable == 2:
    global grind_n_cycles = limiter(n_cycles, 0, 100)
  else:
    global grind_n_cycles = limiter(n_cycles, 0, 1)
  end
  socket_set_var("grind_n_cycles", grind_n_cycles)
end

# Set all speed and acceleration globals based on part geometry and whether we really going to grind
def speed_setter(speed_mmps, min_feature_mm, is_circle = False):
  speed_mmps = limiter(speed_mmps, 0.1, 200)

  # Figure out best blend radius to use
  global grind_min_feature_m = min_feature_mm / 1000.0
  global grind_blend_radius_m = min(grind_max_blend_radius_m, grind_min_feature_m / 4)
  if is_circle:
    if grind_blend_radius_m < 0.0015:
      grind_blend_radius_m = 0
    end
  else:
    if grind_blend_radius_m < 0.0015:
      grind_blend_radius_m = 0
    end
  end

  if grind_contact_enable == 2:
    global grind_speed_mps = speed_mmps / 1000.0
  else:
    global grind_speed_mps = grind_trial_speed_mmps / 1000.0
  end
  global grind_accel_mpss = grind_accel_mmpss / 1000.0

  # Default rotational speeds same as linear
  global grind_rot_speed_rps = 0
  global grind_rot_accel_rpss = 0
  global grind_rot_blend_radius_rad = 0

  # If part is cylinder or spherical, diameter will be >0
  local diam_m = robot_part_geometry[1] / 1000.0
  if diam_m > 0.0:
    # These are 1/4 the theoretical rotational speeds but we need to set them like this to get the correct speed- why??????
    local coeff = 0.5 # Used to be 0.5 and inexplicable
    global grind_rot_speed_rps = grind_speed_mps * coeff / diam_m
    global grind_rot_accel_rpss = grind_accel_mpss * coeff / diam_m
    global grind_rot_blend_radius_rad = grind_blend_radius_m * coeff / diam_m
  end
end

# Set grind variables chosen by command[2]
# Value after set is always returned to socket
def set_grind_variable():
  global grind_ready = False
  socket_send_line("grind_ready=False")

  if command[2] == 1:
    global response = "set grind_contact_enable"
    if command[3] >= 0 and command[3] <= 2:
      global grind_contact_enable = ceil(command[3])
    end
    socket_set_var("grind_contact_enable", grind_contact_enable)
  elif command[2] == 2:
    global response = "set grind_touch_retract_mm"
    if command[3] >= 0:
      global grind_touch_retract_mm = ceil(command[3])
    end
    socket_set_var("grind_touch_retract_mm", grind_touch_retract_mm)
  elif command[2] == 3:
    global response = "set grind_touch_speed_mmps"
    if command[3] >= 0:
      global grind_touch_speed_mmps = ceil(command[3])
    end
    socket_set_var("grind_touch_speed_mmps", grind_touch_speed_mmps)
  elif command[2] == 4:
    global response = "set grind_force_dwell_ms"
    if command[3] >= 0:
      global grind_force_dwell_ms = ceil(command[3])
    end
    socket_set_var("grind_force_dwell_ms", grind_force_dwell_ms)
  elif command[2] == 5:
    global response = "set grind_max_wait_ms"
    if command[3] >= 0:
      global grind_max_wait_ms = ceil(command[3])
    end
    socket_set_var("grind_max_wait_ms", grind_max_wait_ms)
  elif command[2] == 6:
    global response = "set grind_max_blend_radius_mm"
    if command[3] >= 0:
      global grind_max_blend_radius_m = command[3] / 1000.0
    end
    socket_send_string("grind_max_blend_radius_mm=")
    socket_send_string(grind_max_blend_radius_m * 1000.0)
    socket_send_lf()
  elif command[2] == 7:
    global response = "set grind_trial_speed_mmps"
    if command[3] > 0:
      global grind_trial_speed_mmps = ceil(command[3])
    end
    socket_set_var("grind_trial_speed_mmps", grind_trial_speed_mmps)
  elif command[2] == 8:
    global response = "set grind_accel_mmpss"
    if command[3] > 0:
      global grind_accel_mmpss = ceil(command[3])
    end
    socket_set_var("grind_accel_mmpss", grind_accel_mmpss)
  elif command[2] == 9:
    global response = "set grind_point_frequency_hz"
    if command[3] >= 0:
      global grind_point_frequency_hz = ceil(command[3])
    end
    socket_set_var("grind_point_frequency_hz", grind_point_frequency_hz)
  else:
    global response = "Unknown grind set variable command"
  end

  global grind_ready = True
  socket_send_line("grind_ready=True")
end

# Execute the desired grind operation as specified in command[2]...
def grind():
  global grind_ready = False
  socket_send_line("grind_ready=False")

  # Start listening for abort commands from host
  if grind_abort_listener_thread_handle > 0:
    kill grind_abort_listener_thread_handle
    grind_abort_listener_thread_handle = 0
  end
  grind_abort_listener_thread_handle = run grind_abort_listener_thread()

  global grind_cycle = 0
  socket_set_var("grind_cycle", grind_cycle)

  # Install tcp that puts tcp at center of part (noop for flat parts!)
  iset_tcp(robot_tcp_part)

  if command[2] == 10:
    # LINEAR GRIND
    global response = "grind_line"
    global grind_dx_mm = limiter(command[3], -1000, 1000)
    global grind_dy_mm = limiter(command[4], -1000, 1000)
    n_cycle_setter(command[5])
    speed_setter(command[6], 0)
    global grind_force_n = limiter(command[7], 0, 100)
    global grind_continue = command[8] > 0
    imover_realtime(True)
    grind_line(grind_dx_mm, grind_dy_mm, grind_n_cycles, grind_continue)

  elif command[2] == 20:
    # RECTANGULAR GRIND
    global response = "grind_rect"
    global grind_dx_mm = limiter(command[3], 0, 1000)
    global grind_dy_mm = limiter(command[4], 0, 1000)
    n_cycle_setter(command[5])
    speed_setter(command[6], min(grind_dx_mm, grind_dy_mm))
    global grind_force_n = limiter(command[7], 0, 100)
    global grind_continue = command[8] > 0
    imover_realtime(True)
    grind_rect(grind_dx_mm, grind_dy_mm, grind_n_cycles, grind_continue)

  elif command[2] == 30:
    # SERPENTINE GRIND
    global response = "grind_serpentine"
    global grind_dx_mm = limiter(command[3], 0, 1000)
    global grind_dy_mm = limiter(command[4], 0, 1000)
    global grind_n_xsteps = limiter(command[5], 1, grind_dx_mm)
    global grind_n_ysteps = limiter(command[6], 1, grind_dy_mm)
    n_cycle_setter(command[7])
    local min_feature_mm = min(grind_dx_mm / grind_n_xsteps, grind_dy_mm / grind_n_ysteps)
    speed_setter(command[8], min_feature_mm)
    global grind_force_n = limiter(command[9], 0, 10)
    global grind_continue = command[10] > 0
    imover_realtime(True)
    grind_serpentine(grind_dx_mm, grind_dy_mm, grind_n_xsteps, grind_n_ysteps, grind_n_cycles, grind_continue)

  elif command[2] == 40:
    # POLYGON GRIND
    global response = "grind_poly"
    global grind_circle1_diam_mm = limiter(command[3], 0, 1000)
    global grind_n_sides = limiter(command[4], 1, 1000)
    n_cycle_setter(command[5])
    local min_feature_mm = max(2, grind_circle1_diam_mm)
    speed_setter(command[6], min_feature_mm)
    global grind_force_n = limiter(command[7], 0, 100)
    global grind_continue = command[8] > 0
    imover_realtime(True)
    grind_poly(grind_circle1_diam_mm, grind_n_sides, grind_n_cycles, grind_continue)

  elif command[2] == 45:
    # CIRCULAR GRIND
    global response = "grind_circle"
    global grind_circle1_diam_mm = limiter(command[3], 0, 1000)
    n_cycle_setter(command[4])
    local min_feature_mm = max(2, grind_circle1_diam_mm)
    speed_setter(command[5], min_feature_mm, is_circle = True)
    global grind_force_n = limiter(command[6], 0, 100)
    global grind_continue = command[7] > 0
    imover_realtime(False)
    grind_circle(grind_circle1_diam_mm, grind_n_cycles, grind_continue)
    imover_realtime(True)

  elif command[2] == 50:
    # SPIRAL GRIND
    global response = "grind_spiral"
    global grind_circle1_diam_mm = limiter(command[3], 0, 1000)
    global grind_circle2_diam_mm = limiter(command[4], 0, 1000)
    global grind_n_revolutions = limiter(command[5], 1, 100)
    n_cycle_setter(command[6])
    local min_diam_mm = min(grind_circle1_diam_mm, grind_circle2_diam_mm)
    local min_feature_mm = max(2, min_diam_mm)
    speed_setter(command[7], min_feature_mm, is_circle = True)
    global grind_force_n = limiter(command[8], 0, 100)
    global grind_continue = command[9] > 0
    imover_realtime(False)
    grind_spiral(grind_circle1_diam_mm, grind_circle2_diam_mm, grind_n_revolutions, grind_n_cycles, grind_continue)
    imover_realtime(True)

  elif command[2] == 99:
    # RETRACT COMMAND
    global response = "grind_retract"
    set_grind_process_state(False)

  else:
    # Illegal grind command
    global response = "Unknown grind command"
  end

  # Restore tool-only tcp
  iset_tcp(robot_tcp)

  # Stop listening for abort commands from host
  if grind_abort_listener_thread_handle > 0:
    kill grind_abort_listener_thread_handle
    grind_abort_listener_thread_handle = 0
  end

  global grind_ready = True
  socket_send_line("grind_ready=True")
end

# Get into contact with part (or away from it)
# enable:  0=No Contact   1=Touch but no tool/coolant on or force  2=Touch, Tool, Coolant, and Force
def contact_part(on = False, enable = 0):
  if on:
    if enable == 0:
      # Just do a small forward motion in the direction of touchoff- this is a simulated p_contact_init
      global p_contact_init = pose_trans(iget_actual_tcp_pose(), p[0, 0, 0.005, 0, 0, 0])
      imovel(p_contact_init, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
    elif enable == 1:
      # Advance until contact but retract 2X grind distance and use this as a simulated p_contact_init
      local success = itouchoff(grind_touch_speed_mmps, grind_touch_retract_mm * 2.0)
      global p_contact_init = iget_actual_tcp_pose()
      return success
    elif enable == 2:
      # Advance until contact
      local success = itouchoff(grind_touch_speed_mmps, grind_touch_retract_mm)
      # Touchoff has backed off by grind_touch_retract_mm so we need to compute that actual p_contact_init
      global p_contact_init = pose_trans(iget_actual_tcp_pose(), p[0, 0, grind_touch_retract_mm / 1000.0, 0, 0, 0])
      return success
    end
  else:  # Back off
    local p1 = pose_trans(iget_actual_tcp_pose(), p[0, 0, -0.010, 0, 0, 0])
    imovel(p1, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
  end

  return True
end

# Sets digital outpus based 8-element list of 4 pairs DOUT#,State.  -1 indicates unused slot
def set_digital_output_list(list):
  i = 0
  while i < 8:
    if list[i] >= 0:
      b = list[i + 1] == 1
      set_digital_out(list[i], b)
    end
    i = i + 2
  end
end

# Turn tool power on/off if enable=2
def tool_power(on = False, enable = 0):
  if enable < 2:
    return None
  end

  if on:
    # ON IO
    set_digital_output_list(robot_tool_on_outputs)
  else:
    # OFF IO
    set_digital_output_list(robot_tool_off_outputs)
  end

  return None
end

# Turn coolant on/off if enable=2
def coolant_flow(on = False, enable = 0):
  if enable < 2:
    return None
  end

  if on:
    # ON IO
    set_digital_output_list(robot_coolant_on_outputs)
  else:
    # OFF IO
    set_digital_output_list(robot_coolant_off_outputs)
  end

  return None
end

# Turn force mode on/off if enable=2
def apply_force(on = False, enable = 0, force_n = 5, approach_speed_mmps = 10):
  if enable < 2:
    return None
  end

  if on:
    iforce_mode(force_n, approach_speed_mmps)
    sleep(grind_force_dwell_ms / 1000.0)
  else:
    iend_force_mode()
    sleep(0.1)
  end

  return None
end

# Update force applied only
def update_force(on = False, enable = 0, force_n = 5, approach_speed_mmps = 10):
  if enable < 2:
    return None
  end

  if on:
    iforce_update(force_n, approach_speed_mmps)
  end

  return None
end

# Start/Stop Grinding
# Pose to center is the offset we should move to initial touch point [0]=FLAT [1]=CYLINDER [2]=SPHERE
global grind_process_state = False
def set_grind_process_state(on = False, pose_to_center = [p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0]]):
  if on and grind_process_state:
    # Continuing a grind...
    # Move to initial grind position relative to initial p_contact_center
    shape = robot_part_geometry[0]
    if shape < 1 or shape > 3:
      return False
    end
    global dp_from_contact_center = pose_to_center[shape-1]
    grind_to(dp_from_contact_center, r = 0)

    update_force(True, grind_contact_enable, grind_force_n, grind_touch_speed_mmps)
  elif on and not grind_process_state:
    # Need to start the grind
    global p_operator_init = iget_actual_tcp_pose()

    # Move to start position for touchoff
    shape = robot_part_geometry[0]
    if shape < 1 or shape > 3:
      return False
    end

    global dp_from_contact_center = pose_to_center[shape-1]
    local p1 = pose_trans(p_operator_init, dp_from_contact_center)
    # TODO This should look at whether rot or linear for speed,accel
    imovel(p1, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)

    # Touch part and set p_contact_init
    if not contact_part(True, grind_contact_enable):
      # Failure to contact part should abort... don't set grind_process_state and return False
      imovel(p_operator_init, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
      socket_send_line("grind_process_state=False")
      return False
    end

    # Compute p_contact_center... where we would have been if we had touched off from the operator teach position!
    local  reverse_pose_to_center = pose_to_center[shape-1]
    local i = 0
    while i < 6:
      reverse_pose_to_center[i] = -reverse_pose_to_center[i]
      i = i + 1
    end
    global p_contact_center = pose_trans(p_contact_init, reverse_pose_to_center)
    grind_start(dp_from_contact_center)

    # Now power everything on (although these will do nothing unless contact_enable==2)
    tool_power(True, grind_contact_enable)
    coolant_flow(True, grind_contact_enable)
    apply_force(True, grind_contact_enable, grind_force_n, grind_touch_speed_mmps)
    global grind_process_state = True
  elif not on and grind_process_state:
    # Need to stop the grind
    # Shut everything down and return to original pose
    apply_force(False, grind_contact_enable, 0)
    contact_part(False, grind_contact_enable)
    coolant_flow(False, grind_contact_enable)
    tool_power(False, grind_contact_enable)
    imovel(p_operator_init, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
    global grind_process_state = False
  end

  # Always let the host know status
  if grind_process_state:
    socket_send_line("grind_process_state=True")
  else:
    socket_send_line("grind_process_state=False")
  end
  return True
end

######################################################################################
# Thread to listen for abort messages while grinding
#
global grind_force_report_counter = 0
global grind_force_report = p[0, 0, 0, 0, 0, 0]
global grind_force_report_z_n = 0
thread grind_abort_listener_thread():
  global halt_command = [0, 0, 0, 0]
  global halt_count = 0
  global grind_force_report_counter = 0
  global grind_force_readings_n = 5
  global grind_force_readings = [0., 0., 0., 0., 0.]

  # Initialize force readings array
  local i = 0
  while i < grind_force_readings_n:
    local f = get_tcp_force()
    grind_force_readings[i] = f[2]
    i = i + 1
  end
  global grind_force_report_z_n = grind_force_readings[grind_force_readings_n-1]
  global grind_force_filtered_z_n = grind_force_report_z_n


  while (halt_count == 0):
    # Commands should never arrive, so this will block us for 0.2s
    global halt_command = socket_read_ascii_float(3, timeout = 0.2)

    # If door is open, that adds a halt count (anything >0 will stop us!)
    if not is_door_closed():
      global halt_count = halt_count + 1
    end

    # If we've received(index,checksum,10,...) that adds a halt count (as long as checksum matches)
    if halt_command[0] > 2:
      global test_index = halt_command[1]
      global test_checksum = halt_command[2]
      global test_command = halt_command[3]

      if test_checksum == 1000 - test_index and test_command == 10:
        global halt_count = halt_count + 1

        # Send an start/finish acknowledgement just for this command!
        socket_set_var("robot_starting", test_index)
        socket_set_var("robot_completed", test_index)
      end
    end

    # Increment reading counter (10000 is high enough... don't need to worry about wraparound effects)
    grind_force_report_counter = grind_force_report_counter + 1
    if grind_force_report_counter > 10000:
      grind_force_report_counter = 0
    end

    # Store force in circular buffer
    local force = get_tcp_force()
    grind_force_readings[grind_force_report_counter % grind_force_readings_n] = force[2]

    # Report force periodically (This executes at 5Hz because of timeout=0.2 in socket_read_ascii_float(...)
    if grind_force_report_counter % 5 == 0:
      # Compute average of the stored readings
      local i = 0
      local sum = 0.0
      while i < grind_force_readings_n:
        sum = sum + grind_force_readings[i]
        i = i + 1
      end
      global grind_force_average_z_n = sum / grind_force_readings_n

      # Any other filtering could be done here...
      # Round to 2 DP
      global grind_force_report_z_n = ceil(grind_force_average_z_n*100)/100

      socket_send_string("grind_force_report_z_n=")
      socket_send_string(grind_force_report_z_n)
      socket_send_lf()
    end
  end
  return None
end

# Should we proceed? halt_count==0 means no door-opens and no abort commands from host
def ok_to_proceed():
  return halt_count == 0
end
#
# Thread to listen for abort messages while grinding
######################################################################################


######################################################################################
# TOP LEVEL GRIND FUNCTIONS
#
# Grind along a line dx_mm x dy_mm centered on current tool position. Repeat n_cycles times. If stay_in_contact, stay_in_contact at end.
def grind_line(dx_mm, dy_mm, n_cycles, stay_in_contact):
  if n_cycles < 1:
    return True
  end

  # Unit conversion
  dx_m = dx_mm / 1000.0
  dy_m = dy_mm / 1000.0
  radius_m = robot_part_geometry[1] / 2000.0
  drx_rad = dx_m / radius_m
  dry_rad = dy_m / radius_m

  # Grind time estimate
  time_ms = sqrt(dx_mm * dx_mm + dy_mm * dy_mm) * n_cycles / grind_speed_mps + 1500
  socket_set_var("robot_step_time_estimate_ms", time_ms)

  # Swapping sphere axes here since RY is aligned with the X of the FLAT and CYLINDER geometries
  if not set_grind_process_state(True,
    [
      p[-dx_m / 2.0, -dy_m / 2.0, 0, 0, 0, 0],
      p[-dx_m / 2.0, 0, 0, -dry_rad / 2.0, 0, 0],
      p[0, 0, 0, -dry_rad / 2.0, -drx_rad / 2.0, 0]
    ]):
    return False
  end

  # Grind the pattern
  shape = robot_part_geometry[0]
  if shape == 1:
    pattern_line_flat(dx_m, dy_m, n_cycles)
  elif shape == 2:
    pattern_line_cylinder(dx_m, dry_rad, n_cycles)
  elif shape == 3:
    # Swapping axes here since RY is aligned with the X of the FLAT and CYLINDER geometries
    pattern_line_sphere(dry_rad, drx_rad, n_cycles)
  end

  if not stay_in_contact or not ok_to_proceed():
    set_grind_process_state(False)
  end
  return True
end

# Grind along a rect dx_mm x dy_mm centered on current tool position. Repeat n_cycles times. If stay_in_contact, stay_in_contact at end.
# Move in x direction first, then y
def grind_rect(dx_mm, dy_mm, n_cycles, stay_in_contact):
  if n_cycles < 1:
    return True
  end

  # Unit conversion
  dx_m = dx_mm / 1000.0
  dy_m = dy_mm / 1000.0
  diam_m = robot_part_geometry[1] / 1000.0
  radius_m = diam_m / 2.0
  drx_rad = dx_m / radius_m
  dry_rad = dy_m / radius_m

  # Grind time estimate
  time_ms = 2 * (dx_mm + dy_mm) * n_cycles / grind_speed_mps + 1500
  socket_set_var("robot_step_time_estimate_ms", time_ms)

  # Swapping sphere axes here since RY is aligned with the X of the FLAT and CYLINDER geometries
  # 4-point Version
  #if not set_grind_process_state(True,
  #  [
  #    p[-dx_m / 2.0, -dy_m / 2.0, 0, 0, 0, 0],
  #    p[-dx_m / 2.0, 0, 0, -dry_rad / 2.0, 0, 0],
  #    p[0, 0, 0, -dry_rad / 2.0, -drx_rad / 2.0, 0]
  #  ]):
  #  return False
  #end

  # 8-point Version
  if not set_grind_process_state(True,
    [
      p[-dx_m / 2.0 + grind_blend_radius_m * 2, -dy_m / 2.0, 0, 0, 0, 0],
      p[-dx_m / 2.0 + grind_blend_radius_m * 2, 0, 0, -dry_rad / 2.0, 0, 0],
      p[0, 0, 0, -dry_rad / 2.0 + grind_rot_blend_radius_rad * 8, -drx_rad / 2.0, 0]
    ]):
    return False
  end

  # Grind the pattern
  shape = robot_part_geometry[0]
  if shape == 1:
    pattern_rect_flat(dx_m, dy_m, n_cycles)
  elif shape == 2:
    pattern_rect_cylinder(dx_m, dry_rad, n_cycles)
  elif shape == 3:
    # Swapping sphere axes here since RY is aligned with the X of the FLAT and CYLINDER geometries
    pattern_rect_sphere(dry_rad, drx_rad, n_cycles)
  end

  if not stay_in_contact or not ok_to_proceed():
    set_grind_process_state(False)
  end
  return True
end

# Grind along a rect in serpentine dx_mm,dy_mm incrementing by xstep_mm,ystep_mm centered on current tool position. Repeat n_cycles times. If stay_in_contact, stay_in_contact at end.
# Move in x direction first, then y
def grind_serpentine(dx_mm, dy_mm, n_xsteps, n_ysteps, n_cycles, stay_in_contact):
  if n_cycles < 1:
    return True
  end

  # Either n_xsteps or n_ysteps must be 1. Whichever one is one will be the direction of the first move.
  if n_xsteps != 1 and n_ysteps != 1:
    return False
  end

  # Unit conversion
  dx_m = dx_mm / 1000.0
  dy_m = dy_mm / 1000.0
  part_radius_m = robot_part_geometry[1] / 2000.0
  drx_rad = dx_m / part_radius_m
  dry_rad = dy_m / part_radius_m

  # Grind time estimate
  # Per Cycle:
  # 1,3 does 4 passes in x and 1 in y     3,1 does 4 passes in Y and 1 in X
  #   ########################            #  ####  #
  #                          #            #  #  #  #
  #   ########################            #  #  #  #
  #   #                                   #  #  #  #
  #   ########################            #  #  #  #
  #                          #            #  #  #  #
  #   ########################            ####  ####
  if n_xsteps == 1:
    time_ms = (dx_mm * (n_ysteps + 1) + dy_mm) * n_cycles / grind_speed_mps + 1500
  else:
    time_ms = (dx_mm + dy_mm * (n_xsteps + 1)) * n_cycles / grind_speed_mps + 1500
  end
  socket_set_var("robot_step_time_estimate_ms", time_ms)

  # Swapping sphere axes here since RY is aligned with the X of the FLAT and CYLINDER geometries
  if not set_grind_process_state(True,
    [
      p[-dx_m / 2.0, -dy_m / 2.0, 0, 0, 0, 0],
      p[-dx_m / 2.0, 0, 0, -dry_rad / 2.0, 0, 0],
      p[0, 0, 0, -dry_rad / 2.0, -drx_rad / 2.0, 0]
    ]):
    return False
  end

  # Grind the pattern
  shape = robot_part_geometry[0]
  if shape == 1:
    pattern_serpentine_flat(dx_m, dy_m, n_xsteps, n_ysteps, n_cycles)
  elif shape == 2:
    pattern_serpentine_cylinder(dx_m, dry_rad, n_xsteps, n_ysteps, n_cycles)
  elif shape == 3:
    # Swapping axes here since RY is aligned with the X of the FLAT and CYLINDER geometries
    pattern_serpentine_sphere(dry_rad, drx_rad, n_ysteps, n_xsteps, n_cycles)
  end

  if not stay_in_contact or not ok_to_proceed():
    set_grind_process_state(False)
  end
  return True
end

# Grind along a polygon with circle_diam_mm and n_sides. Repeat n_cycles times. If stay_in_contact, stay_in_contact at end.
def grind_poly(circle_diam_mm, n_sides, n_cycles, stay_in_contact):
  if n_cycles < 1:
    return True
  end

  # Unit conversion
  local circle_diam_m = circle_diam_mm / 1000.0
  local part_diam_m = robot_part_geometry[1] / 1000.0

  # Grind time estimate
  local time_ms = MATH_PI * circle_diam_mm * n_cycles / grind_speed_mps + 1500
  socket_set_var("robot_step_time_estimate_ms", time_ms)

  if not set_grind_process_state(True,
    [
      p[-circle_diam_m / 2.0, 0, 0, 0, 0, 0],
      p[-circle_diam_m / 2.0, 0, 0, 0, 0, 0],
      p[0, 0, 0, -circle_diam_m / part_diam_m, 0, 0]
    ]):
    return False
  end

  # Grind the pattern
  local shape = robot_part_geometry[0]
  if shape == 1:
    pattern_poly_flat(circle_diam_m, n_sides, n_cycles)
  elif shape == 2:
    pattern_poly_cylinder(circle_diam_m, n_sides, part_diam_m, n_cycles)
  elif shape == 3:
    pattern_poly_sphere(circle_diam_m, n_sides, part_diam_m, n_cycles)
  end

  if not stay_in_contact or not ok_to_proceed():
    set_grind_process_state(False)
  end
  return True
end

def recommend_npoints(diam_m):
  # 1 point per second?
  local circum_m = MATH_PI * diam_m
  local t = circum_m / grind_speed_mps
  global grind_circle_n_sides = limiter(ceil(t * 2), 2, 1000)

  # 100mm diam gets 50 points... seems about right
  #global grind_circle_n_sides = limiter(diam_m * 500, 2, 1000)
  return grind_circle_n_sides
end

# Grind along a circle with circle_diam_mm. Repeat n_cycles times. If stay_in_contact, stay_in_contact at end.
def grind_circle(circle_diam_mm, n_cycles, stay_in_contact):
  global grind_circle_n_sides = recommend_npoints(circle_diam_mm / 1000.0)

  if grind_blend_radius_m > 0.0:
    # Try setting n_sides to 1.5 blend radii
    local circum_m = MATH_PI * circle_diam_mm / 1000.
    global grind_circle_n_sides = ceil(circum_m / (grind_blend_radius_m * 1.5))
  end
  return grind_poly(circle_diam_mm, grind_circle_n_sides, n_cycles, stay_in_contact)
end

# Grind along a spiral circle1_diam_mm to circle2_diam_mm in n_revolutions with rotations centered on current tool position. Repeat n_cycles times. If stay_in_contact, stay_in_contact at end.
def grind_spiral(circle1_diam_mm, circle2_diam_mm, n_revolutions, n_cycles, stay_in_contact):
  if n_cycles < 1:
    return True
  end

  # Unit conversion
  local circle1_diam_m = circle1_diam_mm / 1000.0
  local circle2_diam_m = circle2_diam_mm / 1000.0
  local part_diam_m = robot_part_geometry[1] / 1000.0

  # Grind time estimate based on average diam
  local avg_diam_mm = (circle1_diam_mm + circle2_diam_mm) / 2.0
  local time_ms = MATH_PI * avg_diam_mm * n_revolutions * n_cycles / grind_speed_mps + 1500
  socket_set_var("robot_step_time_estimate_ms", time_ms)

  if not set_grind_process_state(True,
    [
      p[-circle1_diam_m / 2.0, 0, 0, 0, 0, 0],
      p[-circle1_diam_m / 2.0, 0, 0, 0, 0, 0],
      p[0, 0, 0, -circle1_diam_m / part_diam_m, 0, 0]
    ]):
    return False
  end

  # Grind the pattern
  local shape = robot_part_geometry[0]
  if shape == 1:
    pattern_spiral_flat(circle1_diam_m, circle2_diam_m, n_revolutions, n_cycles)
  elif shape == 2:
    pattern_spiral_cylinder(circle1_diam_m, circle2_diam_m, n_revolutions, part_diam_m, n_cycles)
  elif shape == 3:
    pattern_spiral_sphere(circle1_diam_m, circle2_diam_m, n_revolutions, part_diam_m, n_cycles)
  end

  if not stay_in_contact or not ok_to_proceed():
    set_grind_process_state(False)
  end
  return True
end


######################################################################################
######################################################################################
#
# PATTERN GRINDING FUNCTIONS
#
global grind_current_dp = p[0, 0, 0, 0, 0, 0]

def grind_start(current_dp):
  global grind_current_dp = p[0, 0, 0, 0, 0, 0]

  grind_to(current_dp)
end

def grind_to(dp, r = -1, no_wait = False):
  global grind_current_ddp0 = abs(dp[0] - grind_current_dp[0])
  global grind_current_ddp1 = abs(dp[1] - grind_current_dp[1])
  global grind_current_ddp3 = abs(dp[3] - grind_current_dp[3])
  global grind_current_ddp4 = abs(dp[4] - grind_current_dp[4])
  # Flat:     X, Y
  # Cylinder: X, RX
  # Sphere:   RX, RX
  local shape = robot_part_geometry[0]
  if shape == 3: # Sphere
    global process_a = grind_rot_accel_rpss
    global process_v = grind_rot_speed_rps
    global process_r = grind_rot_blend_radius_rad
  elif shape == 2: # Cylinder
    global process_theta = atan2(grind_current_ddp3, grind_current_ddp0)
    global process_rotational_factor = abs(sin(process_theta))
    global process_a =
    (
      grind_accel_mpss * (1 - process_rotational_factor) +
      grind_rot_accel_rpss * (process_rotational_factor)
    )
    global process_v =
    (
      grind_speed_mps * (1 - process_rotational_factor) +
      grind_rot_speed_rps * (process_rotational_factor)
    )
    global process_r = 
    (
      grind_blend_radius_m * (1 - process_rotational_factor) +
      grind_rot_blend_radius_rad * (process_rotational_factor)
    )
  else: # Flat
    global process_a = grind_accel_mpss
    global process_v = grind_speed_mps
    global process_r = grind_blend_radius_m
  end

  global process_r_in = r
  if r >= 0:
    global process_r = r
  end

  global grind_current_dp = dp
  imovel_int(pose_trans(p_contact_center, grind_current_dp), a = process_a, v = process_v, r = process_r, no_wait = no_wait)
end

def grind_finish(p):
  grind_to(p, r = 0)
end

######################################################################################
# LINE PATTERNS
#
# The line pattern sequence.
# Assumes all point_dist are declared globally
def pattern_line(n_cycles):
  global grind_cycle = 1
  local dpdest = dp2
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)

    if grind_cycle == n_cycles:
      grind_finish(dpdest)
    else:
      grind_to(dpdest, r = 0)
    end

    if dpdest == dp1:
      dpdest = dp2
    else:
      dpdest = dp1
    end

    grind_cycle = grind_cycle + 1
  end
end

# Move along a flat line dx_m x dy_m. Repeat n_cycles times.
# Move in x direction first, then y
def pattern_line_flat(dx_m, dy_m, n_cycles):
  local x2 = dx_m / 2.0
  local y2 = dy_m / 2.0

  global dp1 = dp_from_contact_center
  global dp2 = p[x2, y2, 0, 0, 0, 0]

  pattern_line(n_cycles)
end

# Move along a cylindrical line dx_m x dy_m. Repeat n_cycles times.
# Move in x direction first, then y
def pattern_line_cylinder(dx_m, drx_rad, n_cycles):
  local x2 = dx_m / 2.0
  local rx2 = drx_rad / 2.0

  global dp1 = dp_from_contact_center
  global dp2 = p[x2, 0, 0, rx2, 0, 0]

  pattern_line(n_cycles)
end

# Move along a sphere line dx_m x dy_m. Repeat n_cycles times.
# Move in x direction first, then y
def pattern_line_sphere(drx_rad, dry_rad, n_cycles):
  local rx2 = drx_rad / 2.0
  local ry2 = dry_rad / 2.0

  global dp1 = dp_from_contact_center
  global dp2 = p[0, 0, 0, rx2, ry2, 0]

  pattern_line(n_cycles)
end

######################################################################################
# RECT PATTERNS
#
# The rect pattern sequence. Assumes all points are defined globally!
def pattern_rect(n_cycles):
  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)

    # 4-point Version
    #grind_finish(dp2)
    #grind_finish(dp3)
    #grind_finish(dp4)
    #grind_finish(dp1)

    # 8-point Version
    grind_finish(dp2a)
    grind_finish(dp2b)
    grind_finish(dp3a)
    grind_finish(dp3b)
    grind_finish(dp4a)
    grind_finish(dp4b)
    grind_finish(dp1a)
    grind_finish(dp1b)

    grind_cycle = grind_cycle + 1
  end
end

# Move along a flat rect dx_m x dy_m. Repeat n_cycles times.
# Move in x direction first, then y
def pattern_rect_flat(dx_m, dy_m, n_cycles):
  local x2 = dx_m / 2.0
  local y2 = dy_m / 2.0

  local dx = grind_blend_radius_m * 2

  global dp1 = p[-x2, -y2, 0, 0, 0, 0]
  global dp1a = dp1
  global dp1b = dp1
  dp1a[1] = dp1a[1] + dx
  dp1b[0] = dp1b[0] + dx

  global dp2 = p[x2, -y2, 0, 0, 0, 0]
  global dp2a = dp2
  global dp2b = dp2
  dp2a[0] = dp2a[0] - dx
  dp2b[1] = dp2b[1] + dx

  global dp3 = p[x2, y2, 0, 0, 0, 0]
  global dp3a = dp3
  global dp3b = dp3
  dp3a[1] = dp3a[1] - dx
  dp3b[0] = dp3b[0] - dx

  global dp4 = p[-x2, y2, 0, 0, 0, 0]
  global dp4a = dp4
  global dp4b = dp4
  dp4a[0] = dp4a[0] + dx
  dp4b[1] = dp4b[1] - dx

  pattern_rect(n_cycles)
end

# Move along a cylindrical rect dx_mm,drx_rad. Repeat n_cycles times.
# Move in x direction first, then rx
def pattern_rect_cylinder(dx_m, drx_rad, n_cycles):
  local x2 = dx_m / 2.0
  local rx2 = drx_rad / 2.0

  local dx = grind_blend_radius_m * 2
  local da = grind_rot_blend_radius_rad * 8

  global dp1 = p[-x2, 0, 0, -rx2, 0, 0]
  global dp1a = dp1
  global dp1b = dp1
  dp1a[3] = dp1a[3] + da
  dp1b[0] = dp1b[0] + dx

  global dp2 = p[x2, 0, 0, -rx2, 0, 0]
  global dp2a = dp2
  global dp2b = dp2
  dp2a[0] = dp2a[0] - dx
  dp2b[3] = dp2b[3] + da

  global dp3 = p[x2, 0, 0, rx2, 0, 0]
  global dp3a = dp3
  global dp3b = dp3
  dp3a[3] = dp3a[3] - da
  dp3b[0] = dp3b[0] - dx

  global dp4 = p[-x2, 0, 0, rx2, 0, 0]
  global dp4a = dp4
  global dp4b = dp4
  dp4a[0] = dp4a[0] + dx
  dp4b[3] = dp4b[3] - da

  pattern_rect(n_cycles)
end

# Move along a spherical rect drx_rad,dry_rad. Repeat n_cycles times.
# Move in rx direction first, then ry
def pattern_rect_sphere(drx_rad, dry_rad, n_cycles):
  local rx2 = drx_rad / 2.0
  local ry2 = dry_rad / 2.0

  local da = grind_rot_blend_radius_rad * 8

  global dp1 = p[0, 0, 0, -rx2, -ry2, 0]
  global dp1a = dp1
  global dp1b = dp1
  dp1a[4] = dp1a[4] + da
  dp1b[3] = dp1b[3] + da

  global dp2 = p[0, 0, 0, rx2, -ry2, 0]
  global dp2a = dp2
  global dp2b = dp2
  dp2a[3] = dp2a[3] - da
  dp2b[4] = dp2b[4] + da

  global dp3 = p[0, 0, 0, rx2, ry2, 0]
  global dp3a = dp3
  global dp3b = dp3
  dp3a[4] = dp3a[4] - da
  dp3b[3] = dp3b[3] - da

  global dp4 = p[0, 0, 0, -rx2, ry2, 0]
  global dp4a = dp4
  global dp4b = dp4
  dp4a[3] = dp4a[3] + da
  dp4b[4] = dp4b[4] - da

  pattern_rect(n_cycles)
end

######################################################################################
# SERPENTINE PATTERNS
#
# Move along a flat serpentine dx_m,dy_m in n_xsteps,n_ysteps. Repeat n_cycles times.
# Move in direction of whichever nsteps is 1 first
def pattern_serpentine_flat(dx_m, dy_m, n_xsteps, n_ysteps, n_cycles):
  local t_move_x = dx_m / grind_speed_mps
  local t_move_y = dy_m / grind_speed_mps

  # Bottom left corner, grid 0,0
  local x2 = dx_m / 2.0
  local y2 = dy_m / 2.0
  local dp1 = dp_from_contact_center
  local dp2 = dp1

  # Track our grid square number... we're in [0,0] and moving [+1,+1] in either x or y
  local x_grid = 0
  local y_grid = 0
  local x_incr = 1
  local y_incr = 1
  local grid_dx_m = dx_m / n_xsteps
  local grid_dy_m = dy_m / n_ysteps

  # How many moves does it take to complete a pass?
  global n_moves_per_pass = (n_xsteps + n_ysteps) * 2 - 1

  local move_count = 0
  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    # This will repeat for each leg of the serpentine!
    socket_set_var("grind_cycle", grind_cycle)

    # Skip first X move if we should start with a y move
    if move_count != 0 or n_xsteps == 1:
      # Advance x_grid by x_incr
      x_grid = x_grid + x_incr

      # Move to the corresponding position
      local dp2 = p[x_grid * grid_dx_m - x2, y_grid * grid_dy_m - y2, 0, 0, 0, 0]
      grind_finish(dp2)

      # Adjust x direction
      if x_grid >= n_xsteps:
        x_incr = -1
      elif x_grid <= 0:
        x_incr = 1
      end
      move_count = move_count + 1
    end

    if ok_to_proceed() and move_count < n_moves_per_pass:
      # Advance y_grid by y_incr
      y_grid = y_grid + y_incr

      # Move to the corresponding position
      local dp2 = p[x_grid * grid_dx_m - x2, y_grid * grid_dy_m - y2, 0, 0, 0, 0]
      grind_finish(dp2)

      # Adjust y direction
      if y_grid >= n_ysteps:
        y_incr = -1
      elif y_grid <= 0:
        y_incr = 1
      end
      move_count = move_count + 1
    end

    # Detect when we've covered all the grid squares!
    if move_count >= n_moves_per_pass:
      grind_cycle = grind_cycle + 1
      move_count = 0
    end
  end
end

# Move along a cylindrical serpentine dx_m,drx_rad in n_xsteps,n_rxsteps. Repeat n_cycles times.
# Move in direction of whichever nsteps is 1 first
def pattern_serpentine_cylinder(dx_m, drx_rad, n_xsteps, n_rxsteps, n_cycles):
  local t_move_x = dx_m / grind_speed_mps
  local t_move_rx = drx_rad / grind_rot_speed_rps / 4

  # Bottom left corner, grid 0,0
  local x2 = dx_m / 2.0
  local rx2 = drx_rad / 2.0
  local dp1 = dp_from_contact_center
  local dp2 = dp1

  # Track our grid square number... we're in [0,0] and moving [+1,+1] in either x or y
  local x_grid = 0
  local y_grid = 0
  local x_incr = 1
  local y_incr = 1
  local grid_dx_m = dx_m / n_xsteps
  local grid_drx_rad = drx_rad / n_rxsteps
  local last_a = grind_accel_mpss
  local last_v = grind_speed_mps

  # How many moves does it take to complete a pass?
  global n_moves_per_pass = (n_xsteps + n_rxsteps) * 2 - 1

  local move_count = 0
  global grind_cycle = 1
  grind_start(dp1)
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    # This will repeat for each leg of the serpentine!
    socket_set_var("grind_cycle", grind_cycle)

    # Skip first X move if we should start with a y move
    if move_count != 0 or n_xsteps == 1:
      # Advance x_grid by x_incr
      x_grid = x_grid + x_incr

      # Move to the corresponding position
      local dp2 = p[x_grid * grid_dx_m - x2, 0, 0, y_grid * grid_drx_rad - rx2, 0, 0]
      local last_a = grind_accel_mpss
      local last_v = grind_speed_mps
      grind_finish(dp2)

      # Adjust x direction
      if x_grid >= n_xsteps:
        x_incr = -1
      elif x_grid <= 0:
        x_incr = 1
      end
      move_count = move_count + 1
    end

    if ok_to_proceed() and move_count < n_moves_per_pass:
      # Advance y_grid by y_incr
      y_grid = y_grid + y_incr

      # Move to the corresponding position
      local dp2 = p[x_grid * grid_dx_m - x2, 0, 0, y_grid * grid_drx_rad - rx2, 0, 0]
      local last_a = grind_rot_accel_rpss
      local last_v = grind_rot_speed_rps
      grind_finish(dp2)

      # Adjust y direction
      if y_grid >= n_rxsteps:
        y_incr = -1
      elif y_grid <= 0:
        y_incr = 1
      end
      move_count = move_count + 1
    end

    # Detect when we've covered all the grid squares!
    if move_count >= n_moves_per_pass:
      grind_cycle = grind_cycle + 1
      move_count = 0
    end
  end
end

# Move along a sperical serpentine drx_rad,dry_rad in n_rxsteps,n_rysteps. Repeat n_cycles times.
# Move in direction of whichever nsteps is 1 first
def pattern_serpentine_sphere(drx_rad, dry_rad, n_rxsteps, n_rysteps, n_cycles):
  local t_move_rx = drx_rad / grind_rot_speed_rps / 4
  local t_move_ry = dry_rad / grind_rot_speed_rps / 4

  # Bottom left corner, grid 0,0
  local rx2 = drx_rad / 2.0
  local ry2 = dry_rad / 2.0
  local dp1 = dp_from_contact_center
  local dp2 = dp1

  # Track our grid square number... we're in [0,0] and moving [+1,+1] in either x or y
  local x_grid = 0
  local y_grid = 0
  local x_incr = 1
  local y_incr = 1
  local grid_drx_rad = drx_rad / n_rxsteps
  local grid_dry_rad = dry_rad / n_rysteps

  # How many moves does it take to complete a pass?
  global n_moves_per_pass = (n_rxsteps + n_rysteps) * 2 - 1

  local move_count = 0
  global grind_cycle = 1
  grind_start(dp1)
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    # This will repeat for each leg of the serpentine!
    socket_set_var("grind_cycle", grind_cycle)

    # Skip first X move if we should start with a y move
    if move_count != 0 or n_rxsteps == 1:
      # Advance x_grid by x_incr
      x_grid = x_grid + x_incr

      # Move to the corresponding position
      local dp2 = p[0, 0, 0, x_grid * grid_drx_rad - rx2, y_grid * grid_dry_rad - ry2, 0]
      grind_finish(dp2)

      # Adjust x direction
      if x_grid >= n_rxsteps:
        x_incr = -1
      elif x_grid <= 0:
        x_incr = 1
      end
      move_count = move_count + 1
    end

    if ok_to_proceed() and move_count < n_moves_per_pass:
      # Advance y_grid by y_incr
      y_grid = y_grid + y_incr

      # Move to the corresponding position
      local dp2 = p[0, 0, 0, x_grid * grid_drx_rad - rx2, y_grid * grid_dry_rad - ry2, 0]
      grind_finish(dp2)

      # Adjust y direction
      if y_grid >= n_rysteps:
        y_incr = -1
      elif y_grid <= 0:
        y_incr = 1
      end
      move_count = move_count + 1
    end

    # Detect when we've covered all the grid squares!
    if move_count >= n_moves_per_pass:
      grind_cycle = grind_cycle + 1
      move_count = 0
    end
  end
end


######################################################################################
# POLYGONAL PATTERNS
#
# Grind along a polygon with circle_diam_m and n_sides on a flat. Repeat n_cycles times.
def pattern_poly_flat(circle_diam_m, n_sides, n_cycles):
  # Local calculations
  local circle_radius_m = circle_diam_m / 2.0

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    local i = 0
    while ok_to_proceed() and i <= n_sides:
      local theta = d2r(180.0 + 360.0 * i / n_sides)
      local x = circle_radius_m * cos(theta)
      local y = circle_radius_m * sin(theta)

      local dp = p[x, y, 0, 0, 0, 0]
      if not ok_to_proceed() or i == n_sides:
        grind_finish(dp)
      else:
        grind_to(dp)
      end
      i = i + 1
    end

    grind_cycle = grind_cycle + 1
  end
end

# Grind along a polygon with circle_diam_m and n_sides on a cylinder_radius_m. Repeat n_cycles times.
def pattern_poly_cylinder(circle_diam_m, n_sides, cylinder_radius_m, n_cycles):
  # Local calculations
  local circle_radius_m = circle_diam_m / 2.0

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    local i = 0
    while ok_to_proceed() and i <= n_sides:
      local theta = d2r(180.0 + 360.0 * i / n_sides)
      local x = circle_radius_m * cos(theta)
      local y = circle_radius_m * sin(theta)
      local rx = 2.0 * y / cylinder_radius_m

      local dp = p[x, 0, 0, rx, 0, 0]
      if not ok_to_proceed() or i == n_sides:
        grind_finish(dp)
      else:
        grind_to(dp)
      end
      i = i + 1
    end

    grind_cycle = grind_cycle + 1
  end
end

# Grind along a polygon with circle_diam_m and n_sides on a sphere_diam_m. Repeat n_cycles times.
def pattern_poly_sphere(circle_diam_m, n_sides, sphere_diam_m, n_cycles):
  # Local calculations
  local circle_radius_m = circle_diam_m / 2.0
  local sphere_radius_m = sphere_diam_m / 2.0

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    local i = 0
    while ok_to_proceed() and i <= n_sides:
      local theta = d2r(180.0 + 360.0 * i / n_sides)
      local x = circle_radius_m * cos(theta)
      local rx = x / sphere_radius_m
      local y = circle_radius_m * sin(theta)
      local ry = y / sphere_radius_m

      local dp = p[0, 0, 0, rx, ry, 0]
      if not ok_to_proceed() or i == n_sides:
        grind_finish(dp)
      else:
        grind_to(dp)
      end
      i = i + 1
    end

    grind_cycle = grind_cycle + 1
  end
end


######################################################################################
# SPIRAL PATTERNS
#
# Grind a flat spiral from diam1 to diam2 in n_revolutions revolutions
def pattern_spiral_flat(circle1_diam_m, circle2_diam_m, n_revolutions, n_cycles):
  # Local calculations
  local max_diam_m = max(circle1_diam_m, circle2_diam_m)
  local n_points = recommend_npoints(max_diam_m)
  local n_total_points = n_revolutions * n_points
  local circle1_radius_m = circle1_diam_m / 2.0
  local circle2_radius_m = circle2_diam_m / 2.0

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    local rslope = (circle2_radius_m - circle1_radius_m) / n_total_points
    local i = 0
    while ok_to_proceed() and i <= n_total_points:
      local theta = d2r(180.0 + 360.0 * (i % n_points) / n_points)
      local r_instantaneous = i * rslope + circle1_radius_m
      local x = r_instantaneous * cos(theta)
      local y = r_instantaneous * sin(theta)

      local dp = p[x, y, 0, 0, 0, 0]
      if not ok_to_proceed() or i == n_points:
        grind_finish(dp)
      else:
        grind_to(dp)
      end
      i = i + 1
    end
    grind_cycle = grind_cycle + 1

    # Next cycle- swap diameters so we go in/out/in etc.
    local old_circle1_radius_m = circle1_radius_m
    local circle1_radius_m = circle2_radius_m
    local circle2_radius_m = old_circle1_radius_m
  end
end

# Grind a spiral on a cylinder from diam1 to diam2 in n_revolutions revolutions
def pattern_spiral_cylinder(circle1_diam_m, circle2_diam_m, n_revolutions, cylinder_radius_m, n_cycles):
  # Local calculations
  local max_diam_m = max(circle1_diam_m, circle2_diam_m)
  local n_points = recommend_npoints(max_diam_m)
  local n_total_points = n_revolutions * n_points
  local circle1_radius_m = circle1_diam_m / 2.0
  local circle2_radius_m = circle2_diam_m / 2.0

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    local rslope = (circle2_radius_m - circle1_radius_m) / n_total_points
    local i = 0
    while ok_to_proceed() and i <= n_total_points:
      local theta = d2r(180.0 + 360.0 * (i % n_points) / n_points)
      local r_instantaneous = i * rslope + circle1_radius_m
      local x = r_instantaneous * cos(theta)
      local y = r_instantaneous * sin(theta)
      local rx = 2.0 * y / cylinder_radius_m

      local dp = p[x, 0, 0, rx, 0, 0]

      if not ok_to_proceed() or i == n_points:
        grind_finish(dp)
      else:
        grind_to(dp)
      end
      i = i + 1
    end
    grind_cycle = grind_cycle + 1

    # Next cycle- swap diameters so we go in/out/in etc.
    local old_circle1_radius_m = circle1_radius_m
    local circle1_radius_m = circle2_radius_m
    local circle2_radius_m = old_circle1_radius_m
  end
end

# Grind a spiral on a sphere from diam1 to diam2 in n_revolutions revolutions
def pattern_spiral_sphere(circle1_diam_m, circle2_diam_m, n_revolutions, sphere_diam_m, n_cycles):
  # Local calculations
  local max_diam_m = max(circle1_diam_m, circle2_diam_m)
  local n_points = recommend_npoints(max_diam_m)
  local n_total_points = n_revolutions * n_points
  local circle1_radius_m = circle1_diam_m / 2.0
  local circle2_radius_m = circle2_diam_m / 2.0
  local sphere_radius_m = sphere_diam_m / 2.0

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_set_var("grind_cycle", grind_cycle)
    local rslope = (circle2_radius_m - circle1_radius_m) / n_total_points
    local i = 0
    while ok_to_proceed() and i <= n_total_points:
      local theta = d2r(180.0 + 360.0 * (i % n_points) / n_points)
      local r_instantaneous = i * rslope + circle1_radius_m
      local x = r_instantaneous * cos(theta)
      local rx = x / sphere_radius_m
      local y = r_instantaneous * sin(theta)
      local ry = y / sphere_radius_m

      local dp = p[0, 0, 0, rx, ry, 0]
      if not ok_to_proceed() or i == n_points:
        grind_finish(dp)
      else:
        grind_to(dp)
      end
      i = i + 1
    end
    grind_cycle = grind_cycle + 1

    # Next cycle- swap diameters so we go in/out/in etc.
    local old_circle1_radius_m = circle1_radius_m
    local circle1_radius_m = circle2_radius_m
    local circle2_radius_m = old_circle1_radius_m
  end
end