# File: agscript_grind-2.script
# Project: AutoGrind Code Rev 2 IMOVER
# Author: Ned Lecky, Lecky Engineering LLC
# Purpose: All grinding functions used in AutoGrind

global grind_version = "Rev 2 2022-06-13"

global grind_abort_listener_thread_handle = 0
global pattern_grind_thread_handle = 0

global halt_count = 0
global halt_command = [0, 0, 0, 0]

global grind_ready = True
# grind_contact_enable:  0=No Contact   1=Touch but no tool/coolant on or force  2=Touch, Tool, Coolant, and Force
global grind_contact_enable = 0
global grind_touch_retract_mm = 3       # How far to retract after touch  (we do 2X this for ghrind_contact_enable=1)
global grind_touch_speed_mmps = 0.1     # How fast to go in for the touch
global grind_force_dwell_ms = 500       # How long to dwell after turning force more on
global grind_max_blend_radius_m = 0.010 # Max blend radius to use while grinding
global grind_trial_speed_mmps = 20      # Grinding speed when not really grinding!
global grind_point_frequency_hz = 4     # Points per second to generate in grind_movel

# Current speeds in use for grinding... the angular are computed off the linear
# And the two are blended by draw_to for cylinders
global grind_linear_vel_mps = 0
global grind_linear_accel_mpss = 0
global grind_linear_blend_radius_m = 0
global grind_angular_vel_rps = 0
global grind_angular_accel_rpss = 0
global grind_angular_blend_radius_rad = 0

global grind_part_speed_mmps = 50.0     # Speed used internally when adjusting and moving around part

# Planning points
global p_operator_init = p[0, 0, 0, 0, 0, 0]    # Where we were when operator issued first grind command
global p_contact_init = p[0, 0, 0, 0, 0, 0]     # Where we first contacted the part
global dp_from_contact_center = p[0, 0, 0, 0, 0, 0]   # How did we offset from p_operator_int prior to contact?
global p_contact_center = p[0, 0, 0, 0, 0, 0]   # Computed where center of pattern would be in contact with part

# Set grind variables chosen by command[2]
# Value after set is always returned to socket
def set_grind_variable():
  global grind_ready = False
  socket_send_bool("grind_ready", grind_ready)

  if command[2] == 1:
    global response = "set grind_contact_enable"
    if command[3] >= 0 and command[3] <= 2:
      global grind_contact_enable = ceil(command[3])
    end
    socket_send_integer("grind_contact_enable", grind_contact_enable)
  elif command[2] == 2:
    global response = "set grind_touch_retract_mm"
    if command[3] >= 0:
      global grind_touch_retract_mm = ceil(command[3])
    end
    socket_send_integer("grind_touch_retract_mm", grind_touch_retract_mm)
  elif command[2] == 3:
    global response = "set grind_touch_speed_mmps"
    if command[3] >= 0:
      global grind_touch_speed_mmps = ceil(command[3])
    end
    socket_send_integer("grind_touch_speed_mmps", grind_touch_speed_mmps)
  elif command[2] == 4:
    global response = "set grind_force_dwell_ms"
    if command[3] >= 0:
      global grind_force_dwell_ms = ceil(command[3])
    end
    socket_send_integer("grind_force_dwell_ms", grind_force_dwell_ms)
  elif command[2] == 5:
    global response = "set grind_max_wait_ms"
    if command[3] >= 0:
      global grind_max_wait_ms = ceil(command[3])
    end
    socket_send_integer("grind_max_wait_ms", grind_max_wait_ms)
  elif command[2] == 6:
    global response = "set grind_max_blend_radius_mm"
    if command[3] >= 0:
      global grind_max_blend_radius_m = command[3] / 1000.0
    end
    socket_send_num("grind_max_blend_radius_mm", grind_max_blend_radius_m * 1000.0)
  elif command[2] == 7:
    global response = "set grind_trial_speed_mmps"
    if command[3] > 0:
      global grind_trial_speed_mmps = ceil(command[3])
    end
    socket_send_integer("grind_trial_speed_mmps", grind_trial_speed_mmps)
  elif command[2] == 8:
    global response = "set grind_linear_accel_mmpss"
    if command[3] > 0:
      global grind_linear_accel_mpss = command[3] / 1000.0
    end
    socket_send_integer("grind_linear_accel_mmpss", grind_linear_accel_mpss * 1000.0)
  elif command[2] == 9:
    global response = "set grind_point_frequency_hz"
    if command[3] >= 0:
      global grind_point_frequency_hz = ceil(command[3])
    end
    socket_send_integer("grind_point_frequency_hz", grind_point_frequency_hz)
  else:
    global response = "Unknown grind set variable command"
  end

  global grind_ready = True
  socket_send_bool("grind_ready", grind_ready)
end

# Execute the desired grind operation as specified in command[2]...
def grind():
  global grind_ready = False
  socket_send_bool("grind_ready", grind_ready)

  # Start listening for abort commands from host
  if grind_abort_listener_thread_handle > 0:
    kill grind_abort_listener_thread_handle
    grind_abort_listener_thread_handle = 0
  end
  grind_abort_listener_thread_handle = run grind_abort_listener_thread()

  global grind_cycle = 0
  socket_send_integer("grind_cycle", grind_cycle)

  # Install tcp that puts tcp at center of part (noop for flat parts!)
  iset_tcp(robot_tcp_part)

  if command[2] == 10:
    # LINEAR GRIND
    global response = "grind_line"
    global grind_dx_mm = limiter(command[3], -1000, 1000)
    global grind_dy_mm = limiter(command[4], -1000, 1000)
    n_cycle_setter(command[5])
    speed_setter(command[6])
    global grind_force_N = limiter(command[7], 0, 100)
    global grind_continue = command[8] > 0
    imover_realtime(True)
    grind_line(grind_dx_mm, grind_dy_mm, grind_n_cycles, grind_continue)

  elif command[2] == 11:
    # LINEAR ANGLE GRIND
    global response = "grind_line_deg"
    global grind_len_mm = limiter(command[3], 0, 1000)
    global grind_angle_deg = limiter(command[4], 0, 360)
    n_cycle_setter(command[5])
    speed_setter(command[6])
    global grind_force_N = limiter(command[7], 0, 100)
    global grind_continue = command[8] > 0
    imover_realtime(True)
    global grind_dx_mm = grind_len_mm * cos(d2r(grind_angle_deg))
    global grind_dy_mm = grind_len_mm * sin(d2r(grind_angle_deg))
    grind_line(grind_dx_mm, grind_dy_mm, grind_n_cycles, grind_continue)

  elif command[2] == 20:
    # RECTANGULAR GRIND
    global response = "grind_rect"
    global grind_dx_mm = limiter(command[3], 0, 1000)
    global grind_dy_mm = limiter(command[4], 0, 1000)
    n_cycle_setter(command[5])
    speed_setter(command[6], min(grind_dx_mm, grind_dy_mm))
    global grind_force_N = limiter(command[7], 0, 100)
    global grind_continue = command[8] > 0
    imover_realtime(True)
    grind_rect(grind_dx_mm, grind_dy_mm, grind_n_cycles, grind_continue)

  elif command[2] == 30:
    # SERPENTINE GRIND
    global response = "grind_serpentine"
    global grind_dx_mm = limiter(command[3], 1, 1000)
    global grind_dy_mm = limiter(command[4], 1, 1000)
    global grind_n_xsteps = limiter(command[5], 1, grind_dx_mm)
    global grind_n_ysteps = limiter(command[6], 1, grind_dy_mm)
    n_cycle_setter(command[7])
    local min_feature_mm = min(grind_dx_mm / grind_n_xsteps, grind_dy_mm / grind_n_ysteps)
    speed_setter(command[8], min_feature_mm)
    global grind_force_N = limiter(command[9], 0, 10)
    global grind_continue = command[10] > 0
    grind_serpentine(grind_dx_mm, grind_dy_mm, grind_n_xsteps, grind_n_ysteps, grind_n_cycles, grind_continue)

  elif command[2] == 40:
    # POLYGON GRIND
    global response = "grind_poly"
    global grind_circle1_diam_mm = limiter(command[3], 0, 1000)
    # Limit number of sides to 2 (line) to diam_mm/10 (100mm circle can have up to 10 sides)
    global grind_n_sides = limiter(command[4], 2, grind_circle1_diam_mm / 10.0)
    n_cycle_setter(command[5])
    local min_feature_mm = max(2, grind_circle1_diam_mm)
    speed_setter(command[6], min_feature_mm)
    global grind_force_N = limiter(command[7], 0, 100)
    global grind_continue = command[8] > 0
    grind_poly(grind_circle1_diam_mm, grind_n_sides, grind_n_cycles, grind_continue)

  elif command[2] == 45:
    # CIRCULAR GRIND
    global response = "grind_circle"
    global grind_circle1_diam_mm = limiter(command[3], 0, 1000)
    n_cycle_setter(command[4])
    local min_feature_mm = max(2, grind_circle1_diam_mm)
    speed_setter(command[5], min_feature_mm, is_circle = True)
    global grind_force_N = limiter(command[6], 0, 100)
    global grind_continue = command[7] > 0
    grind_circle(grind_circle1_diam_mm, grind_n_cycles, grind_continue)

  elif command[2] == 50:
    # SPIRAL GRIND
    global response = "grind_spiral"
    global grind_circle1_diam_mm = limiter(command[3], 0, 1000)
    global grind_circle2_diam_mm = limiter(command[4], 0, 1000)
    global grind_n_revolutions = limiter(command[5], 1, 100)
    n_cycle_setter(command[6])
    local min_diam_mm = min(grind_circle1_diam_mm, grind_circle2_diam_mm)
    local min_feature_mm = max(2, min_diam_mm)
    speed_setter(command[7], min_feature_mm, is_circle = True)
    global grind_force_N = limiter(command[8], 0, 100)
    global grind_continue = command[9] > 0
    grind_spiral(grind_circle1_diam_mm, grind_circle2_diam_mm, grind_n_revolutions, grind_n_cycles, grind_continue)

  elif command[2] == 99:
    # RETRACT COMMAND
    global response = "grind_retract"
    imover_realtime(True)
    set_grind_process_state(False)
  else:
    # Illegal grind command
    global response = "Unknown grind command"
  end

  # Restore tool-only tcp
  iset_tcp(robot_tcp)

  # Stop listening for abort commands from host
  if grind_abort_listener_thread_handle > 0:
    kill grind_abort_listener_thread_handle
    grind_abort_listener_thread_handle = 0
  end

  global grind_ready = True
  socket_send_bool("grind_ready", grind_ready)
end

# Set global grind_n_cycles based on whether we really going to grind
def n_cycle_setter(n_cycles):
  if grind_contact_enable == 2:
    global grind_n_cycles = limiter(n_cycles, 0, 100)
  else:
    global grind_n_cycles = limiter(n_cycles, 0, 1)
  end
  socket_send_integer("grind_n_cycles", grind_n_cycles)
end

def forced_speed_setter(speed_mmps):
  # Set as if we're really going to grind but at a user-selected speed
  local old_grind_contact_enable = grind_contact_enable
  global grind_contact_enable = 2
  speed_setter(speed_mmps)
  grind_contact_enable = old_grind_contact_enable
end

# Set all speed and acceleration globals based on part geometry and whether we really going to grind
def speed_setter(speed_mmps, min_feature_mm = 0.0, is_circle = False):
  speed_mmps = limiter(speed_mmps, 0.1, 200)

  # Figure out best blend radius to use
  global grind_min_feature_m = min_feature_mm / 1000.0
  global grind_linear_blend_radius_m = min(grind_max_blend_radius_m, grind_min_feature_m / 4)
  if is_circle:
    if grind_linear_blend_radius_m < 0.0015:
      grind_linear_blend_radius_m = 0
    end
  else:
    if grind_linear_blend_radius_m < 0.0015:
      grind_linear_blend_radius_m = 0
    end
  end

  if grind_contact_enable == 2:
    global grind_linear_vel_mps = speed_mmps / 1000.0
  else:
    global grind_linear_vel_mps = grind_trial_speed_mmps / 1000.0
  end

  # If part is cylinder or spherical, diameter will be >0
  local diam_m = robot_part_geometry[1] / 1000.0
  if diam_m > 0.0:
    # These are 1/4 the theoretical rotational speeds but we need to set them like this to get the correct speed- why??????
    # rot_vel (rad/s) = linear_vel (m/s) * 2pi (rad/s) / pi * diam (m/s)
    local coeff = 0.5 # Should be 2 and why 0.5 is inexplicable
    global grind_angular_vel_rps = grind_linear_vel_mps * coeff / diam_m
    global grind_angular_accel_rpss = grind_linear_accel_mpss * coeff / diam_m
    global grind_angular_blend_radius_rad = grind_linear_blend_radius_m * coeff / diam_m
  end

  socket_send_num("grind_linear_vel_mmps", grind_linear_vel_mps * 1000.0)
  socket_send_num("grind_linear_accel_mmpss", grind_linear_accel_mpss * 1000.0)
  socket_send_num("grind_linear_blend_radius_mm", grind_linear_blend_radius_m * 1000.0)
  socket_send_num("grind_angular_vel_rps", grind_angular_vel_rps)
  socket_send_num("grind_angular_accel_rpss", grind_angular_accel_rpss)
  socket_send_num("grind_angular_blend_radius_rad", grind_angular_blend_radius_rad)
end


# Get into contact with part (or away from it)
# enable:  0=No Contact   1=Touch but no tool/coolant on or force  2=Touch, Tool, Coolant, and Force
def contact_part(on = False, enable = 0):
  draw_origin(iget_actual_tcp_pose())

  if on:
    if enable == 0:
      # Just do a small forward motion in the direction of touchoff- this is a simulated p_contact_init
      draw_speed_once(grind_part_speed_mmps)
      p_contact_init = draw_to(p[0, 0, 0.005, 0, 0, 0])
    elif enable == 1:
      # Advance until contact but retract 2X grind distance and use this as a simulated p_contact_init
      local success = itouchoff(grind_touch_speed_mmps, grind_touch_retract_mm * 2.0)
      global p_contact_init = iget_actual_tcp_pose()
      return success
    elif enable == 2:
      # Advance until contact
      local success = itouchoff(grind_touch_speed_mmps, grind_touch_retract_mm)
      # Touchoff has backed off by grind_touch_retract_mm so we need to compute that actual p_contact_init
      global p_contact_init = pose_trans(iget_actual_tcp_pose(), p[0, 0, grind_touch_retract_mm / 1000.0, 0, 0, 0])
      return success
    end
  else:  # Back off
    draw_speed_once(grind_part_speed_mmps)
    draw_to(p[0, 0, -0.010, 0, 0, 0])
  end

  return True
end

# Sets digital outpus based 8-element list of 4 pairs DOUT#,State.  -1 indicates unused slot
def set_digital_output_list(list):
  i = 0
  while i < 8:
    if list[i] >= 0:
      b = list[i + 1] == 1
      set_digital_out(list[i], b)
    end
    i = i + 2
  end
end

# Turn tool power on/off if enable=2
def tool_power(on = False, enable = 0):
  if enable < 2:
    return None
  end

  if on:
    # ON IO
    set_digital_output_list(robot_tool_on_outputs)
  else:
    # OFF IO
    set_digital_output_list(robot_tool_off_outputs)
  end

  return None
end

# Turn coolant on/off if enable=2
def coolant_flow(on = False, enable = 0):
  if enable < 2:
    return None
  end

  if on:
    # ON IO
    set_digital_output_list(robot_coolant_on_outputs)
  else:
    # OFF IO
    set_digital_output_list(robot_coolant_off_outputs)
  end

  return None
end

# Turn force mode on/off if enable=2
def apply_force(on = False, enable = 0, force_n = 5, approach_speed_mmps = 10):
  if enable < 2:
    return None
  end

  if on:
    izero_ftsensor()
    iforce_mode(force_n, approach_speed_mmps)
    sleep(grind_force_dwell_ms / 1000.0)
  else:
    iend_force_mode()
    sleep(0.1)
  end

  return None
end

# Start/Stop Grinding
global p_init_count = 1
# Pose to center is the offset we should move to initial touch point [0]=FLAT [1]=CYLINDER [2]=SPHERE
global grind_process_state = False
def set_grind_process_state(on = False, pose_to_center = [p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0]]):
  if on and grind_process_state:
    # Continuing a grind...

    # Need to change force?
    # Lift, rezero, and then head toward start of next pattern
    if grind_contact_enable == 2 and imover_force_N != grind_force_N:
      # This would be great, but the sensor drifts and forces returned by get_tcp_force() are offset
      #iforce_update(grind_force_N, grind_touch_speed_mmps)

      # So we do a full reset!
      iend_force_mode()
      draw_speed_once(grind_part_speed_mmps)
      draw_to(p[0, 0, -0.004, 0, 0, 0])
      sleep(1)
      izero_ftsensor()
      iforce_mode(grind_force_N, grind_touch_speed_mmps)
    end

    # Move to initial grind position relative to initial p_contact_center
    shape = robot_part_geometry[0]
    if shape < 1 or shape > 3:
      return False
    end

    global dp_from_contact_center = pose_to_center[shape-1]
    draw_speed_once(grind_part_speed_mmps)
    draw_finish(dp_from_contact_center)
  elif on and not grind_process_state:
    # Need to start the grind
    global p_operator_init = iget_target_tcp_pose()
    local name = "aa_p_operator_init_" + to_str(p_init_count)
    socket_send_pose(name, p_operator_init)

    izero_ftsensor()

    # Move to start position for touchoff
    shape = robot_part_geometry[0]
    if shape < 1 or shape > 3:
      return False
    end

    # TODO This calc isn't exactly right... we will undermove slightly on curved surfaces
    # Think about it
    global dp_from_contact_center = pose_to_center[shape-1]
    draw_origin(p_operator_init)
    draw_speed_once(grind_part_speed_mmps)
    draw_finish(dp_from_contact_center)

    # Touch part and refine p_contact_init
    if not contact_part(True, grind_contact_enable):
      # Failure to contact part should abort... don't set grind_process_state and return False
      draw_speed_once(grind_part_speed_mmps)
      draw_finish(p[0, 0, 0, 0, 0, 0])
      socket_send_line("grind_process_state=False")
      return False
    end

    # Compute p_contact_center... where we would have been if we had touched off from the operator teach position!
    local  reverse_pose_to_center = pose_to_center[shape-1]
    local i = 0
    while i < 6:
      reverse_pose_to_center[i] = -reverse_pose_to_center[i]
      i = i + 1
    end
    global p_contact_center = pose_trans(p_contact_init, reverse_pose_to_center)

    # All remaining grind moves will be relative to this computed center point
    draw_origin(p_contact_center)

    local name = "aa_p_contact_center_" + to_str(p_init_count)
    socket_send_pose(name, p_contact_center)
    p_init_count = p_init_count + 1
    if (p_init_count > 4):
      p_init_count = 1
    end

    # Should already be here? (Should be using the speeds set by the grind() command)
    draw_to(dp_from_contact_center)

    # Now power everything on (although these will do nothing unless contact_enable==2)
    tool_power(True, grind_contact_enable)
    coolant_flow(True, grind_contact_enable)
    apply_force(True, grind_contact_enable, grind_force_N, grind_touch_speed_mmps)
    global grind_process_state = True
  elif not on and grind_process_state:
    set_ok_to_proceed(True)

    # Need to stop the grind
    # Shut everything down and return to original pose
    apply_force(False, grind_contact_enable, 0)
    contact_part(False, grind_contact_enable)
    coolant_flow(False, grind_contact_enable)
    tool_power(False, grind_contact_enable)

    # Always end with a move back to with the imover realtime back running
    imover_realtime(True)
    draw_origin(p_operator_init)
    forced_speed_setter(grind_part_speed_mmps)
    draw_finish(p[0, 0, 0, 0, 0, 0])

    global grind_process_state = False
  end

  # Always let the host know status
  if grind_process_state:
    socket_send_line("grind_process_state=True")
  else:
    socket_send_line("grind_process_state=False")
  end
  return True
end

######################################################################################
# Thread to listen for abort messages while grinding
#
global grind_force_report_counter = 0
global grind_force_report = p[0, 0, 0, 0, 0, 0]
global grind_force_report_z_n = 0
thread grind_abort_listener_thread():
  global halt_command = [0, 0, 0, 0]
  global halt_count = 0
  global grind_force_report_counter = 0
  global grind_force_readings_n = 5
  global grind_force_readings = [0., 0., 0., 0., 0.]

  # Initialize force readings array
  local i = 0
  while i < grind_force_readings_n:
    local f = get_tcp_force()
    grind_force_readings[i] = f[2]
    i = i + 1
  end
  global grind_force_report_z_n = grind_force_readings[grind_force_readings_n-1]
  global grind_force_filtered_z_n = grind_force_report_z_n


  while (halt_count == 0):
    # Commands should never arrive, so this will block us for 0.2s
    global halt_command = socket_read_ascii_float(3, timeout = 0.2)

    # If door is open, that adds a halt count (anything >0 will stop us!)
    if not is_door_closed():
      global halt_count = halt_count + 1
    end

    # If we've received anything we should halt!
    if halt_command[0] > 0:
      global halt_count = halt_count + 1
      socket_send_integer("halt_count", halt_count)
    end

    # Increment reading counter (10000 is high enough... don't need to worry about wraparound effects)
    grind_force_report_counter = grind_force_report_counter + 1
    if grind_force_report_counter > 10000:
      grind_force_report_counter = 0
    end

    # Store force in circular buffer
    local force = get_tcp_force()
    grind_force_readings[grind_force_report_counter % grind_force_readings_n] = force[2]

    # Report force periodically (This executes at 5Hz because of timeout=0.2 in socket_read_ascii_float(...)
    if grind_force_report_counter % 5 == 0:
      # Compute average of the stored readings
      local i = 0
      local sum = 0.0
      while i < grind_force_readings_n:
        sum = sum + grind_force_readings[i]
        i = i + 1
      end
      global grind_force_average_z_n = sum / grind_force_readings_n

      # Any other filtering could be done here...
      # Round to 2 DP
      global grind_force_report_z_n = ceil(grind_force_average_z_n * 100) / 100

      socket_send_num("grind_force_report_z_n", grind_force_report_z_n)
    end
  end
  return None
end

# Should we proceed? halt_count==0 means no door-opens and no abort commands from host
def ok_to_proceed():
  return halt_count == 0
end

def set_ok_to_proceed(ok):
  if ok:
    global halt_count = 0
  else:
    global halt_count = 99
  end
end
#
# Thread to listen for abort messages while grinding
######################################################################################


######################################################################################
# TOP LEVEL GRIND FUNCTIONS
#
# Grind along a line dx_mm x dy_mm centered on current tool position. Repeat n_cycles times. If stay_in_contact, stay_in_contact at end.
def grind_line(dx_mm, dy_mm, n_cycles, stay_in_contact):
  if n_cycles < 1:
    return True
  end

  # Unit conversion
  dx_m = dx_mm / 1000.0
  dy_m = dy_mm / 1000.0
  radius_m = robot_part_geometry[1] / 2000.0
  drx_rad = dx_m / radius_m
  dry_rad = dy_m / radius_m

  # Grind time estimate
  time_ms = sqrt(dx_mm * dx_mm + dy_mm * dy_mm) * n_cycles / grind_linear_vel_mps + 1500
  socket_send_integer("robot_step_time_estimate_ms", time_ms)

  # Swapping sphere axes here since RY is aligned with the X of the FLAT and CYLINDER geometries
  if not set_grind_process_state(True,
    [
      p[-dx_m / 2.0, -dy_m / 2.0, 0, 0, 0, 0],
      p[-dx_m / 2.0, 0, 0, -dry_rad / 2.0, 0, 0],
      p[0, 0, 0, -dry_rad / 2.0, -drx_rad / 2.0, 0]
    ]):
    return False
  end

  # Grind the pattern
  imover_realtime(True)
  start_user_timer()
  shape = robot_part_geometry[0]
  if shape == 1:
    pattern_line_flat(dx_m, dy_m, n_cycles)
  elif shape == 2:
    pattern_line_cylinder(dx_m, dry_rad, n_cycles)
  elif shape == 3:
    # Swapping axes here since RY is aligned with the X of the FLAT and CYLINDER geometries
    pattern_line_sphere(dry_rad, drx_rad, n_cycles)
  end
  stop_user_timer()

  if not stay_in_contact or not ok_to_proceed():
    set_grind_process_state(False)
  end
  return True
end

# Grind along a rect dx_mm x dy_mm centered on current tool position. Repeat n_cycles times. If stay_in_contact, stay_in_contact at end.
# Move in x direction first, then y
def grind_rect(dx_mm, dy_mm, n_cycles, stay_in_contact):
  if n_cycles < 1:
    return True
  end

  # Unit conversion
  dx_m = dx_mm / 1000.0
  dy_m = dy_mm / 1000.0
  diam_m = robot_part_geometry[1] / 1000.0
  radius_m = diam_m / 2.0
  drx_rad = dx_m / radius_m
  dry_rad = dy_m / radius_m

  # Grind time estimate
  time_ms = 2 * (dx_mm + dy_mm) * n_cycles / grind_linear_vel_mps + 1500
  socket_send_integer("robot_step_time_estimate_ms", time_ms)

  # Swapping sphere axes here since RY is aligned with the X of the FLAT and CYLINDER geometries
  # 4-point Version
  #if not set_grind_process_state(True,
  #  [
  #    p[-dx_m / 2.0, -dy_m / 2.0, 0, 0, 0, 0],
  #    p[-dx_m / 2.0, 0, 0, -dry_rad / 2.0, 0, 0],
  #    p[0, 0, 0, -dry_rad / 2.0, -drx_rad / 2.0, 0]
  #  ]):
  #  return False
  #end

  # 8-point Version
  if not set_grind_process_state(True,
    [
      p[-dx_m / 2.0 + grind_linear_blend_radius_m * 2, -dy_m / 2.0, 0, 0, 0, 0],
      p[-dx_m / 2.0 + grind_linear_blend_radius_m * 2, 0, 0, -dry_rad / 2.0, 0, 0],
      p[0, 0, 0, -dry_rad / 2.0 + grind_angular_blend_radius_rad * 8, -drx_rad / 2.0, 0]
    ]):
    return False
  end

  # Grind the pattern
  imover_realtime(True)
  start_user_timer()
  shape = robot_part_geometry[0]
  if shape == 1:
    pattern_rect_flat(dx_m, dy_m, n_cycles)
  elif shape == 2:
    pattern_rect_cylinder(dx_m, dry_rad, n_cycles)
  elif shape == 3:
    # Swapping sphere axes here since RY is aligned with the X of the FLAT and CYLINDER geometries
    pattern_rect_sphere(dry_rad, drx_rad, n_cycles)
  end
  stop_user_timer()

  if not stay_in_contact or not ok_to_proceed():
    set_grind_process_state(False)
  end
  return True
end

# Grind along a rect in serpentine dx_mm,dy_mm incrementing by xstep_mm,ystep_mm centered on current tool position. Repeat n_cycles times. If stay_in_contact, stay_in_contact at end.
# Move in x direction first, then y
def grind_serpentine(dx_mm, dy_mm, n_xsteps, n_ysteps, n_cycles, stay_in_contact):
  if n_cycles < 1:
    return True
  end

  # Either n_xsteps or n_ysteps must be 1. Whichever one is one will be the direction of the first move.
  if n_xsteps != 1 and n_ysteps != 1:
    return False
  end

  # Unit conversion
  dx_m = dx_mm / 1000.0
  dy_m = dy_mm / 1000.0
  part_radius_m = robot_part_geometry[1] / 2000.0
  drx_rad = dx_m / part_radius_m
  dry_rad = dy_m / part_radius_m

  # Grind time estimate
  # Per Cycle:
  # 1,3 does 4 passes in x and 1 in y     3,1 does 4 passes in Y and 1 in X
  #   ########################            #  ####  #
  #                          #            #  #  #  #
  #   ########################            #  #  #  #
  #   #                                   #  #  #  #
  #   ########################            #  #  #  #
  #                          #            #  #  #  #
  #   ########################            ####  ####
  if n_xsteps == 1:
    time_ms = (dx_mm * (n_ysteps + 1) + dy_mm) * n_cycles / grind_linear_vel_mps + 1500
  else:
    time_ms = (dx_mm + dy_mm * (n_xsteps + 1)) * n_cycles / grind_linear_vel_mps + 1500
  end
  socket_send_integer("robot_step_time_estimate_ms", time_ms)

  # Swapping sphere axes here since RY is aligned with the X of the FLAT and CYLINDER geometries
  if not set_grind_process_state(True,
    [
      p[-dx_m / 2.0, -dy_m / 2.0, 0, 0, 0, 0],
      p[-dx_m / 2.0, 0, 0, -dry_rad / 2.0, 0, 0],
      p[0, 0, 0, -dry_rad / 2.0, -drx_rad / 2.0, 0]
    ]):
    return False
  end

  # Grind the pattern
  imover_realtime(True)
  start_user_timer()
  shape = robot_part_geometry[0]
  if shape == 1:
    pattern_serpentine_flat(dx_m, dy_m, n_xsteps, n_ysteps, n_cycles)
  elif shape == 2:
    pattern_serpentine_cylinder(dx_m, dry_rad, n_xsteps, n_ysteps, n_cycles)
  elif shape == 3:
    # Swapping axes here since RY is aligned with the X of the FLAT and CYLINDER geometries
    pattern_serpentine_sphere(dry_rad, drx_rad, n_ysteps, n_xsteps, n_cycles)
  end
  stop_user_timer()

  if not stay_in_contact or not ok_to_proceed():
    set_grind_process_state(False)
  end
  return True
end

# Grind along a polygon with circle_diam_mm and n_sides. Repeat n_cycles times. If stay_in_contact, stay_in_contact at end.
def grind_poly(circle_diam_mm, n_sides, n_cycles, stay_in_contact):
  if n_cycles < 1:
    return True
  end

  # Unit conversion
  local circle_diam_m = circle_diam_mm / 1000.0
  local part_diam_m = robot_part_geometry[1] / 1000.0

  # Grind time estimate
  local time_ms = MATH_PI * circle_diam_mm * n_cycles / grind_linear_vel_mps + 1500
  socket_send_integer("robot_step_time_estimate_ms", time_ms)

  if not set_grind_process_state(True,
    [
      p[-circle_diam_m / 2.0, 0, 0, 0, 0, 0],
      p[-circle_diam_m / 2.0, 0, 0, 0, 0, 0],
      p[0, 0, 0, -circle_diam_m / part_diam_m, 0, 0]
    ]):
    return False
  end

  # Grind the pattern
  imover_realtime(True)
  start_user_timer()
  local shape = robot_part_geometry[0]
  if shape == 1:
    pattern_poly_flat(circle_diam_m, n_sides, n_cycles)
  elif shape == 2:
    pattern_poly_cylinder(circle_diam_m, n_sides, part_diam_m, n_cycles)
  elif shape == 3:
    pattern_poly_sphere(circle_diam_m, n_sides, part_diam_m, n_cycles)
  end
  stop_user_timer()

  if not stay_in_contact or not ok_to_proceed():
    set_grind_process_state(False)
  end
  return True
end

# Grind along a circle with circle_diam_mm. Repeat n_cycles times. If stay_in_contact, stay_in_contact at end.
def grind_circle(circle_diam_mm, n_cycles, stay_in_contact):
  if n_cycles < 1:
    return True
  end

  # Unit conversion
  local circle_diam_m = circle_diam_mm / 1000.0
  local part_diam_m = robot_part_geometry[1] / 1000.0

  # Grind time estimate
  local time_ms = MATH_PI * circle_diam_mm * n_cycles / grind_linear_vel_mps + 1500
  socket_send_integer("robot_step_time_estimate_ms", time_ms)

  if not set_grind_process_state(True,
    [
      p[-circle_diam_m / 2.0, 0, 0, 0, 0, 0],
      p[-circle_diam_m / 2.0, 0, 0, 0, 0, 0],
      p[0, 0, 0, -circle_diam_m / part_diam_m, 0, 0]
    ]):
    return False
  end

  # Grind the pattern
  imover_realtime(False) # True seems to workl!?
  start_user_timer()
  local shape = robot_part_geometry[0]
  if shape == 1:
    pattern_circle_flat(circle_diam_m, n_cycles)
  elif shape == 2:
    pattern_circle_cylinder(circle_diam_m, part_diam_m, n_cycles)
  elif shape == 3:
    pattern_circle_sphere(circle_diam_m, part_diam_m, n_cycles)
  end
  stop_user_timer()

  if not stay_in_contact or not ok_to_proceed():
    set_grind_process_state(False)
  end
  return True

  if grind_linear_blend_radius_m > 0.0:
    # Try setting n_sides to 1.5 blend radii
    local circum_m = MATH_PI * circle_diam_mm / 1000.
    global grind_circle_n_sides = ceil(circum_m / (grind_linear_blend_radius_m * 1.5))
  end
  return grind_poly(circle_diam_mm, grind_circle_n_sides, n_cycles, stay_in_contact)
end

# Grind along a spiral circle1_diam_mm to circle2_diam_mm in n_revolutions with rotations centered on current tool position. Repeat n_cycles times. If stay_in_contact, stay_in_contact at end.
def grind_spiral(circle1_diam_mm, circle2_diam_mm, n_revolutions, n_cycles, stay_in_contact):
  if n_cycles < 1:
    return True
  end

  # Unit conversion
  local circle1_diam_m = circle1_diam_mm / 1000.0
  local circle2_diam_m = circle2_diam_mm / 1000.0
  local part_diam_m = robot_part_geometry[1] / 1000.0

  # Grind time estimate based on average diam
  local avg_diam_mm = (circle1_diam_mm + circle2_diam_mm) / 2.0
  local time_ms = MATH_PI * avg_diam_mm * n_revolutions * n_cycles / grind_linear_vel_mps + 1500
  socket_send_integer("robot_step_time_estimate_ms", time_ms)

  if not set_grind_process_state(True,
    [
      p[-circle1_diam_m / 2.0, 0, 0, 0, 0, 0],
      p[-circle1_diam_m / 2.0, 0, 0, 0, 0, 0],
      p[0, 0, 0, -circle1_diam_m / part_diam_m, 0, 0]
    ]):
    return False
  end

  # Grind the pattern
  imover_realtime(False) # True fails!?
  start_user_timer()
  local shape = robot_part_geometry[0]
  if shape == 1:
    pattern_spiral_flat(circle1_diam_m, circle2_diam_m, n_revolutions, n_cycles)
  elif shape == 2:
    pattern_spiral_cylinder(circle1_diam_m, circle2_diam_m, n_revolutions, part_diam_m, n_cycles)
  elif shape == 3:
    pattern_spiral_sphere(circle1_diam_m, circle2_diam_m, n_revolutions, part_diam_m, n_cycles)
  end
  stop_user_timer()

  if not stay_in_contact or not ok_to_proceed():
    set_grind_process_state(False)
  end
  return True
end


######################################################################################
######################################################################################
#
# PATTERN GRINDING FUNCTIONS
#

######################################################################################
# LINE PATTERNS
#
# The line pattern sequence.
# Assumes all point_dist are declared globally
def pattern_line(n_cycles):
  global grind_cycle = 1
  local dpdest = dp2
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_send_integer("grind_cycle", grind_cycle)

    draw_finish(dpdest)

    if dpdest == dp1:
      dpdest = dp2
    else:
      dpdest = dp1
    end

    grind_cycle = grind_cycle + 1
  end
end

# Move along a flat line dx_m x dy_m. Repeat n_cycles times.
# Move in x direction first, then y
def pattern_line_flat(dx_m, dy_m, n_cycles):
  local x2 = dx_m / 2.0
  local y2 = dy_m / 2.0

  global dp1 = dp_from_contact_center
  global dp2 = p[x2, y2, 0, 0, 0, 0]

  pattern_line(n_cycles)
end

# Move along a cylindrical line dx_m x dy_m. Repeat n_cycles times.
# Move in x direction first, then y
def pattern_line_cylinder(dx_m, drx_rad, n_cycles):
  local x2 = dx_m / 2.0
  local rx2 = drx_rad / 2.0

  global dp1 = dp_from_contact_center
  global dp2 = p[x2, 0, 0, rx2, 0, 0]

  # Cyline calibration is all done using lines on cylinders
  if cyline_cal_enabled:
    start_cal_timer()
  end

  pattern_line(n_cycles)

  # Cyline calibration cleanup
  if cyline_cal_enabled:
    local t = stop_cal_timer()
    adjust_cyline_coefficient(t)
  end
end

# Move along a sphere line dx_m x dy_m. Repeat n_cycles times.
# Move in x direction first, then y
def pattern_line_sphere(drx_rad, dry_rad, n_cycles):
  local rx2 = drx_rad / 2.0
  local ry2 = dry_rad / 2.0

  global dp1 = dp_from_contact_center
  global dp2 = p[0, 0, 0, rx2, ry2, 0]

  pattern_line(n_cycles)
end

######################################################################################
# RECT PATTERNS
#
# The rect pattern sequence. Assumes all points are defined globally!
def pattern_rect(n_cycles):
  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_send_integer("grind_cycle", grind_cycle)

    # 4-point version (With blend)
    # Fails for blend radius/sanity check when in contact
    #draw_to(dp2)
    #draw_to(dp3)
    #draw_to(dp4)
    #if grind_cycle == n_cycles:
    #  draw_finish(dp1)
    #else:
    #  draw_to(dp1)
    #end

    # 4-point version (Without blend)
    #draw_finish(dp2)
    #draw_finish(dp3)
    #draw_finish(dp4)
    #draw_finish(dp1)

    # 8-point version (With blend)
    # Fails for blend radius/sanity check when in contact
    #draw_to(dp2a)
    #draw_to(dp2b)
    #draw_to(dp3a)
    #draw_to(dp3b)
    #draw_to(dp4a)
    #draw_to(dp4b)
    #draw_to(dp1a)
    #if grind_cycle == n_cycles:
    #  draw_finish(dp1b)
    #else:
    #  draw_to(dp1b)
    #end

    # 8-point version (Without blend)
    draw_finish(dp2a)
    draw_finish(dp2b)
    draw_finish(dp3a)
    draw_finish(dp3b)
    draw_finish(dp4a)
    draw_finish(dp4b)
    draw_finish(dp1a)
    draw_finish(dp1b)

    grind_cycle = grind_cycle + 1
  end
end

# Move along a flat rect dx_m x dy_m. Repeat n_cycles times.
# Move in x direction first, then y
def pattern_rect_flat(dx_m, dy_m, n_cycles):
  local x2 = dx_m / 2.0
  local y2 = dy_m / 2.0

  local dx = grind_linear_blend_radius_m * 2

  global dp1 = p[-x2, -y2, 0, 0, 0, 0]
  global dp1a = dp1
  global dp1b = dp1
  dp1a[1] = dp1a[1] + dx
  dp1b[0] = dp1b[0] + dx

  global dp2 = p[x2, -y2, 0, 0, 0, 0]
  global dp2a = dp2
  global dp2b = dp2
  dp2a[0] = dp2a[0] - dx
  dp2b[1] = dp2b[1] + dx

  global dp3 = p[x2, y2, 0, 0, 0, 0]
  global dp3a = dp3
  global dp3b = dp3
  dp3a[1] = dp3a[1] - dx
  dp3b[0] = dp3b[0] - dx

  global dp4 = p[-x2, y2, 0, 0, 0, 0]
  global dp4a = dp4
  global dp4b = dp4
  dp4a[0] = dp4a[0] + dx
  dp4b[1] = dp4b[1] - dx

  pattern_rect(n_cycles)
end

# Move along a cylindrical rect dx_mm,drx_rad. Repeat n_cycles times.
# Move in x direction first, then rx
def pattern_rect_cylinder(dx_m, drx_rad, n_cycles):
  local x2 = dx_m / 2.0
  local rx2 = drx_rad / 2.0

  local dx = grind_linear_blend_radius_m * 2
  local da = grind_angular_blend_radius_rad * 8

  global dp1 = p[-x2, 0, 0, -rx2, 0, 0]
  global dp1a = dp1
  global dp1b = dp1
  dp1a[3] = dp1a[3] + da
  dp1b[0] = dp1b[0] + dx

  global dp2 = p[x2, 0, 0, -rx2, 0, 0]
  global dp2a = dp2
  global dp2b = dp2
  dp2a[0] = dp2a[0] - dx
  dp2b[3] = dp2b[3] + da

  global dp3 = p[x2, 0, 0, rx2, 0, 0]
  global dp3a = dp3
  global dp3b = dp3
  dp3a[3] = dp3a[3] - da
  dp3b[0] = dp3b[0] - dx

  global dp4 = p[-x2, 0, 0, rx2, 0, 0]
  global dp4a = dp4
  global dp4b = dp4
  dp4a[0] = dp4a[0] + dx
  dp4b[3] = dp4b[3] - da

  pattern_rect(n_cycles)
end

# Move along a spherical rect drx_rad,dry_rad. Repeat n_cycles times.
# Move in rx direction first, then ry
def pattern_rect_sphere(drx_rad, dry_rad, n_cycles):
  local rx2 = drx_rad / 2.0
  local ry2 = dry_rad / 2.0

  local da = grind_angular_blend_radius_rad * 8

  global dp1 = p[0, 0, 0, -rx2, -ry2, 0]
  global dp1a = dp1
  global dp1b = dp1
  dp1a[4] = dp1a[4] + da
  dp1b[3] = dp1b[3] + da

  global dp2 = p[0, 0, 0, rx2, -ry2, 0]
  global dp2a = dp2
  global dp2b = dp2
  dp2a[3] = dp2a[3] - da
  dp2b[4] = dp2b[4] + da

  global dp3 = p[0, 0, 0, rx2, ry2, 0]
  global dp3a = dp3
  global dp3b = dp3
  dp3a[4] = dp3a[4] - da
  dp3b[3] = dp3b[3] - da

  global dp4 = p[0, 0, 0, -rx2, ry2, 0]
  global dp4a = dp4
  global dp4b = dp4
  dp4a[3] = dp4a[3] + da
  dp4b[4] = dp4b[4] - da

  pattern_rect(n_cycles)
end

######################################################################################
# SERPENTINE PATTERNS
#
# Move along a flat serpentine dx_m,dy_m in n_xsteps,n_ysteps. Repeat n_cycles times.
# Move in direction of whichever nsteps is 1 first
def pattern_serpentine_flat(dx_m, dy_m, n_xsteps, n_ysteps, n_cycles):
  local t_move_x = dx_m / grind_linear_vel_mps
  local t_move_y = dy_m / grind_linear_vel_mps

  # Bottom left corner, grid 0,0
  local x2 = dx_m / 2.0
  local y2 = dy_m / 2.0
  local dp1 = dp_from_contact_center
  local dp2 = dp1

  # Track our grid square number... we're in [0,0] and moving [+1,+1] in either x or y
  local x_grid = 0
  local y_grid = 0
  local x_incr = 1
  local y_incr = 1
  local grid_dx_m = dx_m / n_xsteps
  local grid_dy_m = dy_m / n_ysteps

  # How many moves does it take to complete a pass?
  global n_moves_per_pass = (n_xsteps + n_ysteps) * 2 - 1

  local move_count = 0
  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    # This will repeat for each leg of the serpentine!
    socket_send_integer("grind_cycle", grind_cycle)

    # Skip first X move if we should start with a y move
    if move_count != 0 or n_xsteps == 1:
      # Advance x_grid by x_incr
      x_grid = x_grid + x_incr

      # Move to the corresponding position
      local dp = p[x_grid * grid_dx_m - x2, y_grid * grid_dy_m - y2, 0, 0, 0, 0]
      if move_count == n_moves_per_pass:
        draw_finish(dp)
      else:
        #draw_to(dp, r = 0)  # No blend
        draw_to(dp)  # Use blend
      end

      # Adjust x direction
      if x_grid >= n_xsteps:
        x_incr = -1
      elif x_grid <= 0:
        x_incr = 1
      end
      move_count = move_count + 1
    end

    if ok_to_proceed() and move_count < n_moves_per_pass:
      # Advance y_grid by y_incr
      y_grid = y_grid + y_incr

      # Move to the corresponding position
      local dp = p[x_grid * grid_dx_m - x2, y_grid * grid_dy_m - y2, 0, 0, 0, 0]
      if move_count == n_moves_per_pass:
        draw_finish(dp)
      else:
        #draw_to(dp, r = 0)  # No blend
        draw_to(dp)  # Use blend
      end

      # Adjust y direction
      if y_grid >= n_ysteps:
        y_incr = -1
      elif y_grid <= 0:
        y_incr = 1
      end
      move_count = move_count + 1
    end

    # Detect when we've covered all the grid squares!
    if move_count >= n_moves_per_pass:
      grind_cycle = grind_cycle + 1
      move_count = 0
    end
  end
end

# Move along a cylindrical serpentine dx_m,drx_rad in n_xsteps,n_rxsteps. Repeat n_cycles times.
# Move in direction of whichever nsteps is 1 first
def pattern_serpentine_cylinder(dx_m, drx_rad, n_xsteps, n_rxsteps, n_cycles):
  local t_move_x = dx_m / grind_linear_vel_mps
  local t_move_rx = drx_rad / grind_angular_vel_rps / 4

  # Bottom left corner, grid 0,0
  local x2 = dx_m / 2.0
  local rx2 = drx_rad / 2.0
  local dp1 = dp_from_contact_center
  local dp2 = dp1

  # Track our grid square number... we're in [0,0] and moving [+1,+1] in either x or y
  local x_grid = 0
  local y_grid = 0
  local x_incr = 1
  local y_incr = 1
  local grid_dx_m = dx_m / n_xsteps
  local grid_drx_rad = drx_rad / n_rxsteps
  local last_a = grind_linear_accel_mpss
  local last_v = grind_linear_vel_mps

  # How many moves does it take to complete a pass?
  global n_moves_per_pass = (n_xsteps + n_rxsteps) * 2 - 1

  local move_count = 0
  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    # This will repeat for each leg of the serpentine!
    socket_send_integer("grind_cycle", grind_cycle)

    # Skip first X move if we should start with a y move
    if move_count != 0 or n_xsteps == 1:
      # Advance x_grid by x_incr
      x_grid = x_grid + x_incr

      # Move to the corresponding position
      local dp = p[x_grid * grid_dx_m - x2, 0, 0, y_grid * grid_drx_rad - rx2, 0, 0]
      if move_count == n_moves_per_pass:
        draw_finish(dp)
      else:
        #draw_to(dp, r = 0)  # No blend
        draw_to(dp)  # Use blend
      end

      # Adjust x direction
      if x_grid >= n_xsteps:
        x_incr = -1
      elif x_grid <= 0:
        x_incr = 1
      end
      move_count = move_count + 1
    end

    if ok_to_proceed() and move_count < n_moves_per_pass:
      # Advance y_grid by y_incr
      y_grid = y_grid + y_incr

      # Move to the corresponding position
      local dp = p[x_grid * grid_dx_m - x2, 0, 0, y_grid * grid_drx_rad - rx2, 0, 0]
      if move_count == n_moves_per_pass:
        draw_finish(dp)
      else:
        #draw_to(dp, r = 0)  # No blend
        draw_to(dp)  # Use blend
      end

      # Adjust y direction
      if y_grid >= n_rxsteps:
        y_incr = -1
      elif y_grid <= 0:
        y_incr = 1
      end
      move_count = move_count + 1
    end

    # Detect when we've covered all the grid squares!
    if move_count >= n_moves_per_pass:
      grind_cycle = grind_cycle + 1
      move_count = 0
    end
  end
end

# Move along a spherical serpentine drx_rad,dry_rad in n_rxsteps,n_rysteps. Repeat n_cycles times.
# Move in direction of whichever nsteps is 1 first
def pattern_serpentine_sphere(drx_rad, dry_rad, n_rxsteps, n_rysteps, n_cycles):
  local t_move_rx = drx_rad / grind_angular_vel_rps / 4
  local t_move_ry = dry_rad / grind_angular_vel_rps / 4

  # Bottom left corner, grid 0,0
  local rx2 = drx_rad / 2.0
  local ry2 = dry_rad / 2.0
  local dp1 = dp_from_contact_center
  local dp2 = dp1

  # Track our grid square number... we're in [0,0] and moving [+1,+1] in either x or y
  local x_grid = 0
  local y_grid = 0
  local x_incr = 1
  local y_incr = 1
  local grid_drx_rad = drx_rad / n_rxsteps
  local grid_dry_rad = dry_rad / n_rysteps

  # How many moves does it take to complete a pass?
  global n_moves_per_pass = (n_rxsteps + n_rysteps) * 2 - 1

  local move_count = 0
  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    # This will repeat for each leg of the serpentine!
    socket_send_integer("grind_cycle", grind_cycle)

    # Skip first X move if we should start with a y move
    if move_count != 0 or n_rxsteps == 1:
      # Advance x_grid by x_incr
      x_grid = x_grid + x_incr

      # Move to the corresponding position
      local dp = p[0, 0, 0, x_grid * grid_drx_rad - rx2, y_grid * grid_dry_rad - ry2, 0]
      if move_count == n_moves_per_pass:
        draw_finish(dp)
      else:
        #draw_to(dp, r = 0)  # No blend
        draw_to(dp)  # Use blend
      end

      # Adjust x direction
      if x_grid >= n_rxsteps:
        x_incr = -1
      elif x_grid <= 0:
        x_incr = 1
      end
      move_count = move_count + 1
    end

    if ok_to_proceed() and move_count < n_moves_per_pass:
      # Advance y_grid by y_incr
      y_grid = y_grid + y_incr

      # Move to the corresponding position
      local dp = p[0, 0, 0, x_grid * grid_drx_rad - rx2, y_grid * grid_dry_rad - ry2, 0]
      if move_count == n_moves_per_pass:
        draw_finish(dp)
      else:
        #draw_to(dp, r = 0)  # No blend
        draw_to(dp)  # Use blend
      end

      # Adjust y direction
      if y_grid >= n_rysteps:
        y_incr = -1
      elif y_grid <= 0:
        y_incr = 1
      end
      move_count = move_count + 1
    end

    # Detect when we've covered all the grid squares!
    if move_count >= n_moves_per_pass:
      grind_cycle = grind_cycle + 1
      move_count = 0
    end
  end
end

######################################################################################
# POLYGONAL PATTERNS
#
# Grind along a polygon with circle_diam_m and n_sides on a flat. Repeat n_cycles times.
def pattern_poly_flat(circle_diam_m, n_sides, n_cycles):
  local circle_radius_m = circle_diam_m / 2.0

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_send_integer("grind_cycle", grind_cycle)
    local i = 0
    while ok_to_proceed() and i <= n_sides:
      local theta = d2r(180.0 + 360.0 * i / n_sides)
      local x = circle_radius_m * cos(theta)
      local y = circle_radius_m * sin(theta)

      local dp = p[x, y, 0, 0, 0, 0]
      if not ok_to_proceed() or i == n_sides:
        draw_finish(dp)
      else:
        #draw_to(dp, r = 0)  # No blend
        draw_to(dp)  # Use blend
      end
      i = i + 1
    end

    grind_cycle = grind_cycle + 1
  end
end

# Grind along a polygon with circle_diam_m and n_sides on a cylinder_radius_m. Repeat n_cycles times.
def pattern_poly_cylinder(circle_diam_m, n_sides, cylinder_radius_m, n_cycles):
  local circle_radius_m = circle_diam_m / 2.0

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_send_integer("grind_cycle", grind_cycle)
    local i = 0
    while ok_to_proceed() and i <= n_sides:
      local theta = d2r(180.0 + 360.0 * i / n_sides)
      local x = circle_radius_m * cos(theta)
      local y = circle_radius_m * sin(theta)
      local rx = 2.0 * y / cylinder_radius_m

      local dp = p[x, 0, 0, rx, 0, 0]
      if not ok_to_proceed() or i == n_sides:
        draw_finish(dp)
      else:
        #draw_to(dp, r = 0)  # No blend
        draw_to(dp)  # Use blend
      end
      i = i + 1
    end

    grind_cycle = grind_cycle + 1
  end
end

# Grind along a polygon with circle_diam_m and n_sides on a sphere_diam_m. Repeat n_cycles times.
def pattern_poly_sphere(circle_diam_m, n_sides, sphere_diam_m, n_cycles):
  local circle_radius_m = circle_diam_m / 2.0
  local sphere_radius_m = sphere_diam_m / 2.0

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_send_integer("grind_cycle", grind_cycle)
    local i = 0
    while ok_to_proceed() and i <= n_sides:
      local theta = d2r(180.0 + 360.0 * i / n_sides)
      local x = circle_radius_m * cos(theta)
      local rx = x / sphere_radius_m
      local y = circle_radius_m * sin(theta)
      local ry = y / sphere_radius_m

      local dp = p[0, 0, 0, rx, ry, 0]
      if not ok_to_proceed() or i == n_sides:
        draw_finish(dp)
      else:
        #draw_to(dp, r = 0)  # No blend
        draw_to(dp)  # Use blend
      end
      i = i + 1
    end

    grind_cycle = grind_cycle + 1
  end
end

######################################################################################
# CIRCULAR PATTERNS
#
global grind_circle_n_sides = 0
# How many points should we use for a circle diam_m at speed_mps?
def recommend_npoints(diam_m, speed_mps):
  local n_points_per_second = 2
  local circum_m = MATH_PI * diam_m

  # Calc 1: Interrupt rate
  # Want at least so many points per second
  local t_circle = circum_m / speed_mps
  global grind_circle_n_sides1 = limiter(ceil(t_circle * grind_point_frequency_hz), 2, 1000)

  # Calc 2: Smoothness
  # 100mm diam gets 50 points... seems about right
  global grind_circle_n_sides2 = limiter(diam_m * 500, 2, 1000)

  global grind_circle_n_sides = max(grind_circle_n_sides1, grind_circle_n_sides2)

  global grind_circle_n_sides3 = 0
  if grind_linear_blend_radius_m > 0.001:
    # Calc 3: Stay ahead of blend radius
    # Do a point every 3 blend radii
    global grind_circle_n_sides3 = limiter(ceil(circum_m / (grind_linear_blend_radius_m * 3)), 2, 1000)
    global grind_circle_n_sides = max(grind_circle_n_sides, grind_circle_n_sides3)
  end

  socket_send_num("aa_grind_circle_n_sides1", grind_circle_n_sides1)
  socket_send_num("aa_grind_circle_n_sides2", grind_circle_n_sides2)
  socket_send_num("aa_grind_circle_n_sides3", grind_circle_n_sides3)
  socket_send_num("aa_grind_circle_n_sides", grind_circle_n_sides)
  return grind_circle_n_sides
end

# Grind along a circle with circle_diam_m on a flat. Repeat n_cycles times.
def pattern_circle_flat(circle_diam_m, n_cycles):
  local circle_radius_m = circle_diam_m / 2.0
  local n_points = recommend_npoints(circle_diam_m, grind_linear_vel_mps)

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_send_integer("grind_cycle", grind_cycle)
    local i = 0
    while ok_to_proceed() and i <= n_points:
      local theta = d2r(180.0 + 360.0 * i / n_points)
      local x = circle_radius_m * cos(theta)
      local y = circle_radius_m * sin(theta)

      local dp = p[x, y, 0, 0, 0, 0]
      if not ok_to_proceed() or i == n_points:
        draw_finish(dp)
      else:
        draw_to(dp)
      end
      i = i + 1
    end

    grind_cycle = grind_cycle + 1
  end
end

# Grind along a circle with circle_diam_m on a cylinder_radius_m. Repeat n_cycles times.
def pattern_circle_cylinder(circle_diam_m, cylinder_radius_m, n_cycles):
  local circle_radius_m = circle_diam_m / 2.0
  local n_points = recommend_npoints(circle_diam_m, grind_linear_vel_mps)

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_send_integer("grind_cycle", grind_cycle)
    local i = 0
    while ok_to_proceed() and i <= n_points:
      local theta = d2r(180.0 + 360.0 * i / n_points)
      local x = circle_radius_m * cos(theta)
      local y = circle_radius_m * sin(theta)
      local rx = 2.0 * y / cylinder_radius_m

      local dp = p[x, 0, 0, rx, 0, 0]
      if not ok_to_proceed() or i == n_points:
        draw_finish(dp)
      else:
        draw_to(dp)
      end
      i = i + 1
    end

    grind_cycle = grind_cycle + 1
  end
end

# Grind along a circle with circle_diam_m on a sphere_diam_m. Repeat n_cycles times.
def pattern_circle_sphere(circle_diam_m, sphere_diam_m, n_cycles):
  local circle_radius_m = circle_diam_m / 2.0
  local sphere_radius_m = sphere_diam_m / 2.0
  local n_points = recommend_npoints(circle_diam_m, grind_linear_vel_mps)

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_send_integer("grind_cycle", grind_cycle)
    local i = 0
    while ok_to_proceed() and i <= n_points:
      local theta = d2r(180.0 + 360.0 * i / n_points)
      local x = circle_radius_m * cos(theta)
      local rx = x / sphere_radius_m
      local y = circle_radius_m * sin(theta)
      local ry = y / sphere_radius_m

      local dp = p[0, 0, 0, rx, ry, 0]
      if not ok_to_proceed() or i == n_points:
        draw_finish(dp)
      else:
        draw_to(dp)
      end
      i = i + 1
    end

    grind_cycle = grind_cycle + 1
  end
end

######################################################################################
# SPIRAL PATTERNS
#
# Grind a flat spiral from diam1 to diam2 in n_revolutions revolutions
def new_pattern_spiral_flat(circle1_diam_m, circle2_diam_m, n_revolutions, n_cycles):
  local max_diam_m = max(circle1_diam_m, circle2_diam_m)
  local circle1_radius_m = circle1_diam_m / 2.0
  local circle2_radius_m = circle2_diam_m / 2.0

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_send_integer("grind_cycle", grind_cycle)

    # Initial conditions
    local theta = d2r(180.0)
    local r_m = circle1_radius_m
    local revs_completed = 0.0
    local rev_slope = (circle2_radius_m - circle1_radius_m) / n_revolutions
    local move_m = grind_linear_blend_radius_m * 2
    #socket_send_num("aa_rev_slope", rev_slope)
    #socket_send_num("aa_move_m", move_m)
    #socket_send_num("aa_revs_completed", revs_completed)
    #socket_send_num("aa_r_m", r_m)

    while ok_to_proceed() and revs_completed < n_revolutions:
      local delta_theta = move_m / r_m
      local theta = theta + delta_theta
      #socket_send_num("aa_delta_theta", delta_theta)
      #socket_send_num("aa_theta", theta)
      local x = r_m * cos(theta)
      local y = r_m * sin(theta)

      local dp = p[x, y, 0, 0, 0, 0]
      if not ok_to_proceed() or revs_completed >= n_revolutions:
        draw_finish(dp)
      else:
        draw_to(dp)
      end

      local revs_completed = revs_completed + delta_theta / (2 * MATH_PI)
      local r_m = circle1_radius_m + rev_slope * revs_completed
      #socket_send_num("aa_revs_completed", revs_completed)
      #socket_send_num("aa_r_m", r_m)
    end

    grind_cycle = grind_cycle + 1

    # Next cycle- swap diameters so we go in/out/in etc.
    local old_circle1_radius_m = circle1_radius_m
    local circle1_radius_m = circle2_radius_m
    local circle2_radius_m = old_circle1_radius_m
  end
end

# Grind a flat spiral from diam1 to diam2 in n_revolutions revolutions
def pattern_spiral_flat(circle1_diam_m, circle2_diam_m, n_revolutions, n_cycles):
  local max_diam_m = max(circle1_diam_m, circle2_diam_m)
  local n_points = recommend_npoints(max_diam_m, grind_linear_vel_mps)
  local n_total_points = n_revolutions * n_points
  local circle1_radius_m = circle1_diam_m / 2.0
  local circle2_radius_m = circle2_diam_m / 2.0

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_send_integer("grind_cycle", grind_cycle)

    local rslope = (circle2_radius_m - circle1_radius_m) / n_total_points
    local i = 0
    while ok_to_proceed() and i <= n_total_points:
      local theta = d2r(180.0 + 360.0 * (i % n_points) / n_points)
      local r_instantaneous = i * rslope + circle1_radius_m
      local x = r_instantaneous * cos(theta)
      local y = r_instantaneous * sin(theta)

      local dp = p[x, y, 0, 0, 0, 0]
      if not ok_to_proceed() or i == n_total_points:
        draw_finish(dp)
      else:
        draw_to(dp)
      end
      i = i + 1
    end

    grind_cycle = grind_cycle + 1

    # Next cycle- swap diameters so we go in/out/in etc.
    local old_circle1_radius_m = circle1_radius_m
    local circle1_radius_m = circle2_radius_m
    local circle2_radius_m = old_circle1_radius_m
  end
end

# Grind a spiral on a cylinder from diam1 to diam2 in n_revolutions revolutions
def pattern_spiral_cylinder(circle1_diam_m, circle2_diam_m, n_revolutions, cylinder_radius_m, n_cycles):
  local max_diam_m = max(circle1_diam_m, circle2_diam_m)
  local n_points = recommend_npoints(max_diam_m, grind_linear_vel_mps)
  local n_total_points = n_revolutions * n_points
  local circle1_radius_m = circle1_diam_m / 2.0
  local circle2_radius_m = circle2_diam_m / 2.0

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_send_integer("grind_cycle", grind_cycle)
    local rslope = (circle2_radius_m - circle1_radius_m) / n_total_points
    local i = 0
    while ok_to_proceed() and i <= n_total_points:
      local theta = d2r(180.0 + 360.0 * (i % n_points) / n_points)
      local r_instantaneous = i * rslope + circle1_radius_m
      local x = r_instantaneous * cos(theta)
      local y = r_instantaneous * sin(theta)
      local rx = 2.0 * y / cylinder_radius_m

      local dp = p[x, 0, 0, rx, 0, 0]

      if not ok_to_proceed() or i == n_total_points:
        draw_finish(dp)
      else:
        draw_to(dp)
      end
      i = i + 1
    end
    grind_cycle = grind_cycle + 1

    # Next cycle- swap diameters so we go in/out/in etc.
    local old_circle1_radius_m = circle1_radius_m
    local circle1_radius_m = circle2_radius_m
    local circle2_radius_m = old_circle1_radius_m
  end
end

# Grind a spiral on a sphere from diam1 to diam2 in n_revolutions revolutions
def pattern_spiral_sphere(circle1_diam_m, circle2_diam_m, n_revolutions, sphere_diam_m, n_cycles):
  local max_diam_m = max(circle1_diam_m, circle2_diam_m)
  local n_points = recommend_npoints(max_diam_m, grind_linear_vel_mps)
  local n_total_points = n_revolutions * n_points
  local circle1_radius_m = circle1_diam_m / 2.0
  local circle2_radius_m = circle2_diam_m / 2.0
  local sphere_radius_m = sphere_diam_m / 2.0

  global grind_cycle = 1
  while (ok_to_proceed() and grind_cycle <= n_cycles):
    socket_send_integer("grind_cycle", grind_cycle)
    local rslope = (circle2_radius_m - circle1_radius_m) / n_total_points
    local i = 0
    while ok_to_proceed() and i <= n_total_points:
      local theta = d2r(180.0 + 360.0 * (i % n_points) / n_points)
      local r_instantaneous = i * rslope + circle1_radius_m
      local x = r_instantaneous * cos(theta)
      local rx = x / sphere_radius_m
      local y = r_instantaneous * sin(theta)
      local ry = y / sphere_radius_m

      local dp = p[0, 0, 0, rx, ry, 0]
      if not ok_to_proceed() or i == n_total_points:
        draw_finish(dp)
      else:
        draw_to(dp)
      end
      i = i + 1
    end
    grind_cycle = grind_cycle + 1

    # Next cycle- swap diameters so we go in/out/in etc.
    local old_circle1_radius_m = circle1_radius_m
    local circle1_radius_m = circle2_radius_m
    local circle2_radius_m = old_circle1_radius_m
  end
end