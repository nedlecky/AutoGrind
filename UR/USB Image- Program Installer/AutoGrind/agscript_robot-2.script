# File: agscript_robot-2.script
# Project: AutoGrind
# Author: Ned Lecky, Lecky Engineering LLC
# Purpose: Robot control commands supporting the AutoGrind application

global robot_version = "Rev 2 2022-06-06"

global response = "unknown"
global robot_index = 0
global robot_checkvalue = 0

global robot_linear_speed_mps = 0.2
global robot_linear_accel_mpss = 0.4
global robot_blend_radius_m = 0.003
global robot_joint_speed_rps = 1.0
global robot_joint_accel_rpss = 4.0
global robot_tcp = p[0, 0, 0.175, 0, 0, 0]
global robot_tcp_part = robot_tcp
global robot_payload_mass_kg = 1.0
global robot_payload_cog_m = [0, 0, 0.50]
# Geometry [1=FLAT 2=CYL 3=SPHERE, diameter_mm)
global robot_part_geometry = [0, 0]
global robot_door_closed_input = [-1, -1]
global robot_footswitch_pressed_input = [-1, -1]
global robot_tool_on_outputs = [-1, -1, -1, -1, -1, -1, -1, -1]
global robot_tool_off_outputs = [-1, -1, -1, -1, -1, -1, -1, -1]
global robot_coolant_on_outputs = [-1, -1, -1, -1, -1, -1, -1, -1]
global robot_coolant_off_outputs = [-1, -1, -1, -1, -1, -1, -1, -1]
global robot_freedrive_mode = 0

# command should be[nElements,index,checkval,param[0],param[1],...]
# put index into robot_index
# validate checkval
# Remove both from command so we get command = [nElements-2, param[0], param[1],...]
#global command = [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]
def command_validate():
  # must be at least index, check, and 1 param
  if command[0] < 3:
    command[0] = 0
    return False
  end

  # Now make sure checksum matches what we expect
  global test_index = command[1]
  global test_checksum = command[2]
  if test_checksum != 1000 - test_index:
    command[0] = 0
    return False
  end

  # Now if we are still in the grind state and we are not getting a grind command (40) make sure we're are off the part!
  if grind_process_state and command[3] != 40:
    # Using set_grind_process_state which assumes robot_tcp_part!
    iset_tcp(robot_tcp_part)
    set_grind_process_state(False)
    iset_tcp(robot_tcp)
  end

  # Slide the robot commands and parameters back in command[] to remove the index and checksum
  local i = 3
  while (i < command[0] + 1):
    command[i-2] = command[i]
    i = i + 1
  end
  command[i-1] = 0
  command[i-2] = 0
  command[0] = command[0] - 2    # 2 fewer elements in the array now!

  global robot_index = test_index
  return True
end

# Call this when starting command execution
def command_start():
  global last_comand = command

  # This one signifies we're starting a new command!
  global robot_starting = robot_index
  socket_set_var("robot_starting", robot_starting)
  socket_send_line("robot_ready=False")
end

# Call this when a command is complete
def command_finish():
  local retval = "robot_response=" + response + "#robot_ready=True"
  socket_send_line(retval)

  global robot_completed = robot_index
  socket_set_var("robot_completed", robot_completed)
end

# Set variable interface. Interprets command[2] to select what to set and returns result to socket
# Can also be used for validation and enforcing limits
def set_variable():
  if command[2] == 1:
    # Set speed to s if s>0. Always returns current value
    s = command[3]
    if s > 0:
      robot_linear_speed_mps = ceil(s) / 1000.0
    end
    socket_set_var("robot_linear_speed_mmps", robot_linear_speed_mps * 1000.0)
    global response = "set_linear_speed()"
  elif command[2] == 2:
    # Set accel to a if a>0. Always returns current value
    a = command[3]
    if a > 0:
      robot_linear_accel_mpss = ceil(a) / 1000.0
    end
    socket_set_var("robot_linear_accel_mmpss", robot_linear_accel_mpss * 1000.0)
    global response = "set_linear_accel()"
  elif command[2] == 3:
    # Set blend to b if b>=0. Always returns current value
    b = command[3]
    if b >= 0:
      robot_blend_radius_m = b / 1000.0
    end
    socket_send_string("robot_blend_radius_mm=")
    socket_send_string(robot_blend_radius_m * 1000.0)
    socket_send_lf()
    global response = "set_blend_radius()"
  elif command[2] == 4:
    # Set joint speed to s if s>0. Always returns current value
    s = command[3]
    if s > 0:
      robot_joint_speed_rps = d2r(ceil(s))
    end
    socket_set_var("robot_joint_speed_dps", r2d(robot_joint_speed_rps))
    global response = "set_joint_speed()"
  elif command[2] == 5:
    # Set joint accel to a if a>0. Always returns current value
    a = command[3]
    if a > 0:
      robot_joint_accel_rpss = d2r(ceil(a))
    end
    socket_set_var("robot_joint_accel_dpss", r2d(robot_joint_accel_rpss))
    global response = "set_joint_accel()"
  elif command[2] == 6:
    # Set part_geometry to [shape, diameter_mm] if shape==1,2,3. Always returns "robot_part_geometry=[current geometry]"
    # Also updates robot_part_tcp using update_robot_tcp_part
    shape = command[3]
    if shape == 1:
      robot_part_geometry = [1, 0]
    elif shape == 2 or shape == 3:
      diameter_mm = limiter(command[4], 50, 3000)
      robot_part_geometry = [shape, diameter_mm]
    end

    update_robot_tcp_part()

    socket_send_string("robot_part_geometry=")
    return_vector(robot_part_geometry, 2)
    socket_send_lf()
    global response = "set_part_geometry()"
  elif command[2] == 10:
    # Set door closed input
    if command[3] >= 0:
      robot_door_closed_input[0] = command[3]
      robot_door_closed_input[1] = command[4]
    end

    socket_send_string("robot_door_closed_input=")
    return_vector(robot_door_closed_input, 2)
    socket_send_lf()
    socket_set_var("robot_door_closed", is_door_closed())
    global response = "set_door_closed_input()"
  elif command[2] == 11:
    # Set tool on output
    robot_tool_on_outputs = command_3_padded_8(command)

    socket_send_string("robot_tool_on_outputs=")
    return_vector(robot_tool_on_outputs, 8)
    socket_send_lf()
    global response = "set_tool_on_outputs()"
  elif command[2] == 12:
    # Set tool off output
    robot_tool_off_outputs = command_3_padded_8(command)

    socket_send_string("robot_tool_off_outputs=")
    return_vector(robot_tool_off_outputs, 8)
    socket_send_lf()
    global response = "set_tool_off_outputs()"
  elif command[2] == 13:
    # Set coolant on output
    robot_coolant_on_outputs = command_3_padded_8(command)

    socket_send_string("robot_coolant_on_outputs=")
    return_vector(robot_coolant_on_outputs, 8)
    socket_send_lf()
    global response = "set_coolant_on_outputs()"
  elif command[2] == 14:
    # Set coolant off output
    robot_coolant_off_outputs = command_3_padded_8(command)

    socket_send_string("robot_coolant_off_outputs=")
    return_vector(robot_coolant_off_outputs, 8)
    socket_send_lf()
    global response = "set_coolant_off_outputs()"
  elif command[2] == 15:
    # tool_on
    tool_power(True, 2)
    global response = "tool_on()"
  elif command[2] == 16:
    # tool_off
    tool_power(False, 2)
    global response = "tool_off()"
  elif command[2] == 17:
    # coolant_on
    coolant_flow(True, 2)
    global response = "coolant_on()"
  elif command[2] == 18:
    # coolant_off
    coolant_flow(False, 2)
    global response = "coolant_off()"
  elif command[2] == 19:
    # freedrive 1=on/0=off, 0=base|1=tcp|2=tcp_part, 6 axisEnables
    if command[3] == 0:
      end_freedrive_mode()
      iset_tcp(robot_tcp)
      robot_freedrive_mode = 0
      socket_set_var("robot_freedrive_mode", robot_freedrive_mode)
    else:
      local coordSys = command[4]
      local freeAxes = [command[5], command[6], command[7], command[8], command[9], command[10]]
      if coordSys == 1:
        iset_tcp(robot_tcp)
        freedrive_mode(freeAxes = freeAxes, feature = "tool")
      elif coordSys == 2:
        iset_tcp(robot_tcp_part)
        freedrive_mode(freeAxes = freeAxes, feature = "tool")
      else:
        # Base
        freedrive_mode(freeAxes = freeAxes)
      end
      robot_freedrive_mode = 1
      socket_set_var("robot_freedrive_mode", robot_freedrive_mode)
    end
    global response = "freedrive_mode()"
  elif command[2] == 20:
    # set_tcp if command[3] > -10. Always returns robot_tcp=p[...]
    if command[3] > -10:
      robot_tcp = p[command[3], command[4], command[5], command[6], command[7], command[8]]
      iset_tcp(robot_tcp)
    end
    return_pose("robot_tcp", get_tcp_offset())
    # Recompute robot_tcp_part based on current geometry
    update_robot_tcp_part()
    global response = "set_tcp()"
  elif command[2] == 21:
    # set_payload if command[3] > 0. Always return robot_m and robot_cog
    if command[3] > 0:
      robot_payload_mass_kg = command[3]
      robot_payload_cog_m = [command[4], command[5], command[6]]
      iset_payload(robot_payload_mass_kg, robot_payload_cog_m)
    end
    socket_set_var("robot_payload_mass_kg", robot_payload_mass_kg)
    socket_send_string("robot_payload_cog_m=")
    return_vector(robot_payload_cog_m, 3)
    socket_send_lf()
    global response = "set_payload()"
  elif command[2] == 22:
    # Set footswitch pressed input
    if command[3] >= 0:
      robot_footswitch_pressed_input[0] = command[3]
      robot_footswitch_pressed_input[1] = command[4]
    end

    socket_send_string("robot_footswitch_pressed_input=")
    return_vector(robot_footswitch_pressed_input, 2)
    socket_send_lf()
    socket_set_var("robot_footswitch_pressed", is_footswitch_pressed())
    global response = "set footswitch_pressed_input()"
  elif command[2] == 30:
    # set_output
    local out = command[3]
    local state = command[4] > 0
    set_digital_out(out, state)
    global response = "set_output()"
  else:
    global response = "set_variable ERROR"
  end
end

# Compute appropriate robot_tcp for the part based on robot_tcp and robot_part_geometry
# They're the same for flat parts, but the TCP is adjusted to the center of the cylinder or sphere
def update_robot_tcp_part():
  shape = robot_part_geometry[0]
  if shape == 1:  # Flat
    robot_tcp_part = robot_tcp
  else:  # Cylinder or Sphere
    robot_tcp_part = pose_trans(robot_tcp, p[0, 0, robot_part_geometry[1] / 2000.0, 0, 0, 0])
  end
  return_pose("robot_tcp_part", robot_tcp_part)
end

# Send get_tcp_offset() result to socket
def return_tcp_offset():
  p = get_tcp_offset()
  return_pose("tcp_offset", p)
  global response = "return_tcp_offset()"
end

# Send get_actual_tcp_pose() to socket
def return_actual_tcp_pose():
  p = iget_actual_tcp_pose()
  return_pose("actual_tcp_pose", p)
  global response = "return_actual_tcp_pose()"
end

# Send get_actual_joint_positions() to socket
def return_get_actual_joint_positions():
  p = iget_actual_joint_positions()
  return_joints("actual_joint_positions", p)
  global response = "return_get_actual_joint_positions()"
end

# Send both joints and pose to socket labeled position_p and position_q
def return_both_positions():
  return_joints("position_q", iget_actual_joint_positions())
  return_pose("position_p", iget_actual_tcp_pose())
  global response = "return_both_positions()"
end

# Movel relatively in base coordinates
def movel_relative_base(p1):
  local p0 = get_target_tcp_pose()
  local p2 = pose_add(p0, p1)
  if p1[0] == 0 and p1[1] == 0 and p1[2] == 0:  # Rotational move
    imovel(p2, robot_joint_accel_rpss, robot_joint_speed_rps)
  else:
    imovel(p2, robot_linear_accel_mpss, robot_linear_speed_mps)
  end
  global response = "movel_relative_base()"
end

# Movel relatively in TCP coordinates
def movel_relative_tcp(p1):
  local p2 = pose_trans(get_target_tcp_pose(), p1)
  if p1[0] == 0 and p1[1] == 0 and p1[2] == 0:  # Rotational move
    imovel(p2, robot_joint_accel_rpss, robot_joint_speed_rps)
  else:
    imovel(p2, robot_linear_accel_mpss, robot_linear_speed_mps)
  end
  global response = "movel_relative_tcp()"
end

# Movel relatively in TCP_part coordinates
def movel_relative_tcp_part(p1):
  iset_tcp(robot_tcp_part)
  local p2 = pose_trans(get_target_tcp_pose(), p1)
  if p1[0] == 0 and p1[1] == 0 and p1[2] == 0:  # Rotational move
    imovel(p2, robot_joint_accel_rpss, robot_joint_speed_rps)
  else:
    imovel(p2, robot_linear_accel_mpss, robot_linear_speed_mps)
  end
  iset_tcp(robot_tcp)
  global response = "movel_relative_tcp_part()"
end

# Change one element of current pose and movel there
def movel_one_only(index = 0, val = 0):
  local p = get_target_tcp_pose()
  p[index] = val
  if index < 3:  # Translational
    imovel(p, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
  else:
    imovel(p, a = robot_joint_accel_rpss, v = robot_joint_speed_rps)
  end
  global response = "movel_one_only()"
end

# Change only rotation elements of current pose and movel there
def movel_rot_only(r1 = 0, r2 = 0, r3 = 0):
  local p = get_target_tcp_pose()
  p[3] = r1
  p[4] = r2
  p[5] = r3
  imovel(p, a = robot_joint_accel_rpss, v = robot_joint_speed_rps)
  global response = "movel_rot_only()"
end

# Movej to position (works with joints or poses)
def movej_ag(p):
  imovej(p, a = robot_joint_accel_rpss, v = robot_joint_speed_rps)
  global response = "movej_ag()"
end

# Movel to position (works with joints or poses)
def movel_ag(p):
  imovel(p, a = robot_linear_accel_mpss, v = robot_linear_speed_mps)
  global response = "movel_ag()"
end

# ####################################################################################
# Interrupting Motion
# Motion and force_mode and part contact muct all end if any of 3 things happen
#  1) Door is opened
#  2) We're in contact with the part and grinding, but no grind command comes within some time (default 1.5s)
#  3) We receive an abort message from the host
#
# How is it implemented?
#
# 1) io_monitor_thread (below) is ALWAYS running. Fires every time_door_check_rate_s (0.25s)
#    - Whenever it sees the state of the door change, it sends SET robot_door_closed state to host
#    - Whenever it sees the state of the footswitch (DIN7) change, it sends SET robot_footswitch state to host
#    - It monitors if we're still in contact wth the part butr not grinding (grind_process_state and grind_ready)
#      - If that goes beyond grind_max_wait_ms it sets halt_grind=True
# 2) no_command function (below). Called by PolScript everyu time it's waiting for a command and doesn't get one with a second
#    - If halt_grind is set (by door monitor thread above)
#      - stopl and simulate receiving a grind_retract
#      - THIS FORCES THE force_off and motion commands to come from the primary thread, as they must
# 3) listener_thread started by grind()
#    - This runs only while a grind is in progress
#    - It listens for commands from the host since PolyScope is blocked
#    - Any command received increments halt_count which makes ok_to_proceed() false
#    - That is checked in all the grinding programs and forces them to finish up and get off the part in an orderly fashion

# ####################################################################################
# START AUTOMATED DOOR MONITORING THREAD
#
# Return True if door in closed state (or if door input is undefined)
def is_door_closed():
  if robot_door_closed_input[0] < 0:
    return True
  end
  if get_standard_digital_in(robot_door_closed_input[0]):
    f = 1
  else:
    f = 0
  end
  return f == robot_door_closed_input[1]
end

# Return True if footswitch pressed (or False if footswitch input is undefined)
def is_footswitch_pressed():
  if robot_footswitch_pressed_input[0] < 0:
    return False
  end
  if get_standard_digital_in(robot_footswitch_pressed_input[0]):
    f = 1
  else:
    f = 0
  end
  return f == robot_footswitch_pressed_input[1]
end

global robot_door_closed = is_door_closed()
global robot_footswitch_pressed = is_footswitch_pressed()
global time_in_uncommanded_grind = 0
global time_door_check_rate_s = 0.250
global grind_max_wait_ms = 1500
# Also monitors footswitch!
thread io_monitor_thread():
  # Send current state on start... in future will only be sent on change
  socket_set_var("robot_door_closed", robot_door_closed)
  socket_set_var("robot_footswitch_pressed", robot_footswitch_pressed)

  while True:
    sleep(time_door_check_rate_s)
    local new_door_closed = is_door_closed()
    local new_footswitch_pressed = is_footswitch_pressed()

    # Notify host if door state has changed
    if robot_door_closed != new_door_closed:
      robot_door_closed = new_door_closed
      socket_set_var("robot_door_closed", robot_door_closed)
    end

    # Notify host if footswitch state has changed
    if robot_footswitch_pressed != new_footswitch_pressed:
      robot_footswitch_pressed = new_footswitch_pressed
      socket_set_var("robot_footswitch_pressed", robot_footswitch_pressed)
    end

    # Check for still in grind process but not executing a grind command
    # This is what happens after a grind_...(....,1) executes while waiting for next command
    if grind_process_state and grind_ready:
      time_in_uncommanded_grind = time_in_uncommanded_grind + time_door_check_rate_s
      # No new grind commands for grind_max_wait_ms... schedule a grind_retract!
      if time_in_uncommanded_grind > grind_max_wait_ms / 1000.0:
        global halt_grind = True
      end
    else:
      time_in_uncommanded_grind = 0
    end
  end
end
global ioMonitorThread = run io_monitor_thread()
#
# END AUTOMATED DOOR MONITORING THREAD
# ####################################################################################

# ####################################################################################
# START NO_COMMAND HOUSEKEEPING
# This gets called when the PolyScope receives no command (about 1/second)
# We can fire off any command here safely since no others will be seen until we exit
#
global no_command_count = 0
global halt_grind = False
def no_command():
  global no_command_count = no_command_count + 1

  if grind_process_state and grind_ready and halt_grind:
    halt_grind = False
    istopl(20)

    iset_tcp(robot_tcp_part)
    set_grind_process_state(False)
    iset_tcp(robot_tcp)
  end
end
#
# END NO_COMMAND HOUSEKEEPING
# ####################################################################################

# ####################################################################################
# START TOUCHOFF HANDLER
#
def calculate_point_to_move_towards(feature, direction, position_distance):
  local posDir = [direction[0], direction[1], direction[2]]
  if (norm(posDir) < 1e-6):
    return get_target_waypoint()
  end
  local direction_vector_normalized = normalize(posDir)
  local displacement_pose = p[direction_vector_normalized[0] * position_distance, direction_vector_normalized[1] * position_distance, direction_vector_normalized[2] * position_distance, 0, 0, 0]
  local wanted_displacement_in_base_frame = pose_sub(pose_trans(feature, displacement_pose), feature)
  return pose_add(get_target_waypoint(), wanted_displacement_in_base_frame)
end
#$ 7 "Robot Program"
#$ 8 "MoveL"
#$ 9 "Direction: Tool Z+"
global move_thread_flag = 0
global move_thread_approach_speed_mps = 0.01
thread move_thread():
  enter_critical
  move_thread_flag = 1
  local towardsPos = calculate_point_to_move_towards(get_forward_kin(), [0.0, 0.0, 1.0], 0.025)
  imovel(towardsPos, a = 0.5, v = move_thread_approach_speed_mps)
  move_thread_flag = 2
  exit_critical
end
# Currently using speed_mmps for both approach and 2X for departure
def touchoff(approach_speed_mmps, retract_mm):
  approach_speed_mps = approach_speed_mmps / 1000.0
  global move_thread_approach_speed_mps = approach_speed_mps

  retract_speed_mps = approach_speed_mps * 2.0

  retract_m = retract_mm / 1000.0

  move_thread_flag = 0
  move_thread_han = run move_thread()
  while (True):
    local targetTcpDirection = get_target_tcp_speed()
    local stepsToRetract = tool_contact(direction = targetTcpDirection)
    if (stepsToRetract > 0):
      kill move_thread_han
      imover_restart()
      istopl(20)
      local backTrackMovement = get_actual_joint_positions_history(stepsToRetract)
      local contactPose = get_forward_kin(backTrackMovement)
      local posDir = [targetTcpDirection[0], targetTcpDirection[1], targetTcpDirection[2]]
      local retractTo = contactPose
      if (norm(posDir) > 1e-6):
        local normalizedPosDir = normalize(posDir)
        local additionalRetraction = p[normalizedPosDir[0] * retract_m, normalizedPosDir[1] * retract_m, normalizedPosDir[2] * retract_m, 0, 0, 0]
        retractTo = pose_sub(contactPose, additionalRetraction)
      end
      imovel(retractTo, a = 1.0, v = retract_speed_mps)
      #$ 10 "Until (tool_contact_detection)"
      return True
      break
    end
    sleep(1.0E-10)
    if (move_thread_flag > 1):
      join move_thread_han
      #$ 11 "Until (distance)"
      #$ 12 "Popup: No part encountered"
      #popup("No part encountered", "Message", False, False, blocking = True)
      return False
      break
    end
    sync()
  end
  return False
end
#
# END TOUCHOFF HANDLER
# ####################################################################################

# ####################################################################################
# START IMOVER SYSTEM
#
global imover_enable = True
global imover_p = p[0, 0, 0, 0, 0, 0]
global imover_q = [0, 0, 0, 0, 0, 0]
global imover_a = 1.2
global imover_v = 0.25
global imover_t = 0
global imover_r = 0
global imover_f = False
global imover_tcp = p[0, 0, 0, 0, 0, 0]
global imover_mass = 1.0
global imover_cog = [0, 0, 0]
global imover_thread_handle = 0
global imover_cmd = 0
global imover_cmd_hist = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
global imover_param1 = 0
global imover_param2 = 0
imover_PING = 1
imover_MOVEL = 2
imover_MOVEJ = 3
imover_STOPL = 4
imover_STARTFORCE = 5
imover_UPDATEFORCE = 6
imover_ENDFORCE = 7
imover_GETACTUALTCPPOSE = 8
imover_GETACTUALJOINTPOSITIONS = 9
imover_SETTCP = 10
imover_SETPAYLOAD = 11
imover_TOUCHOFF = 12

def imover_wait(terminate_not_ok = False):
  while imover_cmd > 0:
    if terminate_not_ok and not ok_to_proceed():
      return None
    end
    sync()
  end
end

def imover_cmd_exec(cmd, param1 = 0, param2 = 0, terminate_not_ok = False, no_wait = False):
  imover_wait()
  global imover_param1 = param1
  global imover_param2 = param2

  local i = 9
  while i > 0:
    imover_cmd_hist[i] = imover_cmd_hist[i - 1]
    i = i - 1
  end
  imover_cmd_hist[0] = cmd
  global imover_cmd = cmd

  if not no_wait:
    imover_wait(terminate_not_ok)
  end
end

def imover_abort():
  if imover_thread_handle > 0:
    kill imover_thread_handle
    imover_thread_handle = 0
  end
  set_tcp(imover_tcp)
  set_payload(imover_mass, imover_cog)
end

def imover_restart():
  imover_abort()
  global imover_thread_handle = run imover_thread()
  iset_tcp(imover_tcp)
  iset_payload(imover_mass, imover_cog)
end

def istopl(a, aRot = 999):
  if imover_enable:
    imover_cmd_exec(imover_STOPL, a, aRot)
  else:
    if aRot == 999:
      stopl(a)
    else:
      stopl(a, aRot)
    end
  end
end

def iforce_mode(force_n, approach_speed_mmps):
  if imover_enable:
    imover_cmd_exec(imover_STARTFORCE, force_n, approach_speed_mmps)
  else:
    sleep(0.25)
    zero_ftsensor()

    # Using the defaults here
    force_mode_set_damping(0)
    force_mode_set_gain_scaling(1)

    # Force is in tool frame
    # Compliant in Tool Z
    # Applying grind_force_n in Z+
    # 2: Force frame not transformed
    # Speed limits
    force_mode(tool_pose(), [0, 0, 1, 0, 0, 0], [0.0, 0.0, force_n, 0.0, 0.0, 0.0], 2, [0.1, 0.1, approach_speed_mmps / 1000.0, 0.3490658503988659, 0.3490658503988659, 0.3490658503988659])
  end
end

def iforce_update(force_n = 5, approach_speed_mmps = 10):
  if imover_enable:
    imover_cmd_exec(imover_UPDATEFORCE, force_n, approach_speed_mmps)
  else:
    # Force is in tool frame
    # Compliant in Tool Z
    # Applying grind_force_n in Z+
    # 2: Force frame not transformed
    # Speed limits
    force_mode(tool_pose(), [0, 0, 1, 0, 0, 0], [0.0, 0.0, force_n, 0.0, 0.0, 0.0], 2, [0.1, 0.1, approach_speed_mmps / 1000.0, 0.3490658503988659, 0.3490658503988659, 0.3490658503988659])
  end
end

def iend_force_mode():
  if imover_enable:
    imover_cmd_exec(imover_ENDFORCE)
  else:
    end_force_mode()
  end
end

def iget_actual_tcp_pose():
  if imover_enable:
    imover_cmd_exec(imover_GETACTUALTCPPOSE)
    return imover_p
  else:
    return get_actual_tcp_pose()
  end
end

def iget_actual_joint_positions():
  if imover_enable:
    imover_cmd_exec(imover_GETACTUALJOINTPOSITIONS)
    return imover_q
  else:
    return get_actual_joint_positions()
  end
end

def iset_tcp(tcp):
  if imover_enable:
    imover_tcp = tcp
    imover_cmd_exec(imover_SETTCP)
    return imover_q
  else:
    set_tcp(tcp)
  end
end

def iset_payload(mass, cog):
  if imover_enable:
    imover_mass = mass
    imover_cog = cog
    imover_cmd_exec(imover_SETPAYLOAD)
  else:
    set_payload(mass, cog)
  end
end

def itouchoff(speed_mmps, retract_mm):
  if False: #imover_enable:
    imover_param1 = speed_mmps
    imover_param2 = retract_mm
    imover_cmd_exec(imover_TOUCHOFF)
    return imover_f
  else:
    return touchoff(speed_mmps, retract_mm)
  end
end

def imovel(p, a = 1.2, v = 0.25, t = 0, r = 0):
  if imover_enable:
    imover_wait()
    global imover_p = p
    global imover_a = a
    global imover_v = v
    global imover_t = t
    global imover_r = r
    imover_cmd_exec(imover_MOVEL, 0, 0, True)
  else:
    movel(p, a = a, v = v, t = t, r = r)
  end
end

def imovel_int(p, a = 1.2, v = 0.25, t = 0, r = 0, no_wait = False):
  if not ok_to_proceed():
    return None
  end

  if imover_enable:
    imover_wait()
    global imover_p = p
    global imover_a = a
    global imover_v = v
    global imover_t = t
    global imover_r = r
    imover_cmd_exec(imover_MOVEL, 0, 0, True, no_wait)
    if not ok_to_proceed():
      imover_restart()
      istopl(grind_accel_mpss, grind_rot_accel_rpss)
    end
  else:
    movel(p, a = a, v = v, t = t, r = r)
  end
end

def imovej(q, a = 1.2, v = 0.25, t = 0, r = 0):
  if imover_enable:
    imover_wait()
    global imover_q = q
    global imover_a = a
    global imover_v = v
    global imover_t = t
    global imover_r = r
    imover_cmd_exec(imover_MOVEJ, 0, 0, True)
  else:
    movej(q, a = a, v = v, t = t, r = r)
  end
end

thread imover_thread():
  global imover_cmd = 0
  while True:
    if imover_cmd == imover_MOVEL:
      movel(imover_p, a = imover_a, v = imover_v, t = imover_t, r = imover_r)
      global imover_cmd = 0
    elif imover_cmd == imover_MOVEJ:
      movej(imover_q, imover_a, imover_v, imover_t, imover_r)
      global imover_cmd = 0
    elif imover_cmd == imover_STOPL:
      stopl(grind_speed_mps, grind_rot_speed_rps)
      global imover_cmd = 0
    elif imover_cmd == imover_STARTFORCE:
      # Settle and zero the force/torque sensor
      sleep(0.25)
      zero_ftsensor()

      # Using the defaults here
      force_mode_set_damping(0)
      force_mode_set_gain_scaling(1)

      # Force is in tool frame
      # Compliant in Tool Z
      # Applying grind_force_n in Z+
      # 2: Force frame not transformed
      # Speed limits
      force_mode(tool_pose(), [0, 0, 1, 0, 0, 0], [0.0, 0.0, imover_param1, 0.0, 0.0, 0.0], 2, [0.1, 0.1, imover_param2 / 1000.0, 0.3490658503988659, 0.3490658503988659, 0.3490658503988659])
      global imover_cmd = 0
    elif imover_cmd == imover_UPDATEFORCE:
      # Update force
      # Force is in tool frame
      # Compliant in Tool Z
      # Applying grind_force_n in Z+
      # 2: Force frame not transformed
      # Speed limits
      force_mode(tool_pose(), [0, 0, 1, 0, 0, 0], [0.0, 0.0, imover_param1, 0.0, 0.0, 0.0], 2, [0.1, 0.1, imover_param2 / 1000.0, 0.3490658503988659, 0.3490658503988659, 0.3490658503988659])
      global imover_cmd = 0
    elif imover_cmd == imover_ENDFORCE:
      end_force_mode()
      global imover_cmd = 0
    elif imover_cmd == imover_GETACTUALTCPPOSE:
      imover_p = get_actual_tcp_pose()
      global imover_cmd = 0
    elif imover_cmd == imover_GETACTUALJOINTPOSITIONS:
      imover_q = get_actual_joint_positions()
      global imover_cmd = 0
    elif imover_cmd == imover_SETTCP:
      set_tcp(imover_tcp)
      global imover_cmd = 0
    elif imover_cmd == imover_SETPAYLOAD:
      set_payload(imover_mass, imover_cog)
      global imover_cmd = 0
    elif imover_cmd == imover_TOUCHOFF:
      imover_f = touchoff(imover_param1, imover_param2)
      global imover_cmd = 0
    elif imover_cmd == imover_PING:
      global imover_cmd = 0
    end
    sync()
  end
end
global imover_thread_handle = run imover_thread()
#
# END IMOVER SYSTEM
# ####################################################################################
